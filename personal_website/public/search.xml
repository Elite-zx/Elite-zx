<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>assembly language</title>
    <url>/2023/03/06/assemble/</url>
    <content><![CDATA[<p><meta name="referrer" content="no-referrer"><br><a name="MTE7s"></a></p>
<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的attack lab完成了</p>
<h2 id><a href="#" class="headerlink" title></a><span id="more"></span></h2><p><a name="PhqOH"></a></p>
<h1 id="实验1-查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验1-查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验1 查看CPU和内存，用机器指令和汇编指令编程"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h1><p><a name="xymUo"></a></p>
<h2 id="debug环境搭建：参考此文"><a href="#debug环境搭建：参考此文" class="headerlink" title="debug环境搭建：参考此文"></a>debug环境搭建：<a href="https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506">参考此文</a></h2><p><a name="UrdzB"></a></p>
<h2 id="assignment-1"><a href="#assignment-1" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li>用A命令向内存中写入汇编指令，用U命令查看</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249473372-3a80b2ab-d9e2-483c-ac41-140d30fdd765.png" alt="image.png"></p>
<ol>
<li>用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249669344-d36231e5-8310-46ba-a3c6-155e2601ff58.png" alt="image.png"><br><a name="rTW1r"></a></p>
<h2 id="assignment-2"><a href="#assignment-2" class="headerlink" title="assignment 2"></a>assignment 2</h2><ol>
<li>写入并查看指令</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250172971-61fbb876-feda-4ca9-b81d-e558cc0e5a6a.png" alt="image.png"></p>
<ol>
<li>修改_CS:IP_指向</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250237721-ec3e62f5-f6bc-4890-8f25-b62f6d89e60e.png" alt="image.png"></p>
<ol>
<li>执行指令，计算$2^8$，结果为 $AX = 0100H$</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250558182-3582fd8d-9783-421c-9731-0d83ae5c81a8.png" alt="image.png"><br><a name="QAZ3Z"></a></p>
<h2 id="assignment-3"><a href="#assignment-3" class="headerlink" title="assignment 3"></a>assignment 3</h2><ol>
<li>用D命令查找，最终在$FFFF5H \to FFFFCH（FFFF:0005 \to FFFF:000C）$发现$dd/mm/yy$字样的生产日期</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251622812-ca79ef23-5a2a-46b2-ba9f-326aa9d3bc54.png" alt="image.png"></p>
<ol>
<li>尝试用E命令修改，该操作失效，因为这是ROM</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251941938-25cdf39e-5c26-49a3-81da-f108dff28da7.png" alt="image.png"><br><a name="CHS7t"></a></p>
<h2 id="assignment-4"><a href="#assignment-4" class="headerlink" title="assignment 4"></a>assignment 4</h2><p>1.$A0000H \to BFFFFH$对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253290191-823908a7-61e0-4e4d-ac20-66184b8a4509.png" alt="image.png"></p>
<hr>
<p><a name="hcb7h"></a></p>
<h1 id="实验2-用机器指令和汇编指令编程"><a href="#实验2-用机器指令和汇编指令编程" class="headerlink" title="实验2 用机器指令和汇编指令编程"></a>实验2 用机器指令和汇编指令编程</h1><p><a name="vDc8z"></a></p>
<h2 id="assignment-1-1"><a href="#assignment-1-1" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li>用A指令向内存中写入汇编指令，用U指令查看</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596808599-b129a717-4d20-42a3-8823-64dc726440e3.png" alt="image.png"></p>
<ol>
<li>修改CS:IP使其指向代码段</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596896692-f6335ebe-e9b7-44cf-9a38-d686dde7d140.png" alt="image.png"></p>
<ol>
<li>t命令逐步执行指令后查看AX、BX、SP寄存器内容</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673597028389-791ccf84-0268-4f23-976f-53e6ecd97b36.png" alt="image.png"><br><a name="NB9fg"></a></p>
<h2 id="assignment-2-1"><a href="#assignment-2-1" class="headerlink" title="assignment 2"></a>assignment 2</h2><p>在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）</p>
<hr>
<p><a name="jpe3I"></a></p>
<h1 id="实验3-编程、编译、链接、跟踪"><a href="#实验3-编程、编译、链接、跟踪" class="headerlink" title="实验3 编程、编译、链接、跟踪"></a>实验3 编程、编译、链接、跟踪</h1><p><a name="QMUAH"></a></p>
<h2 id="assignment-1-2"><a href="#assignment-1-2" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li>编译链接生成可执行文件</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673681789903-cb9f13be-b044-4c3f-be1d-8fa401195306.png" alt="image.png"><br><a name="bm7kI"></a></p>
<h2 id="assignment-2-2"><a href="#assignment-2-2" class="headerlink" title="assignment 2"></a>assignment 2</h2><ol>
<li>debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为$DS=075C$，则PSP的地址为$075C:0$，程序的地址为$076C:0\;(075C+10:0)$,$CS:IP = 076C:0000$</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682350829-98451696-0d75-4414-87c5-b527b5c96169.png" alt="image.png"></p>
<ol>
<li>跟踪程序执行过程</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682565168-917f19d2-8e0c-44ab-84e5-453c301bcda0.png" alt="image.png"><br><a name="fqp3r"></a></p>
<h2 id="assignment-3-1"><a href="#assignment-3-1" class="headerlink" title="assignment 3"></a>assignment 3</h2><ol>
<li>查看PSP的内容</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682886059-386e1af8-2b73-480f-92b1-d2ea01cce40a.png" alt="image.png"></p>
<hr>
<p><a name="eTiIA"></a></p>
<h1 id="实验4-bx-和loop的使用"><a href="#实验4-bx-和loop的使用" class="headerlink" title="实验4 [bx]和loop的使用"></a>实验4 [bx]和loop的使用</h1><p><a name="Ypsn2"></a></p>
<h2 id="assignment-1-3"><a href="#assignment-1-3" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li><p>编写源程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax, 0020H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov dx, 0</span><br><span class="line">mov cx, 64</span><br><span class="line"></span><br><span class="line">s: </span><br><span class="line">mov [bx],dx</span><br><span class="line">inc bx</span><br><span class="line">inc dx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译，链接生成可执行文件</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673769654198-dcf5a11b-b298-4d67-ac52-e6412baa7953.png" alt="image.png"></p>
<ol>
<li>查看载入内存的程序，可以看见标签s已被替换为地址$076C:000E$</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770040980-f6175097-5e41-41f0-a0d4-ed6dcc9e2d26.png" alt="image.png"></p>
<ol>
<li>执行程序，验证结果，正确</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770269260-0b535c86-7318-4bea-9b9b-151df8786503.png" alt="image.png"><br><a name="q95Oy"></a></p>
<h2 id="assignment-2-3"><a href="#assignment-2-3" class="headerlink" title="assignment 2"></a>assignment 2</h2><ol>
<li><p>编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax, 0020H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 64</span><br><span class="line"></span><br><span class="line">s: </span><br><span class="line">mov [bx],bx</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它步骤与assigment 1一致，验证结果，正确</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673771416582-e853218d-46c6-4bf8-98d6-cacae4200dbb.png" alt="image.png"><br><a name="b3BKL"></a></p>
<h2 id="assignment-3-2"><a href="#assignment-3-2" class="headerlink" title="assignment 3"></a>assignment 3</h2><ol>
<li>复制的是什么：复制程序的第一条指令<code>mov ax,cs</code>到 <code>loop s</code> 指令至内存地址$0020:0000$处</li>
<li>如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在<code>mov cx,_____</code> 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：$076C:0000 \to 076C:0015$，共$16H\,(23D)$个字节,因此第二个空应该填入$16H$</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673774640766-de55642e-4594-4add-9f75-ac17f9cf3628.png" alt="image.png"></p>
<hr>
<p><a name="l6DRo"></a></p>
<h1 id="实验5-编写、调试具有多个段的程序"><a href="#实验5-编写、调试具有多个段的程序" class="headerlink" title="实验5 编写、调试具有多个段的程序"></a>实验5 编写、调试具有多个段的程序</h1><p><a name="y07m5"></a></p>
<h2 id="assignment-1-4"><a href="#assignment-1-4" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li>将程序载入内存后查看，可知data段段地址为$076C$, stack段段地址为$076D$，code段段地址为$076E$</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877104816-d24fcee5-293b-4965-a116-55b74e84812c.png" alt="image.png"></p>
<ol>
<li>Q1：<code>G 001D</code>执行程序至程序返回前，用U命令查看data段内容: $0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H$，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877337524-5a528fcf-a7ec-47a7-ba04-6014616d76ff.png" alt="image.png"></p>
<ol>
<li>Q2：R命令查看各个段寄存器的值  $\to \;CS:076E$、 $DS:076C$、$SS:076D$</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877858110-72e7472f-1574-4c88-ae28-a064f40894e4.png" alt="image.png"></p>
<ol>
<li><p>Q3：data段和stack段分别占16个字节，因此设code段段地址为$X$，那么stack段段地址为$X-1H$，data段段地址为$X-2H$（做了assignment2后可以发现这里说法并不准确）<br><a name="qSFne"></a></p>
<h2 id="assignment-2-4"><a href="#assignment-2-4" class="headerlink" title="assignment 2"></a>assignment 2</h2></li>
<li><p>步骤与assigment1 完全一致</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878358257-7f67627a-48a8-45cf-bc4a-1f51e9552faa.png" alt="image.png"></p>
<ol>
<li><p>得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍<br><a name="AiceH"></a></p>
<h2 id="assignment-3-3"><a href="#assignment-3-3" class="headerlink" title="assignment 3"></a>assignment 3</h2></li>
<li><p>步骤与assignment1完全一致</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879121558-74eaedb2-acd9-4a9c-a318-e028bba49db2.png" alt="image.png"><br>2， 设code段段地址为$X$，那么data段段地址为$X+3H$，stack段段地址为$X+4H$<br><a name="NxsNH"></a></p>
<h2 id="assignment-4-1"><a href="#assignment-4-1" class="headerlink" title="assignment 4"></a>assignment 4</h2><p>如果去掉通知编译器程序的入口的<code>end start</code>语句，那么唯一可正确运行的是起始段为code段的程序3<br><a name="oVwXx"></a></p>
<h2 id="assignment-5"><a href="#assignment-5" class="headerlink" title="assignment 5"></a>assignment 5</h2><ol>
<li><p>编写源程序，注意在将段地址写入$DS$时，要借助一个寄存器充当介质，因为立即数无法直接写入$DS$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment </span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment </span><br><span class="line">db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 8</span><br><span class="line">s:</span><br><span class="line">mov dx, a</span><br><span class="line">mov ds,dx</span><br><span class="line">mov ax, [bx]</span><br><span class="line">mov dx, b</span><br><span class="line">mov ds,dx</span><br><span class="line">add ax, [bx]</span><br><span class="line">mov dx, c</span><br><span class="line">mov ds,dx</span><br><span class="line">mov [bx], ax</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>用debug跟踪程序，可以看到a段段地址：$076C$、b段段地址：$076D$、c段段地址：$076E$</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882442409-a3ef513e-eb43-4f18-abf5-ea6f262cc3f6.png" alt="image.png"></p>
<ol>
<li>执行程序，查看c段内容，正确</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882790995-352f2b4b-203d-458a-b5a2-878acfd29335.png" alt="image.png"><br><a name="azFBM"></a></p>
<h2 id="assignment-6"><a href="#assignment-6" class="headerlink" title="assignment 6"></a>assignment 6</h2><ol>
<li><p>编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment </span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start:</span><br><span class="line">mov ax, a</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, b </span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0010H</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 8</span><br><span class="line">s:</span><br><span class="line">push [bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>用debug跟踪程序，可以看到a段段地址： $076C$ 、 b段段地址：$076E$、code段段地址：$076F$</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885232599-a5e6bf92-ae97-421b-ad5b-904f427aef76.png" alt="image.png"></p>
<ol>
<li>执行程序，查看b段内容，正确</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885271367-eddf0cc8-98aa-4fe8-a38f-a014ed5f8179.png" alt="image.png"></p>
<hr>
<p><a name="O7BgM"></a></p>
<h1 id="实验6-实践课程中的程序"><a href="#实验6-实践课程中的程序" class="headerlink" title="实验6 实践课程中的程序"></a>实验6 实践课程中的程序</h1><p><a name="dyxQS"></a></p>
<h2 id="assignment-1-5"><a href="#assignment-1-5" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li><p>这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stacksg</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 10H</span><br><span class="line">mov ax, datasg</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 4</span><br><span class="line">s0:</span><br><span class="line">push cx</span><br><span class="line">mov si, 0</span><br><span class="line">mov cx, 3</span><br><span class="line">s:</span><br><span class="line">mov al, [bx+si]</span><br><span class="line">and al, 11011111B</span><br><span class="line">mov [bx+si], al</span><br><span class="line">inc si</span><br><span class="line">loop s </span><br><span class="line"></span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>跟踪程序，查看data段内容</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954476992-988989f0-7ba5-4132-8b53-011e5cfe1ce7.png" alt="image.png"></p>
<ol>
<li>执行程序后，查看data段内容，正确</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954644257-b63d5af0-f266-4057-b1e1-c513e09c9298.png" alt="image.png"><br><a name="pHbEJ"></a></p>
<h2 id="assignment-2-5"><a href="#assignment-2-5" class="headerlink" title="assignment 2"></a>assignment 2</h2><ol>
<li><p>编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">db &#x27;1. display      &#x27;</span><br><span class="line">db &#x27;2. brows        &#x27;</span><br><span class="line">db &#x27;3. replace      &#x27;</span><br><span class="line">db &#x27;4. modify       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stacksg</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 10H </span><br><span class="line">mov ax, datasg</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 4</span><br><span class="line">s0:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 4</span><br><span class="line">mov si, 0</span><br><span class="line">s: </span><br><span class="line">mov al, [bx+3+si]</span><br><span class="line">and al, 11011111B</span><br><span class="line">mov [bx+3+si], al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>跟踪程序，查看data段内容</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955793129-198d15a6-56f1-4375-a4c1-fa6d84e6aa7c.png" alt="image.png"></p>
<ol>
<li>执行程序，查看data段内容，正确</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955864652-707fd6d7-d65d-4be6-b3f9-bbcbbc27484b.png" alt="image.png"></p>
<hr>
<p><a name="MJU1z"></a></p>
<h1 id="实验7-寻址方式在结构化数据访问中的应用"><a href="#实验7-寻址方式在结构化数据访问中的应用" class="headerlink" title="实验7 寻址方式在结构化数据访问中的应用"></a>实验7 寻址方式在结构化数据访问中的应用</h1><ol>
<li><p>编写源程序，用<code>word ptr / byte ptr</code>指定内存单元大小主要应用在<code>div</code>指令或用于向内存写入立即数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">db 21 dup (&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack ;0776C</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 10H</span><br><span class="line">mov ax, data ; 076D</span><br><span class="line">mov es, ax</span><br><span class="line">mov ax, table ; 077b</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,21</span><br><span class="line"></span><br><span class="line">year:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 4</span><br><span class="line">mov di, 0</span><br><span class="line">char:</span><br><span class="line">mov al, es:[si]</span><br><span class="line">mov [bx+di], al</span><br><span class="line">inc di</span><br><span class="line">inc si</span><br><span class="line">loop char</span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop year</span><br><span class="line"></span><br><span class="line">mov cx, 21</span><br><span class="line">mov bx, 0</span><br><span class="line">income:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 2</span><br><span class="line">mov di, 0</span><br><span class="line">dwInt:</span><br><span class="line">mov ax, es:[si]</span><br><span class="line">mov [bx].5[di], ax</span><br><span class="line">add si, 2</span><br><span class="line">add di, 2</span><br><span class="line">loop dwInt</span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop income</span><br><span class="line"></span><br><span class="line">mov cx, 21</span><br><span class="line">mov bx, 0</span><br><span class="line">staff:</span><br><span class="line">mov ax, es:[si]</span><br><span class="line">mov [10+bx], ax</span><br><span class="line">add si, 2;</span><br><span class="line">add bx, 10H</span><br><span class="line">loop staff</span><br><span class="line"></span><br><span class="line">mov cx, 21</span><br><span class="line">mov bx, 0</span><br><span class="line">average:</span><br><span class="line">mov dx, [bx+7]</span><br><span class="line">mov ax, [bx+5]</span><br><span class="line">div word ptr [bx+0AH]</span><br><span class="line">mov [bx+0Dh], ax</span><br><span class="line">add bx, 10H</span><br><span class="line">loop average</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看原始table段的内容</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054412418-905eb553-63b9-4352-8fd3-87d9c57ec955.png" alt="image.png"></p>
<ol>
<li>执行程序后，查看table段的内容，正确</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054465034-493bafb1-d935-4da9-b3d0-07b0bdd54911.png" alt="image.png"><br><a name="wI3bu"></a></p>
<h1 id="实验8-分析一个奇怪的程序"><a href="#实验8-分析一个奇怪的程序" class="headerlink" title="实验8 分析一个奇怪的程序"></a>实验8 分析一个奇怪的程序</h1><ol>
<li>程序从$start$入口处开始执行，一个<code>nop</code>指令占一个字节并表示No operation，此处用了两个<code>nop</code>指令的目的是在$s$处预留两个字节的空间，程序执行<code>mov cs:[di], ax</code>之后$s$处的两个字节被试图写入<code>jmp short s1</code>，接着程序向下执行<code>jmp short s</code>使得程序跳转回$s$处开始执行。</li>
<li><code>jmp short s1</code>到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从$s2$跳转到$s1$，即从$s2$处的jmp指令的下一指令<code>nop</code>$(076C:0022)$跳转到$s1$处的<code>mov ax, 0</code>$(076C:0018)$，因为<code>jmp short 标号</code>是依据位移进行转移的指令，而此处位移大小为$0022H-0018H =-10D(F6H)$，所以$s$处的<code>jmp short s</code>指令的机器码为<code>EBF6</code>（刚好占两个字节，因此可以被正确写入$s$处）</li>
<li>执行$s$处的跳转指令，使得$IP = IP+(-10)$,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为<code>mov ax, 4c00H</code>$(000AH-0010H=0000H)$，程序从此处开始向下执行，最终可以正确退出</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674306714709-54439679-a96b-496d-97b1-de0f2c3abf77.png" alt="image.png"><br><a name="lZyJr"></a></p>
<h1 id="实验9-根据材料编程"><a href="#实验9-根据材料编程" class="headerlink" title="实验9 根据材料编程"></a>实验9 根据材料编程</h1><ol>
<li><p>编写源程序：最开始我试图用<code>mov address，data</code>的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据<code>welcome to masm!</code>，利用寄存器$ax$作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: </span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov bx, 0</span><br><span class="line">mov si, 1824</span><br><span class="line">mov cx, 10H</span><br><span class="line">s0:</span><br><span class="line">mov ah, 82H</span><br><span class="line">mov al, [bx]</span><br><span class="line">mov es:[si], ax</span><br><span class="line">inc bx</span><br><span class="line">add si, 2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov bx, 0 </span><br><span class="line">mov si, 1984</span><br><span class="line">mov cx, 10H</span><br><span class="line">s1:</span><br><span class="line">mov ah, 0A4H</span><br><span class="line">mov al, [bx]</span><br><span class="line">mov es:[si], ax</span><br><span class="line">inc bx</span><br><span class="line">add si, 2</span><br><span class="line">loop s1</span><br><span class="line"></span><br><span class="line">mov bx, 0 </span><br><span class="line">mov si, 2144</span><br><span class="line">mov cx, 10H</span><br><span class="line">s2:</span><br><span class="line">mov ah, 11110001B</span><br><span class="line">mov al, [bx]</span><br><span class="line">mov es:[si], ax</span><br><span class="line">inc bx</span><br><span class="line">add si, 2</span><br><span class="line">loop s2</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终效果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674447541217-19494cef-6da4-4fd3-b28c-6ad18c755471.png" alt="image.png"></p>
<p><a name="zPzcC"></a></p>
<h1 id="实验10-编写子程序"><a href="#实验10-编写子程序" class="headerlink" title="实验10 编写子程序"></a>实验10 编写子程序</h1><p><a name="Z9mXL"></a></p>
<h2 id="assignment-1-6"><a href="#assignment-1-6" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li><p>编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（<strong>注意入栈顺序与出栈顺序相反</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &quot;welcome to masm!&quot;, 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov dh, 8</span><br><span class="line">mov dl, 3</span><br><span class="line">mov cl, 2</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, stack</span><br><span class="line">mov sp, 20H</span><br><span class="line">mov si, 0</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov al, 160 ; 设置指定打印位置</span><br><span class="line">inc dh ; 行数从0开始</span><br><span class="line">mul dh ; 8位乘法，结果存储在ax中</span><br><span class="line">mov bx, ax</span><br><span class="line">mov al, 2</span><br><span class="line">mul dl</span><br><span class="line">add bx, ax</span><br><span class="line">mov ah, cl</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">mov cl, [si] ; 设置cx</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz ok ;判断字符串是否结束</span><br><span class="line"></span><br><span class="line">mov al, cl ; 设置字符属性和值</span><br><span class="line">mov es:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">add bx, 2</span><br><span class="line">jmp print</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674959885930-a6c4181a-e6a1-44cb-9ec8-cc5013b1314e.png" alt="image.png"><br><a name="gCr3l"></a></p>
<h2 id="assignment-2-6"><a href="#assignment-2-6" class="headerlink" title="assignment 2"></a>assignment 2</h2><ol>
<li><p>编写源程序，利用除法溢出公式 </p>
<pre><code>            $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$&lt;br /&gt;该公式的基本思想是将可能发生除法溢出的32位除法$X/n$，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法&lt;br /&gt;$(H/n)*65536 + (L/n)$&lt;br /&gt;**商（32位）：**&lt;br /&gt;高十六位为$int(H/2)*65536$,低十六为$int([rem(H/n)*65536+L]/n)$&lt;br /&gt;**余数（16位）：**&lt;br /&gt;$rem([rem(H/n)*65536+L]/n)$&lt;br /&gt;（注：对这个公式的理解有限）
</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line">mov ax, 4240H</span><br><span class="line">mov dx, 000FH</span><br><span class="line">mov cx, 0AH</span><br><span class="line">call divdw</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">divdw:</span><br><span class="line">push bx</span><br><span class="line"></span><br><span class="line">mov bx, ax ; 暂存L</span><br><span class="line">mov ax, dx ; H/N</span><br><span class="line">mov dx, 0</span><br><span class="line">div cx ; int(H/N)在ax中，rem(H/N)在dx中</span><br><span class="line"></span><br><span class="line">push ax ; 暂存int(H/N)，除数</span><br><span class="line"></span><br><span class="line">mov ax, bx; dx and ax constitute rem(H/N)*65535+L</span><br><span class="line">div cx ; ax store the result</span><br><span class="line">mov cx, dx</span><br><span class="line"></span><br><span class="line">pop dx ; int(H/N)</span><br><span class="line"></span><br><span class="line">pop bx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果正确</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675050216892-a6c856a5-19e3-42a9-9dae-62052e8d077c.png" alt="image.png"><br><a name="wHNVn"></a></p>
<h2 id="assignment-3-4"><a href="#assignment-3-4" class="headerlink" title="assignment 3"></a>assignment 3</h2><ol>
<li><p>编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db 10 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, 12666</span><br><span class="line">mov bx, data</span><br><span class="line">mov ds, bx</span><br><span class="line">mov si, 0</span><br><span class="line">mov bx, stack</span><br><span class="line">mov ss, bx</span><br><span class="line">mov sp, 20H</span><br><span class="line">call dtoc</span><br><span class="line"></span><br><span class="line">mov dh, 8</span><br><span class="line">mov dl, 3</span><br><span class="line">mov cl, 2</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">dtoc:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov dx, 0 ; 被除数高16位 置0</span><br><span class="line">mov bx, 10</span><br><span class="line">mov di, 0 ; 字符计数</span><br><span class="line"></span><br><span class="line">divide:</span><br><span class="line">mov cx, ax </span><br><span class="line">jcxz over</span><br><span class="line">inc di</span><br><span class="line">div bx ; 32位除法，商在ax，余数在dx</span><br><span class="line">add dx, 30H</span><br><span class="line">push dx</span><br><span class="line">mov dx, 0</span><br><span class="line">jmp divide</span><br><span class="line"></span><br><span class="line">over:</span><br><span class="line">mov cx, di</span><br><span class="line">move: </span><br><span class="line">pop bx</span><br><span class="line">mov [si], bl</span><br><span class="line">inc si</span><br><span class="line">loop move</span><br><span class="line"></span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov al, 160 ; 设置指定打印位置</span><br><span class="line">inc dh ; 行数从0开始</span><br><span class="line">mul dh ; 8位乘法，结果存储在ax中</span><br><span class="line">mov bx, ax</span><br><span class="line">mov dh, 0</span><br><span class="line">mov al, 2</span><br><span class="line">mul dl</span><br><span class="line">add bx, ax</span><br><span class="line">mov ah, cl</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">mov cl, [si] ; 设置cx</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz ok ;判断字符串是否结束</span><br><span class="line"></span><br><span class="line">mov al, cl ; 设置字符属性和值</span><br><span class="line">mov es:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">add bx, 2</span><br><span class="line">jmp print</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070403817-35e5aa0f-3d0c-42ab-803a-9d7dbf5bcb8a.png" alt="image.png"><br><a name="ww3wC"></a></p>
<h1 id="实验11-编写子程序"><a href="#实验11-编写子程序" class="headerlink" title="实验11 编写子程序"></a>实验11 编写子程序</h1><ol>
<li><p>编写源程序：主要用到了<code>cmp</code>指令和条件转移指令组合形成的if逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">datasg segment</span><br><span class="line">db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">begin:</span><br><span class="line">mov ax, datasg</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, 0</span><br><span class="line">call letterc</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">letterc:</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line"></span><br><span class="line">Capital:</span><br><span class="line">mov al, [si]</span><br><span class="line">mov cl, al</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz OK</span><br><span class="line">cmp al, 97</span><br><span class="line">jb NO</span><br><span class="line">cmp al, 122</span><br><span class="line">ja NO</span><br><span class="line">and al, 11011111B</span><br><span class="line">mov [si], al	</span><br><span class="line"></span><br><span class="line">NO:</span><br><span class="line">inc si</span><br><span class="line">jmp short Capital</span><br><span class="line"></span><br><span class="line">OK:</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142887049-1e6b7958-8779-4745-81f5-c6a536a232ca.png" alt="image.png"><br><a name="bk4z5"></a></p>
<h1 id="实验12-编写0号中断的处理程序"><a href="#实验12-编写0号中断的处理程序" class="headerlink" title="实验12 编写0号中断的处理程序"></a>实验12 编写0号中断的处理程序</h1><ol>
<li>编写源程序</li>
</ol>
<p>总体来说就3个任务：</p>
<ul>
<li>编写中断处理程序 </li>
<li>复制中断处理程序至内存空闲区域($0000:0200H\to0000:02FFH$)  </li>
<li>修改中断向量表（中断处理程序地址入口表）</li>
</ul>
<p>注意在用<code>jcxz</code>条件转移指令时，要<code>jmp short</code>回程序开头<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset do0 ; 076C:0028</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset do0end- offset do0; 0034H</span><br><span class="line">cld</span><br><span class="line">rep movsb ; 复制程序到0:200</span><br><span class="line"></span><br><span class="line">mov word ptr es:[0], 0200H</span><br><span class="line">mov word ptr es:[0+2], 0 ; 修改中断向量表</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">do0:</span><br><span class="line">jmp short do0start</span><br><span class="line">db &quot;divide error&quot;,0 </span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 160*12+34*2</span><br><span class="line"></span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, 202H</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">mov cL, [si]</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz ok</span><br><span class="line">mov ah, 04h ;red</span><br><span class="line">mov al, cl</span><br><span class="line">mov es:[di], ax</span><br><span class="line">inc si</span><br><span class="line">add di, 2 </span><br><span class="line">jmp short print</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">do0end: ;005C</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p>
<ol>
<li>运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675159533550-89caf027-f6da-4345-aa8c-e03159df600e.png" alt="image.png"><br><a name="YSdgF"></a></p>
<h1 id="实验13-编写、应用中断例程"><a href="#实验13-编写、应用中断例程" class="headerlink" title="实验13 编写、应用中断例程"></a>实验13 编写、应用中断例程</h1><p><a name="HHw6N"></a></p>
<h2 id="assignment-1-7"><a href="#assignment-1-7" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li><p>编写源程序：与lab10-1的show_str基本一致，只需将<code>call-ret</code>更改为 <code>int 7cH - iret</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset print</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset printed - offset print</span><br><span class="line">cld</span><br><span class="line">rep  movsb</span><br><span class="line"></span><br><span class="line">mov word ptr es:[7cH*4], 0200H</span><br><span class="line">mov word ptr es:[7cH*4+2], 0 </span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push ax</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov al, 160</span><br><span class="line">inc dh</span><br><span class="line">mul dh ; 160*(10+1) in ax</span><br><span class="line">mov bx, ax</span><br><span class="line">mov al, 2</span><br><span class="line">mul dl ; 10*2 in ax</span><br><span class="line">add bx, ax</span><br><span class="line">mov ah, cl</span><br><span class="line"></span><br><span class="line">stPrint:</span><br><span class="line">mov ch, 0</span><br><span class="line">mov cl, [si]</span><br><span class="line">jcxz ok</span><br><span class="line"></span><br><span class="line">mov al, cl</span><br><span class="line">mov es:[bx], ax</span><br><span class="line">add bx, 2</span><br><span class="line">inc si</span><br><span class="line">jmp short stPrint</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">printed:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675224733068-a783d5cd-5d35-46b5-8032-3c8938e8347a.png" alt="image.png"><br><a name="LKaNX"></a></p>
<h2 id="assignment-2-7"><a href="#assignment-2-7" class="headerlink" title="assignment 2"></a>assignment 2</h2><ol>
<li>编写源程序</li>
</ol>
<p>用中断例程实现loop指令，主要需要解决三个问题</p>
<ul>
<li>怎么取得标号$S$的段地址和偏移地址？</li>
</ul>
<p>有一对段地址$CS$和偏移地址$IP$在中断过程时被压入栈，标号的段地址就是该CS，标号           的偏移地址可由该IP加上转移地址(<code>offset s - offset se</code>)得到</p>
<ul>
<li>得到$S$的段地址和偏移地址后，如何设置$CS:IP$</li>
</ul>
<p>用<code>iret</code>指令：<code>pop IP , pop CS ,  popf</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset lp</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset lped - offset lp</span><br><span class="line">cld</span><br><span class="line">rep  movsb</span><br><span class="line"></span><br><span class="line">mov word ptr es:[7cH*4], 0200H</span><br><span class="line">mov word ptr es:[7cH*4+2], 0 </span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">lp:</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">push bp</span><br><span class="line">mov bp, sp</span><br><span class="line">add [bp+2], bx</span><br><span class="line">lpret:</span><br><span class="line">pop bp</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">lped:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p>
<ol>
<li>运行结果</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675237825483-f1ed3d6d-00cc-453b-91b3-757823355468.png" alt="image.png"><br><a name="TCCAl"></a></p>
<h2 id="assignment-3-5"><a href="#assignment-3-5" class="headerlink" title="assignment 3"></a>assignment 3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">s1: db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">s2: db &#x27;Never let it rest,&#x27;,&#x27;$&#x27; </span><br><span class="line">s3: db &#x27;Till good is better,&#x27;,&#x27;$&#x27;</span><br><span class="line">s4: db &#x27;And better,best.&#x27;, &#x27;$&#x27;</span><br><span class="line">s: dw offset s1, offset s2, offset s3, offset s4 </span><br><span class="line">row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">mov ax, cs </span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, offset s</span><br><span class="line">mov si, offset row</span><br><span class="line">mov cx, 4</span><br><span class="line">ok:</span><br><span class="line">mov bh, 0 </span><br><span class="line">mov dh, [si]</span><br><span class="line">mov dl, 0</span><br><span class="line">mov ah, 2 ; BIOS中断例程--设置光标</span><br><span class="line">int 10h </span><br><span class="line"></span><br><span class="line">mov dx, [bx]                                           </span><br><span class="line">mov ah, 9 ; DOS中断例程--打印字符串</span><br><span class="line">int 21h</span><br><span class="line">inc si</span><br><span class="line">add bx, 2</span><br><span class="line">loop ok</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H; DOS中断例程--程序返回，返回值在al</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><a name="zGspx"></a></p>
<h1 id="实验14-访问-CMOS-RAM"><a href="#实验14-访问-CMOS-RAM" class="headerlink" title="实验14 访问 CMOS RAM"></a>实验14 访问 CMOS RAM</h1><ol>
<li><p>编写源程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov al, 9</span><br><span class="line">mov bx, 160*12+36*2</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 8</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 7</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27; &#x27;</span><br><span class="line"></span><br><span class="line">mov al, 4</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 2</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 0</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">GetAscill:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">out 70H, al</span><br><span class="line">in al, 71H</span><br><span class="line"></span><br><span class="line">mov ah, al</span><br><span class="line">mov cl, 4</span><br><span class="line">shr ah, cl</span><br><span class="line">and al, 00001111B</span><br><span class="line"></span><br><span class="line">add ah, 30H</span><br><span class="line">add al, 30H</span><br><span class="line"></span><br><span class="line">mov dx, 0B800H</span><br><span class="line">mov es, dx</span><br><span class="line">mov es:[bx], ah </span><br><span class="line">mov byte ptr es:[bx+1], 02H ; green</span><br><span class="line">mov es:[bx+2], al</span><br><span class="line">mov byte ptr es:[bx+3], 02H</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675253920788-8fc4fee5-abeb-4e49-93bf-97e3873b6599.png" alt="image.png"><br><a name="yTwL0"></a></p>
<h1 id="实验15-安装新的int-9-中断例程"><a href="#实验15-安装新的int-9-中断例程" class="headerlink" title="实验15 安装新的int 9 中断例程"></a>实验15 安装新的int 9 中断例程</h1><p><a name="TIrMX"></a></p>
<h2 id="前置练习1"><a href="#前置练习1" class="headerlink" title="前置练习1"></a>前置练习1</h2><p>在屏幕中间依次显示$a\to z$,按Esc键后改变与颜色</p>
<ol>
<li><p>编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把<code>call dword ptr ds:[0]</code>写成了<code>call word ptr ds:[0]</code>，导致整个系统没有正确的int 9中断例程，因此出现了错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 64 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 40H</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop ds:[0]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop ds:[2] ; 保存原int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4], offset int9</span><br><span class="line">mov es:[9*4+2], cs;设置新的入口地址</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov dh, &#x27;a&#x27;</span><br><span class="line">s:</span><br><span class="line">mov es:[160*12+40*2], dh</span><br><span class="line">call delay</span><br><span class="line">inc dh</span><br><span class="line">cmp dh, &#x27;z&#x27;</span><br><span class="line">jna s ; 依次打印a~z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax, 0 </span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">push ds:[0]</span><br><span class="line">pop es:[9*4]</span><br><span class="line">push ds:[2]</span><br><span class="line">pop es:[9*4+2] ;恢复原int 9中断例程的入口地址</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax, 4C00h</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">delay:</span><br><span class="line">push ax</span><br><span class="line">push dx</span><br><span class="line">mov ax, 0</span><br><span class="line">mov dx, 10H</span><br><span class="line">se:</span><br><span class="line">sub ax, 1 ; 不能用dec</span><br><span class="line">sbb dx, 0</span><br><span class="line">cmp ax, 0</span><br><span class="line">jne se</span><br><span class="line">cmp dx, 0</span><br><span class="line">jne se</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret ; 延时</span><br><span class="line"></span><br><span class="line">int9:</span><br><span class="line">push ax</span><br><span class="line">push es</span><br><span class="line">in al, 60H</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">cmp al, 01H</span><br><span class="line">jne int9ret</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">inc byte ptr es:[160*12+40*2+1] ; 修改字符属性</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">pop es</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319548168-77f7b5a6-54bb-4526-b234-adb0e561004e.png" alt="image.png"><br><a name="vlBjq"></a></p>
<h2 id="前置练习2"><a href="#前置练习2" class="headerlink" title="前置练习2"></a>前置练习2</h2><p>在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理</p>
<ol>
<li><p>编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在$0:0200 \to 0:0203$,可在新int 9中断例程中通过<code>cs:[200H]</code>访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 32 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line"></span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0204H</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset int9</span><br><span class="line"></span><br><span class="line">mov cx, offset int9ed - offset int9</span><br><span class="line">cld</span><br><span class="line">rep movsb; 安装</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200H]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202H] ; 保存原int 9入口地址</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4], 204H</span><br><span class="line">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">int9:</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">in al, 60H</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr cs:[200H] ; 调用原int 9</span><br><span class="line"></span><br><span class="line">cmp al, 3BH</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 1</span><br><span class="line">mov cx, 2000</span><br><span class="line">s:</span><br><span class="line">inc byte ptr es:[di]</span><br><span class="line">add di, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">pop di</span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int9ed:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322759364-2785ad21-17c7-4499-b1a3-fe6726975b02.png" alt="image.png"><br><a name="XyIu0"></a></p>
<h2 id="assignment-1-8"><a href="#assignment-1-8" class="headerlink" title="assignment 1"></a>assignment 1</h2><ol>
<li>编写源程序</li>
</ol>
<p>与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码<code>cmp aL, 1EH+80H</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 32 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line"></span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0204H</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset int9</span><br><span class="line"></span><br><span class="line">mov cx, offset int9ed - offset int9</span><br><span class="line">cld</span><br><span class="line">rep movsb; 安装</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200H]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202H] ; 保存原int 9入口地址</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4], 204H</span><br><span class="line">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">int9:</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">in aL,60h</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr cs:[200H]</span><br><span class="line"></span><br><span class="line">cmp aL, 1EH+80H</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">mov cx, 2000</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0</span><br><span class="line">s:</span><br><span class="line">mov byte ptr es:[di], &#x27;A&#x27;</span><br><span class="line">mov byte ptr es:[di+1], 02H</span><br><span class="line">add di, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">pop di</span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">int9ed:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ol>
<li>运行结果</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675329053483-60588212-d9b5-4cef-acf7-06c70f65db5f.png" alt="image.png"><br><a name="YodIM"></a></p>
<h1 id="实验16-编写包含多个功能子程序的中断例程"><a href="#实验16-编写包含多个功能子程序的中断例程" class="headerlink" title="实验16 编写包含多个功能子程序的中断例程"></a>实验16 编写包含多个功能子程序的中断例程</h1><ol>
<li>编写源程序</li>
</ol>
<p>注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset int7ch</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset int7ched - offset int7ch</span><br><span class="line">cld</span><br><span class="line">rep  movsb</span><br><span class="line"></span><br><span class="line">mov word ptr es:[7cH*4], 0200H</span><br><span class="line">mov word ptr es:[7cH*4+2], 0 </span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">int7ch:</span><br><span class="line">jmp short int7chStart</span><br><span class="line">table dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200H</span><br><span class="line"></span><br><span class="line">int7chStart:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">cmp ah, 3</span><br><span class="line">ja int7chRet</span><br><span class="line">mov bl, ah</span><br><span class="line">mov bh, 0</span><br><span class="line">add bx, bx</span><br><span class="line">call word ptr cs:(table-int7ch+200H)[bx]</span><br><span class="line"></span><br><span class="line">int7chRet:</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">Sub1:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov cx, 2000</span><br><span class="line">mov bx, 0</span><br><span class="line">s1:</span><br><span class="line">mov byte ptr [bx], &#x27; &#x27;</span><br><span class="line">add bx, 2</span><br><span class="line">loop s1</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">Sub2:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">mov bx, 0B800H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov cx, 2000</span><br><span class="line">mov bx, 1</span><br><span class="line">s2:</span><br><span class="line">and byte ptr [bx], 11111000B ; 只设置最后3位</span><br><span class="line">or byte ptr [bx], al</span><br><span class="line">add bx, 2</span><br><span class="line">loop s2</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">Sub3:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">mov bx, 0B800H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov cl, 4</span><br><span class="line">shl al, cl</span><br><span class="line">mov cx, 2000</span><br><span class="line">mov bx, 1</span><br><span class="line">s3:</span><br><span class="line">and byte ptr [bx], 10001111B</span><br><span class="line">or [bx], al</span><br><span class="line">add bx, 2</span><br><span class="line">loop s3</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">Sub4:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line">mov bx, 08B00H</span><br><span class="line">mov es, bx</span><br><span class="line">mov ds, bx</span><br><span class="line">mov si, 160</span><br><span class="line">mov di, 0</span><br><span class="line">cld</span><br><span class="line">mov cx, 24</span><br><span class="line"></span><br><span class="line">s4:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 160</span><br><span class="line">rep movsb</span><br><span class="line">pop cx</span><br><span class="line">loop s4</span><br><span class="line"></span><br><span class="line">mov cx, 80</span><br><span class="line">mov si, 0</span><br><span class="line">s41:</span><br><span class="line">mov byte ptr [160*24+si], &#x27; &#x27;</span><br><span class="line">add si ,2</span><br><span class="line">loop s41</span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">int7ched:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ah,1 ; 0 2 3</span><br><span class="line">mov al,2</span><br><span class="line">int 7CH</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p>
<ol>
<li>运行结果</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411618416-c6c100a2-f4d1-4bc9-b3e6-22f83fcdcaee.png" alt="image.png"><br><a name="IRx7s"></a></p>
<h1 id="实验17-编写包含多个功能子程序的中断例程"><a href="#实验17-编写包含多个功能子程序的中断例程" class="headerlink" title="实验17 编写包含多个功能子程序的中断例程"></a>实验17 编写包含多个功能子程序的中断例程</h1><p>第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了<br><a name="upigZ"></a></p>
<h2 id="练习17-1"><a href="#练习17-1" class="headerlink" title="练习17-1"></a>练习17-1</h2><p>接受用户的键盘输入，输入”r”，”g”,“b”分别将屏幕上的字符设置为红色，绿色，蓝色</p>
<ol>
<li>编写源程序</li>
</ol>
<p>用功能号为0的int 16H中断例程读取键盘输入即可<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">show:</span><br><span class="line">push ax</span><br><span class="line">push es</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ah, 0</span><br><span class="line">int 16H</span><br><span class="line"></span><br><span class="line">mov bl, 1</span><br><span class="line">cmp al,&#x27;b&#x27;</span><br><span class="line">je showst</span><br><span class="line">shl bl, 1</span><br><span class="line">cmp al, &#x27;g&#x27;</span><br><span class="line">je showst</span><br><span class="line">shl bl, 1</span><br><span class="line">cmp al, &#x27;r&#x27;</span><br><span class="line">je showst</span><br><span class="line">jmp short FRet</span><br><span class="line"></span><br><span class="line">showst:</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 1</span><br><span class="line">mov cx, 2000</span><br><span class="line">s:</span><br><span class="line">and byte ptr es:[di], 11111000B</span><br><span class="line">or es:[di], bl</span><br><span class="line">add di, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">FRet:</span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p>
<ol>
<li>运行结果</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431818731-db0edf92-bc54-4bfc-a35f-613c796dddda.png" alt="image.png"><br><a name="Wyllk"></a></p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p><a name="QMCD1"></a></p>
<h2 id="1-理解assume伪指令的作用"><a href="#1-理解assume伪指令的作用" class="headerlink" title="1. 理解assume伪指令的作用"></a>1. 理解assume伪指令的作用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov si, 0</span><br><span class="line">mov cx, 8</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov ah, 0</span><br><span class="line">mov al, a[si]</span><br><span class="line">add b, ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ol>
<li><code>assume ds:data ss:stack</code></li>
</ol>
<ul>
<li>assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器$DS、SS$中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:<code>mov ax, data ``mov ds, ax</code></li>
<li>assume是伪指令，用于指示编译器将$DS、SS$分别与data段和stack段关联。①关联是什么意思呢？就是<strong>在编译时默认data段中的数据标号a、b的段地址在</strong>$DS$<strong>中</strong>，因此如果要正确访问到a、b的内容，必须用指令将data填入$DS$中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此<code>mov ax, data</code>在编译器看来是<code>mov ax, data段段地址</code>，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax</li>
</ul>
<p>如果在程序中省略<code>assume ds:data</code>，则会出现_不能用段寄存器寻址_的错误<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675343108877-68cf68d3-97ef-4ecb-8b4f-6da330149c94.png" alt="image.png"></p>
<ol>
<li><code>assume cs:codesg</code></li>
</ol>
<p>将$CS$与代码段关联，在程序加载时将代码段(codesg)的段地址放入$CS$中. 如果去掉该语句，则程序编译不通过，因为$CS$的值不确定<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675341791119-4c9029f0-b9e3-4e2f-b1b9-aa5d02685f8f.png" alt="image.png"><br><a name="wwfwW"></a></p>
<h2 id="2-理解数据标号"><a href="#2-理解数据标号" class="headerlink" title="2. 理解数据标号"></a>2. 理解数据标号</h2><ol>
<li>数据标号与地址标号的不同</li>
</ol>
<p>地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, es:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov si, 0</span><br><span class="line">mov cx, 8</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov ah, 0</span><br><span class="line">mov al, a[si]</span><br><span class="line">add b, ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><br>这里的a和b分别指代了</p>
<ul>
<li><strong>地址为</strong><code>**seg data:0**</code><strong>, 长度为byte的字节单元</strong></li>
<li><strong>地址为</strong><code>**seg data:8**</code><strong>, 长度为word的字单元</strong></li>
</ul>
<ol>
<li>如何用数据标号以简洁形式访问内存中的数据</li>
</ol>
<p>在上一个程序中，我们用<code>mov al, a[si]</code> <code>add b, ax</code>访问了data段的内容，在编译器看来，这两条语句是这样的: <code>mov al, es:0[si]``add es:[8], ax</code><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409971871-70ff728a-fa74-48ac-a742-be8ec319d677.png" alt="image.png"></p>
<ol>
<li>将标号当作数据定义<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a, b</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov dx, 2</span><br><span class="line">mov dx, c</span><br><span class="line">mov ax, c[1]</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<code>c dw a, b</code>将数据标号当作数据定义，c指代地址为<code>seg data:000A</code>的字单元，<strong>该字单元的内容是a的偏移地址</strong>$0000$，下面是验证<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409382345-20e1a2f2-8973-4150-992a-2a8acb141fa9.png" alt="image.png"></li>
</ol>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>[csapp] datalab, bomblab, attacklab</title>
    <url>/2023/03/06/csapp-lab/</url>
    <content><![CDATA[<p><meta name="referrer" content="no-referrer"><br><a name="IR5gF"></a></p>
<h1 id="lab1-dataLab"><a href="#lab1-dataLab" class="headerlink" title="lab1 dataLab"></a>lab1 dataLab</h1><span id="more"></span>
<p><a name="RKm5i"></a></p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>确保有一个linux系统，并已经执行过以下两条命令:<br>安装gcc：<code>sudo apt-get install build-essential</code>  <br>安装<a href="https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea">gcc的交叉编译环境</a>.)：<code>sudo apt-get install gcc-multilib</code>，因为实验的程序需要以32位方式编译<br>在<a href="http://csapp.cs.cmu.edu/3e/labs.html">CMU的CSAPP网站</a>上下载实验所需资料，包括<strong>README, Writeup，Self-Study Handout，</strong>这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件</p>
<p><a name="IOcHR"></a></p>
<h2 id="1-bitXor-x-y"><a href="#1-bitXor-x-y" class="headerlink" title="1.bitXor(x,y)"></a>1.bitXor(x,y)</h2><p>要用~和&amp;实现异或^，即将结果中 1-0，0-1对应的位设置为1<br>x&amp;y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br>(~x&amp;~y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br>两个做交集即为结果。（位向量可以表示集合，&amp;，|，~可视为 交，并，补操作）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment">Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment">Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment">Max ops: 14</span></span><br><span class="line"><span class="comment">Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  ~(x&amp;y) &amp; ~(~x&amp;~y) ; <span class="comment">// if regardless &#x27;+&#x27; is illegal:(~x&amp;y) + ((x)&amp;(~y)) or ~((x&amp;y) + ((~x)&amp;(~y)))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="mB5XE"></a></p>
<h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2.tmin"></a>2.tmin</h2><p>最简单的一题：<code>000...001</code> —&gt; <code>1000...000</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">Max ops: 4</span></span><br><span class="line"><span class="comment">Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmin</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="pr9MQ"></a></p>
<h2 id="3-isTmax-x"><a href="#3-isTmax-x" class="headerlink" title="3.isTmax(x)"></a>3.isTmax(x)</h2><p>这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了<code>!((~x) + (~x))</code>，但<a href="https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471">测试结果出乎意料</a>，加法溢出导致了未知的行为。<br>根据 Tmax +1 = Tmin 的性质可以得出 ,  <code>100...000</code> + <code>011...111</code> = <code>111..1111</code> (-1)，可得出<code>!(~x^(x+1))</code>（^可替换为+）<br>处理特例-1： -1同样会产生结果1，根据 <code>-1+1==0</code>,<code>Tmax+1!=0</code>，进而<code>!(-1+1) !=0</code> ，<code>!(Tmax+1) ==0</code>.<br>所以<code>对Tmax, x+(x+1) = x</code> , <code>对-1,x+(x+1)!=x</code><br>用<code>x+(x+1)</code> 替换原式中的第一项x，最终得出结果：<code>!(~((x+!(x+1))^(x+1)))</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment">and 0 otherwise </span></span><br><span class="line"><span class="comment">egal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment">Max ops: 10</span></span><br><span class="line"><span class="comment">Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(~((x+!(x+<span class="number">1</span>)) ^ (x+<span class="number">1</span>))) ; </span><br><span class="line">   <span class="comment">// !((~x) + (~x));  it should be right, the operator &quot;!&quot; seem to not work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="kHLgK"></a></p>
<h2 id="4-allOddBits-x"><a href="#4-allOddBits-x" class="headerlink" title="4.allOddBits(x)"></a>4.allOddBits(x)</h2><p>这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br>用好异或即可解决：构造<code>101...1010</code>，再用该数提取x中的奇数位，最后再与<code>101...1010</code>比较<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment">where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment">Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">Max ops: 12</span></span><br><span class="line"><span class="comment">Rating: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> allOdd = (<span class="number">0xAA</span> &lt;&lt; <span class="number">24</span>) + (<span class="number">0xAA</span> &lt;&lt; <span class="number">16</span>) + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>) + <span class="number">0xAA</span>; <span class="comment">// 10101010..101</span></span><br><span class="line">  <span class="keyword">return</span> ! ((allOdd &amp; x) ^ allOdd);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="sswhY"></a></p>
<h2 id="5-isAsciiDigit-x"><a href="#5-isAsciiDigit-x" class="headerlink" title="5.isAsciiDigit(x)"></a>5.isAsciiDigit(x)</h2><p>有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验—-用异或执行比较操作。<br>x的最后四位，3bit 与 1,2bit不能同时为1，因而有<code>!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)))</code>，难点在于怎么处理好式中三部分的逻辑关系<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mask1 = <span class="number">0x3</span>;   <span class="comment">// 000...0011</span></span><br><span class="line">  <span class="type">int</span> mask2 = <span class="number">0xA</span>;   <span class="comment">// 1010</span></span><br><span class="line">  <span class="type">int</span> mask3 = <span class="number">0xC</span>;   <span class="comment">// 1100</span></span><br><span class="line">  <span class="keyword">return</span>  !( ((x&gt;&gt;<span class="number">4</span>)^mask1) | (!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)) ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="DZZaa"></a></p>
<h2 id="6-conditional"><a href="#6-conditional" class="headerlink" title="6.conditional"></a>6.conditional</h2><p>比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br>涉及的操作是把x转化为0与1两个值，再把<code>000...0001</code>转化为<code>111...1111</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; </span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>  judge = !(x ^ <span class="number">0x0</span>); <span class="comment">// x=0 -&gt; judge=1,whereas x!=0 -&gt; judge=0</span></span><br><span class="line">  judge = (judge &lt;&lt; <span class="number">31</span>)&gt;&gt;<span class="number">31</span>; <span class="comment">// 000...000 or 111...111</span></span><br><span class="line">  <span class="keyword">return</span> ((~judge)&amp;y) | (judge&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="MZZvz"></a></p>
<h2 id="7-isLessOrEqual-x-y"><a href="#7-isLessOrEqual-x-y" class="headerlink" title="7.isLessOrEqual(x, y)"></a>7.isLessOrEqual(x, y)</h2><p>可通过减法<code>y-x&gt;=0</code>判断<code>x&lt;=y</code>，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br>那么这题就涉及加法溢出,需要对<code>x+uw  y</code>结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br>更好的想法是<strong>分析式子</strong><code>**y-x**</code><strong>并加入一个conditional操作</strong>：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> Tmin = <span class="number">1</span>&lt;&lt;<span class="number">31</span>; <span class="comment">// 100...0000</span></span><br><span class="line">  <span class="type">int</span> signY = Tmin &amp; y;</span><br><span class="line">  <span class="type">int</span> signX = Tmin &amp; x;</span><br><span class="line">  <span class="type">int</span> judge = (signY ^ signX)&lt;&lt;<span class="number">31</span>; </span><br><span class="line">  x = (~x)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (judge&amp;signX) | (~(judge&gt;&gt;<span class="number">31</span>) &amp; !((y+x)&amp;Tmin)) ; <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="WP1Li"></a></p>
<h2 id="8-logicalNeg-x"><a href="#8-logicalNeg-x" class="headerlink" title="8.logicalNeg(x)"></a>8.logicalNeg(x)</h2><p>这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br>于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的<strong>positive overflow</strong>现象，即 Tmax + x ，对任意x&gt;0均会使结果变为负数，符号位由0 —&gt;1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致<a href="http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3">undefined behavior</a>）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logi&#x27;calNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> Tmin = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> Tmax = ~Tmin;</span><br><span class="line">  <span class="type">int</span> signX = ((x&amp;Tmin)&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">return</span> (signX^<span class="number">0x1</span>) &amp; ((((x + Tmax)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>)^<span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="Y5Acb"></a></p>
<h2 id="9-howManyBits-x"><a href="#9-howManyBits-x" class="headerlink" title="9.howManyBits(x)"></a>9.howManyBits(x)</h2><p>这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：<strong>当数的符号位为1时，将数按符号位扩展之后其值不会变</strong>，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br>要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -&gt; 0010)<br>按二分法逐步缩小范围，找到最左边的1<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="type">int</span> signX = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = ((~signX) &amp; x) | (signX&amp;(~x));<span class="comment">// if x is negative, let sign bit:1-&gt; 0</span></span><br><span class="line">  </span><br><span class="line">  b16 = (!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>; <span class="comment">// ensure high 16 bits exist 1 or not</span></span><br><span class="line">  x=x&gt;&gt;b16;</span><br><span class="line">  b8 = (!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>; <span class="comment">// ensure high 8 bits </span></span><br><span class="line">  x=x&gt;&gt;b8;</span><br><span class="line">  b4 = (!!(x&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>; <span class="comment">// ensure high 4 bits </span></span><br><span class="line">  x=x&gt;&gt;b4;  </span><br><span class="line">  b2 = (!!(x&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>; <span class="comment">// ensure high 2 bits </span></span><br><span class="line">  x=x&gt;&gt;b2; </span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>); <span class="comment">// ensure 31 bits or not </span></span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> b0+b1+b2+b4+b8+b16+<span class="number">1</span>; <span class="comment">// 1: sign bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="glYde"></a></p>
<h2 id="10-floatScale2-uf"><a href="#10-floatScale2-uf" class="headerlink" title="10.floatScale2(uf)"></a>10.floatScale2(uf)</h2><p>先对题目做出一点解释：传入一个<code>unsigned</code>类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br><strong>整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论</strong><br>注意点：对normalized，f*2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么<code>frac = frac &lt;&lt;1</code>，这也使得denormalized能转化到normalized (smoothly)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument    // revision: NaN or infinity</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> musk_exp,musk_frac,sign,exp,frac,result;</span><br><span class="line">  musk_exp = <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  musk_frac = <span class="number">0x7FFFFF</span>;</span><br><span class="line">  exp = (uf &amp; musk_exp)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  frac = uf &amp; musk_frac;</span><br><span class="line">  sign = <span class="number">0x1</span>&lt;&lt;<span class="number">31</span> &amp; uf;</span><br><span class="line">  result = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span>(exp == <span class="number">0xFF</span>  ) <span class="comment">// NaN</span></span><br><span class="line">     result = uf;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp == <span class="number">0x0</span>) <span class="comment">// denormalized</span></span><br><span class="line">  &#123;  </span><br><span class="line">     <span class="keyword">if</span>(frac == <span class="number">0x0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(sign)  <span class="comment">// -0.0</span></span><br><span class="line">           result = uf;</span><br><span class="line">        <span class="keyword">else</span>     <span class="comment">// +0.0</span></span><br><span class="line">           result = <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">        frac = frac &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result = sign+ (exp&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp != <span class="number">0x0</span> &amp;&amp; exp != <span class="number">0xFF</span>) <span class="comment">// normalized</span></span><br><span class="line">  &#123;</span><br><span class="line">     exp += <span class="number">1</span>;</span><br><span class="line">     result = sign+ (exp&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="tO8yh"></a></p>
<h2 id="11-floatFloat2Int-uf"><a href="#11-floatFloat2Int-uf" class="headerlink" title="11.floatFloat2Int(uf)"></a>11.floatFloat2Int(uf)</h2><p>浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br>对题目的解释：返回浮点数f的int型表示，如输入<code>12345.0 (0x4640E400)</code>, 正确输出为<code>12345 (0x3039)</code><br>注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E&gt;31时，属于out of range<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> musk_exp,musk_frac,exp,frac,sign,E,Bias,result;</span><br><span class="line">  musk_exp = <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  musk_frac = <span class="number">0x7FFFFF</span>;</span><br><span class="line">  exp = (uf &amp; musk_exp)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  frac = uf &amp; musk_frac;</span><br><span class="line">  sign = <span class="number">0x1</span>&lt;&lt;<span class="number">31</span> &amp; uf;</span><br><span class="line">  Bias = <span class="number">127</span>;</span><br><span class="line">  result = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span>(exp == <span class="number">0xFF</span>  ) <span class="comment">// NaN or infinity</span></span><br><span class="line">     result = <span class="number">0x80000000</span>u;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp == <span class="number">0x0</span>)</span><br><span class="line">     result = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp != <span class="number">0x0</span> &amp;&amp; exp != <span class="number">0xFF</span>) <span class="comment">// normalized</span></span><br><span class="line">  &#123;</span><br><span class="line">     E = exp -Bias;  <span class="comment">// bit_num of fraction</span></span><br><span class="line">     <span class="keyword">if</span>(E &lt; <span class="number">0</span>)</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (E&gt;<span class="number">31</span>)</span><br><span class="line">        result = <span class="number">0x80000000</span>u;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">        frac = frac&gt;&gt;(<span class="number">23</span>-E);</span><br><span class="line">        result = (<span class="number">0x1</span> &lt;&lt; E) + frac ; </span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>)</span><br><span class="line">           result = - result;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="UlJMS"></a></p>
<h2 id="12-floatPower2-x"><a href="#12-floatPower2-x" class="headerlink" title="12.floatPower2(x)"></a>12.floatPower2(x)</h2><p>注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> exp,frac,E,Bias,result;</span><br><span class="line">  Bias = <span class="number">127</span>;</span><br><span class="line">  result = <span class="number">5</span>;</span><br><span class="line">  E = x;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">1</span> &amp;&amp; x!=<span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= <span class="number">0x1</span> || x == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     frac = <span class="number">0x0</span>;</span><br><span class="line">     exp = E+Bias;</span><br><span class="line">     <span class="keyword">if</span>(exp &gt; <span class="number">254</span>)  <span class="comment">// 1111 1110</span></span><br><span class="line">        &#123;</span><br><span class="line">           exp = <span class="number">0xFF</span>;</span><br><span class="line">           result = exp &lt;&lt;<span class="number">23</span>+frac;         </span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        result = (exp&lt;&lt;<span class="number">23</span>) + frac; </span><br><span class="line">  &#125;    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="iHsuB"></a></p>
<h2 id="consequence"><a href="#consequence" class="headerlink" title="consequence"></a>consequence</h2><p><code>make</code><br><code>./driver.pl</code><br><a name="SLl25"></a></p>
<h3 id><a href="#" class="headerlink" title></a><img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1669795434321-27bd7778-bde0-4d21-9ae0-425e1e785bd1.png" alt="data_lab_success.png"></h3><hr>
<p><a name="FsQk5"></a></p>
<h1 id="lab2-bombLab"><a href="#lab2-bombLab" class="headerlink" title="lab2 bombLab"></a>lab2 bombLab</h1><p><a name="mm3BW"></a></p>
<h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><ol>
<li>反汇编<code>main</code>函数：<code>read_line</code>函数之后寄存器<code>%rax</code>和<code>%rdi</code>存储了我们输入的字符串的首地址(后续的phase都是如此)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677142575501-aadca48e-4054-40dc-977b-4719009de3e3.png" alt="image.png"></p>
<ol>
<li>反汇编<code>strings_not_equal</code>函数：该函数在输入字符串与目的字符串相同时，将寄存器<code>%rax</code>（通常用作函数返回值）赋值为0 (1 vice versa)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143001741-9ecdcda9-b9a6-4b31-a450-5d80ed226850.png" alt="image.png"></p>
<ol>
<li>反汇编<code>phase_1</code>函数：<code>strings_not_equal</code>函数返回值为0时，<code>test %eax, %eax</code>能使<code>je 0x400ef7&lt;phase_1+23&gt;</code>执行，phase_1 defused (explode vice versa)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143312955-e1e9a80c-1730-48ae-84f7-5dfded69d3a9.png" alt="image.png"></p>
<ol>
<li>至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用<code>strings_not_equal</code>函数之前赋值的<code>%esi：0x402400</code>寄存器中</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143752561-a0f86e1a-fc9c-4ff2-b386-d8d929f293c5.png" alt="image.png"><br><a name="aPHyw"></a></p>
<h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><ol>
<li>反汇编<code>read_six_numbers</code>函数：可以推断出其实现了<code>sscanf(input, &quot;%d %d %d %d %d %d&quot;,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6)</code>的功能，其中<code>&amp;a1~&amp;a6</code>分别在1)<code>%rcx:0x4(%rsi)</code>2)<code>%r8:0x8(%rsi)</code>3)<code>%r9:0xc(%rsi)</code>4)<code>%rsp:0x10(%rsi)</code>5)<code>0x8(%rsp):0x14(%rsi), 0x18(%rsi)</code> 前3个指针存储在寄存器中传递给<code>sscanf</code>函数，后三个指针存储在为<code>read_six_numbers</code>函数分配的栈空间中,可以推断出<code>%rsi</code>为一个含有六个元素的数组的首地址</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677148614935-cd29c501-e2a8-4185-9924-0829124ef293.png" alt="image.png"></p>
<ol>
<li>反汇编<code>phase_2</code>函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150067118-dd3962a5-1458-4a3e-9399-4cf1699ca7a7.png" alt="image.png"></p>
<ol>
<li>自此，我们可以判断出这六个数字分别是$2^0,2^1,2^2,2^3,2^4,2^5$</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677149991615-e3f805b9-b4b0-4f49-bfbf-36dc2153557b.png" alt="image.png"><br><a name="XKRDk"></a></p>
<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><ol>
<li>反汇编<code>phase_3</code>：从<code>(%esi)</code>的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(<code>cmpl 0x7,0x8(rsp)</code>)，并根据这个值执行间接跳转操作(<code>jmp *0x402470(,rax,8)</code>)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150892423-92750918-b2b5-4aa5-9b0e-e08eec5cffdd.png" alt="image.png"></p>
<ol>
<li>查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的<code>0x8(%rsp</code>：1 2 3 4 5 6 7</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677072562462-74d53e52-6a59-498d-9186-02f1b43b8be5.png" alt="image.png"></p>
<ol>
<li>根据后续的赋值-跳转指令，可以得到对应的7个<code>0xc(%rsp)</code>：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151557789-3726bd23-9a03-48c7-bb2b-1a31a71ae4c0.png" alt="image.png"><br><a name="Qae7S"></a></p>
<h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><ol>
<li>反汇编<code>phase_4</code>函数：开头部分具有与<code>phase_3</code>函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(<code>cmpl $0xe, 0x8(%rsp)</code>)，之后函数调用<code>func4</code>函数，传入三个参数<code>%edx</code>, <code>%esi</code>, <code>0x8(%rsp)</code>。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(<code>test %eax, %eax</code>)。后续的<code>cmpl $0x0, 0xc(%rsp)</code>足以确定第2个值为0</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206362623-39fe4977-5cab-4016-9003-2541d41dbe6a.png" alt="image.png"></p>
<ol>
<li>反汇编<code>func4</code>函数：出现了<code>func4</code>调用自身的情况，所以<code>func4</code>是一个递归函数。第1部分将<code>%rax</code>赋值为<code>%edx</code>-<code>%esi</code>,再加上它的最高位(<code>%rax &gt;&gt; 31</code>)，接着执行算数右移。这里加上最高位的原因在于，当后续<code>%rax</code>在递归中值减少为-1时，最高位是符号位1，两者相加能保证<code>%rax</code>始终大于等于0，结合后续汇编内容，可以推断出第一个值<code>0x8(%rsp)</code>应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果<code>%ecx &gt; %edi</code>，那么就使<code>%ecx</code>变为<code>%esi</code>到<code>%edx</code>的中间值(<code>lea -0x1(%rcx), %edx</code>)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回<code>phase_4</code>的<code>%rax</code>值为1</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677204842268-34841e29-56e5-4d63-9e9f-b1576cec24a4.png" alt="image.png"></p>
<ol>
<li>自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206164369-fa35758d-403b-483b-ad52-af80ef73df84.png" alt="image.png"><br><a name="Kxq7k"></a></p>
<h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><ol>
<li><p>反汇编<code>phase_5</code>函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> index</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span> <span class="comment">// %rax</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">index = *(input+i);</span><br><span class="line">index = index&amp; <span class="number">0xf</span>; <span class="comment">// take lower four bits</span></span><br><span class="line">dest[<span class="number">0</span>] = source[index]; <span class="comment">// dest: (%rsp+0x10+%rax) source: 0x4024b0</span></span><br><span class="line"><span class="keyword">if</span>(string_not_equal(dest, target) == <span class="number">0</span>) <span class="comment">// target: 0x40245e --- &quot;flyers&quot;</span></span><br><span class="line">      <span class="comment">//defuse</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   explode_bomb();</span><br><span class="line">&#125;<span class="keyword">while</span>(i&gt;<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227102569-50a0daeb-22b8-4911-84ee-83283088ca0d.png" alt="image.png"></p>
</li>
<li><p>分别查看<code>source: 0x4024b0</code>和<code>target: 0x40245e</code>处的字符串，我们要做的就是使输入字符串形成的索引值能够从<code>0x4024b0</code>处的字符集中提取出 “flyers”</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227207876-48a2e806-f23e-49ec-982e-698183c7bc19.png" alt="image.png"></p>
<ol>
<li>我们的输入字符串每个字符在内存中占一个byte，<code>movzbl (%rbx, %rax, 1), %ecx</code>说明了一次循环提取一个字符，并只取该字符的低四位(<code>and $0xf, %edx</code>)作为索引值</li>
<li>首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228092474-185f8fde-3015-4a64-ae85-2a4931bb2ca9.png" alt="image.png"><br><a name="BuuHr"></a></p>
<h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><ol>
<li><p>thinking process</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">phase_6(input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">0</span>;  <span class="comment">// %r12d</span></span><br><span class="line"><span class="type">int</span>* input_copy = input; <span class="comment">// mov %rsp, %r13</span></span><br><span class="line"><span class="type">int</span> val; <span class="comment">// %eax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    val = *(input_copy); <span class="comment">// 0x0(%r13)</span></span><br><span class="line">    val = val<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val&gt;<span class="number">5</span>)  explode()  <span class="comment">// 元素值不得大于6</span></span><br><span class="line">        </span><br><span class="line">    ++a1; <span class="comment">// add $0x1, %r12d</span></span><br><span class="line">    <span class="keyword">if</span>(a1 == <span class="number">6</span>) <span class="keyword">break</span>; <span class="comment">// jmp 95</span></span><br><span class="line">    <span class="type">int</span> a2 = a1; <span class="comment">// mov %r12d, %ebx</span></span><br><span class="line">    <span class="keyword">do</span>&#123;   <span class="comment">// 65</span></span><br><span class="line">        val = *(input+a2);</span><br><span class="line">        <span class="keyword">if</span>(val == *input_copy)</span><br><span class="line">            explode();</span><br><span class="line">        ++a2;</span><br><span class="line">        &#125;<span class="keyword">while</span>(a2&lt;= <span class="number">5</span> ) <span class="comment">// 87</span></span><br><span class="line">    ++input_copy; <span class="comment">// add $0x4, %r13</span></span><br><span class="line">&#125; <span class="comment">// 93</span></span><br><span class="line"><span class="comment">/*两个信息：(已验证)</span></span><br><span class="line"><span class="comment">1. 输入字符串中所有元素不大于6</span></span><br><span class="line"><span class="comment">2. 输入字符串中所有元素互不相等 */</span> <span class="number">0</span>~<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* sentry = input+<span class="number">6</span>; <span class="comment">// mov 0x18(%rsp), %rsi   95</span></span><br><span class="line"><span class="type">int</span>* input_copy_2 = input; <span class="comment">// %rax</span></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">7</span>; <span class="comment">// %edx, %ecx</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    *(input_copy_2) = a3 - *(input_copy_2);</span><br><span class="line">    ++input_copy_2;</span><br><span class="line">&#125;<span class="keyword">while</span>(input_copy_2 != sentry)</span><br><span class="line"><span class="comment">/* 更新输入字符串所有值为：7-初始值(已证实), </span></span><br><span class="line"><span class="comment">结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a4 = <span class="number">0</span>; <span class="comment">// 123 %esi  -- index</span></span><br><span class="line"><span class="type">int</span> a5; <span class="comment">// %edx</span></span><br><span class="line"><span class="type">int</span> a6; <span class="comment">// %eax  -- index</span></span><br><span class="line">offset_166:</span><br><span class="line"><span class="keyword">if</span>(input[a4] &lt;= <span class="number">1</span>) <span class="comment">// 166  %ecx</span></span><br><span class="line">&#123;</span><br><span class="line">    a5 = <span class="number">0x6032d0</span>; <span class="comment">// 143</span></span><br><span class="line">    offset_148:</span><br><span class="line">    *(input+<span class="number">0x20</span>+<span class="number">2</span>*a4) = a5; <span class="comment">// 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48</span></span><br><span class="line">                             <span class="comment">//   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320   </span></span><br><span class="line">    a4 += <span class="number">4</span>; <span class="comment">// add $0x4, %rsi </span></span><br><span class="line">    <span class="keyword">if</span>(a4 ==  <span class="number">24</span> )</span><br><span class="line">        <span class="keyword">goto</span> offset_183; <span class="comment">// 161 </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">goto</span> offset_166;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">// 均要走这个else， 可能有一个不走这个else --&gt;肯定有一个不走</span></span><br><span class="line">&#123;</span><br><span class="line">    a6 = <span class="number">1</span>;  <span class="comment">// 171  </span></span><br><span class="line">    &amp;a5 = <span class="number">0x6032d0</span>; <span class="comment">// 176  这个地址+0x8能多次跳转</span></span><br><span class="line">    <span class="keyword">do</span>&#123; <span class="comment">// 130</span></span><br><span class="line">        a5 = *(&amp;a5 + <span class="number">0x8</span>) ; <span class="comment">// mov 0x8(%rdx),%rdx  链表?</span></span><br><span class="line">        ++a6; </span><br><span class="line">    &#125;<span class="keyword">while</span>(a6 != *(input+a4) ) <span class="comment">// 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)</span></span><br><span class="line">    <span class="keyword">goto</span> offset_148;         <span class="comment">// recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5</span></span><br><span class="line">&#125; <span class="comment">// 181</span></span><br><span class="line"></span><br><span class="line">offset_183：    function: link node in order</span><br><span class="line"><span class="type">int</span> a7 = input[<span class="number">8</span>]; <span class="comment">//%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address</span></span><br><span class="line"><span class="type">int</span>* input_copy_3 = input+<span class="number">10</span> <span class="comment">// %rax  0x28(%rsp)</span></span><br><span class="line"><span class="type">int</span>* input_copy_4 = input+<span class="number">20</span> <span class="comment">// %rsi  0x50(%rsp)</span></span><br><span class="line">a3 = a7; <span class="comment">// a3:%rcx</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">// 201</span></span><br><span class="line">    a5 = *input_copy_3; <span class="comment">//a5:%rdx [10][12]...[18][20] 6</span></span><br><span class="line">    *(a3+<span class="number">0x8</span>) = a5; <span class="comment">// 0x8(%rcx)</span></span><br><span class="line">    input_copy_3 += <span class="number">2</span>; <span class="comment">// 0x8 </span></span><br><span class="line">    <span class="keyword">if</span>(input_copy_3 == input_copy_4) <span class="keyword">break</span>; <span class="comment">// 215 </span></span><br><span class="line">    a3 = a5; <span class="comment">// mov %rdx, %rcx</span></span><br><span class="line">&#125;    <span class="comment">//   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)</span></span><br><span class="line"><span class="comment">// 结束时 %rdx = * (input + 18)</span></span><br><span class="line"></span><br><span class="line">*(*(input+<span class="number">18</span>) + <span class="number">2</span> ) = <span class="number">0</span>; <span class="comment">// 222   set last node&#x27;s pointer to nullptr</span></span><br><span class="line"><span class="type">int</span> a8 = <span class="number">5</span>; <span class="comment">// %ebp</span></span><br><span class="line"><span class="type">int</span> a9 <span class="comment">// %rax </span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"> &amp;a9 = *(a7+<span class="number">2</span>); <span class="comment">// %rax   initial a7 = input[8]</span></span><br><span class="line">  a9 = *a9; <span class="comment">// mov (%rax), %eax</span></span><br><span class="line"><span class="keyword">if</span>(*(*(input+<span class="number">8</span>)) &lt; a9) <span class="comment">// cmp %eax, (%rbx) </span></span><br><span class="line">    explode();   <span class="comment">// 验证是否降序</span></span><br><span class="line">a7 = *(*(input+<span class="number">8</span>)+<span class="number">2</span>); <span class="comment">// mov 0x8(%rbx), %rbx 更新%rbx  </span></span><br><span class="line">--a8;</span><br><span class="line">&#125;<span class="keyword">while</span>(a8&gt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// over</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*inital:</span></span><br><span class="line"><span class="comment">0x14c(0): 332;</span></span><br><span class="line"><span class="comment">0x0a8(1): 168;</span></span><br><span class="line"><span class="comment">0x39c(2): 924;</span></span><br><span class="line"><span class="comment">0x2b3(3): 691</span></span><br><span class="line"><span class="comment">0x1dd(4): 477</span></span><br><span class="line"><span class="comment">0x1bb(5): 443</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2-&gt;3-&gt;4-&gt;5-&gt;0-&gt;1 */</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是<code>0x6032d0</code>这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使<code>0x6032d0</code>这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677403752602-71565a7a-ae83-4e0e-a0d7-cdd2e3df1fd5.png" alt="image.png"><br><a name="QjpMp"></a></p>
<h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404056138-294107ed-6f1c-4477-83c9-44b00041ef4b.png" alt="image.png"></p>
<ol>
<li>发现彩蛋</li>
</ol>
<p>以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用<code>objdump -t bomb</code>查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404753141-3d41a656-d41d-476c-aae5-e51421f24d6e.png" alt="image.png"></p>
<ol>
<li>怎么触发</li>
</ol>
<p>1)谁调用了secret_phase：<code>secret_phase</code>既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在<code>main</code>函数中寻找可能调用<code>secret_base</code>的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在<code>phase_defused</code>函数中，反汇编<code>phase_defused</code>函数，果然发现了调用<code>secret_phase</code>的指令<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404954528-c0e39bd3-077e-49cd-a460-d820f2047ce8.png" alt="image.png"></p>
<ol>
<li>终章：拆解secret_phase</li>
</ol>
<p>1）反编译secret_base<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">secret_phase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> input_2;<span class="comment">// (%rdi)</span></span><br><span class="line">    &amp;input_2 = read_line(); <span class="comment">//  %rdi</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">0xa</span>; <span class="comment">// %edx</span></span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">0x0</span>; <span class="comment">// %esi</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> input_num_1 = strtol(input_2); <span class="comment">// %rax</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> input_num_2 = input_num_1 <span class="comment">// %rbx</span></span><br><span class="line">    input_num_1 -= <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(input_num_1 &gt; <span class="number">0x3e8</span> <span class="comment">/*1000*/</span>) explode();</span><br><span class="line">    <span class="comment">// 输入的数字字符串 值小于 1001</span></span><br><span class="line">    a2 = input_num_2;<span class="comment">// mov %ebx, %esi  </span></span><br><span class="line">    &amp;input_2 = <span class="number">0x6030f0</span>;</span><br><span class="line">    <span class="type">int</span> ret = fun7(&amp;input_2,a2,input_num_1); <span class="comment">// ret_value: %rax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0x2</span>)</span><br><span class="line">        defused();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        explode(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(&amp;input_2, a2, input_num_1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;input_2 == <span class="number">0x0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// avoid endless recursion</span></span><br><span class="line">    <span class="type">int</span> a3 = *(&amp;input_2);  <span class="comment">// 9 %edx   initial a3 = 24</span></span><br><span class="line">    <span class="keyword">if</span>(a3 &lt;= a2) <span class="keyword">goto</span> offset_28; <span class="comment">// 13  a2是输入值 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a3 &gt; a2</span></span><br><span class="line">    input_2 = *(&amp;input_2 + <span class="number">0x8</span>); <span class="comment">// +2  turn left</span></span><br><span class="line">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">    input_num_1 *= <span class="number">2</span>; <span class="comment">// input_num_q is 1 here</span></span><br><span class="line">    <span class="keyword">return</span> input_num_1;</span><br><span class="line"></span><br><span class="line">    offset_28:</span><br><span class="line">    input_num_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a3 == a2) <span class="keyword">return</span> input_num_1;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a3 &lt; a2</span></span><br><span class="line">    input_2 = *(&amp;input_2 + <span class="number">0x10</span>); <span class="comment">// +4   turn right</span></span><br><span class="line">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class="comment">// 0</span></span><br><span class="line">    input_num_1 = <span class="number">2</span>*input_num_1 + <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> input_num_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>2）有了phase_6的经验，我在查看了特殊地址<code>0x6030f0</code>的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址<code>0x6030f0</code>为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合<code>secret_phase</code>的逻辑，在子函数<code>fun7</code>返回值为2时defuse，经过分析，<code>fun7</code>这个递归函数，在最后三次递归时为turn left(<code>&amp;input_2 + 0x8</code>）-&gt;turn right(<code>&amp;input_2 + 0x10</code>) -&gt; return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484445488-99b96bb8-8026-406a-8606-b6ed814389d7.png" alt="image.png"></p>
<hr>
<p><a name="SLpu6"></a></p>
<h1 id="lab3-attacklab"><a href="#lab3-attacklab" class="headerlink" title="lab3 attacklab"></a>lab3 attacklab</h1><p><a name="UbCO7"></a></p>
<h2 id="前提-1"><a href="#前提-1" class="headerlink" title="前提"></a>前提</h2><ol>
<li>注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04</li>
</ol>
<p>博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题</p>
<ol>
<li>exploit string用工具<code>hex/2raw</code>构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。</li>
</ol>
<p>writeup的附录A介绍了多种<code>hex/2raw</code>接受输入字符串并传递给ctarget的多种方式，我习惯用：<br><code>./hex2raw &lt; exploit_string.txt | ./ctarget -q</code><br>这条命令将<code>exploit_string.txt</code>作为<code>hex2raw</code>的输入，并建立管道将<code>hex2raw</code>的输出传输到<code>./ctarget</code>中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行<code>./hex2raw</code>那么将无法中止输入<br><a name="Kk3w5"></a></p>
<h2 id="phase-1-1"><a href="#phase-1-1" class="headerlink" title="phase_1"></a>phase_1</h2><ol>
<li>反汇编<code>ctarget</code>：可用<code>objdump -d ctarget</code>获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585087533-3d1cfcba-4dd9-41f4-8cc8-bb4c35b8674f.png" alt="image.png"><br>这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了</p>
<ol>
<li><code>vim dis_ctarget.asm</code>查看<code>getbuf</code>函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者<code>test</code>函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看<code>touch1</code>函数，它的地址在<code>0x004017c0</code>处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585873581-353e1114-4253-4b23-aceb-6ba85c12e660.png" alt="image.png"></p>
<ol>
<li><p><code>vim phase_1.txt</code>输入</p>
<p>$\begin{matrix}<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\<br>&amp;00 &amp;00  &amp; 00 &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\<br>&amp;00  &amp;00  &amp;00  &amp;00 &amp;00  &amp;00  &amp;00  &amp;00\\<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\<br>&amp;c0 &amp;17  &amp;40  &amp;00  &amp;00  &amp;00  &amp;00<br>\end{matrix}$<br>最后留了一个字节以供gets放入’ \n ‘ (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了<br><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677586525442-cc13fc97-7de2-4bc6-90c7-bdb9356cc9b4.png" alt="image.png"><br><a name="xCSRi"></a></p>
<h2 id="phase-2-1"><a href="#phase-2-1" class="headerlink" title="phase_2"></a>phase_2</h2></li>
<li><p>编写汇编代码，转化为字节码：<code>vim asb.s</code>，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637642575-745a9de7-6e49-4ef0-9f44-46dbe3cfb8a0.png" alt="image.png"></p>
<ol>
<li>构造<code>phase_2.txt</code>，因为<code>asb.o</code>中的代码本身就已经逆序，所以直接输入即可；用于覆盖<code>test</code>栈帧中返回地址的值可由<code>%rsp</code>的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是<code>%rsp</code>的值</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677591555601-28a75db3-4efc-445a-bd75-67d6722d57ee.png" alt="image.png"></p>
<ol>
<li>攻击生效</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638454464-852c44b4-14f9-43fe-8e9f-a927c267b260.png" alt="image.png"><br><a name="TVVPU"></a></p>
<h2 id="phase-3-1"><a href="#phase-3-1" class="headerlink" title="phase_3"></a>phase_3</h2><ol>
<li>与<code>phase_2</code>很像，但这次要传递的参数是字符串形式的<code>cookie</code>。因为<code>getbuf</code>的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串<code>cookie</code>放在<code>test</code>函数的栈帧中，地址<code>0x5561dca8</code>；获取<code>touch3</code>函数的地址，编写攻击代码</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677673769317-083e3c3d-3eb7-4716-8b34-154511f96d34.png" alt="image.png"></p>
<ol>
<li><code>ascii -ax</code>查看十六进制形式的ascii-table，得出<code>&quot;59b997fa&quot;</code>的ascii形式为<code>35 39 62 39 39 37 66 61</code></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678551264-8b3b6a28-3390-45cb-bbc6-b20f241eb472.png" alt="image.png"></p>
<ol>
<li>覆盖返回地址和test栈帧，写入攻击代码的地址和字符串<code>cookie</code></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678755332-3ea51646-6c2b-4212-8f6a-d6fe5551fa9a.png" alt="image.png"></p>
<ol>
<li>攻击生效</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678782689-4f003174-6f36-4200-87cd-d46e586d9907.png" alt="image.png"><br><a name="UnHwd"></a></p>
<h2 id="phase-4-1"><a href="#phase-4-1" class="headerlink" title="phase_4"></a>phase_4</h2><p>确定攻击方案：<code>rtarget</code>由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用<code>ctarget</code>自身的代码实现攻击，具体做法是通过地址跳转，截取<code>ctarget</code>的部分代码用作攻击代码；<code>gadget</code>指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串<code>gadget</code>的地址，那么一旦执行其中一个<code>gadget</code>，<code>ret</code>指令就会不断的从栈中弹出新的<code>gadget</code>的地址赋给<code>%rip</code>,由此引发多个<code>gadget</code>的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）</p>
<ol>
<li><code>cookie</code>的值不可能从<code>rgadget</code>中找到，需要我们自己放到栈中，如同<code>phase_3</code>一样，放的位置不能是<code>getbuf</code>的缓冲区，因此我们将其放到<code>test</code>的栈帧中；接着要实现<code>mov $0x59b997fa,%rdi</code>，需执行<code>popq %rdi</code>，根据writeup的参照表，先在<code>start_farm</code>和<code>end_farm</code>之间寻找<code>5f</code>，结果没有，但是找到了<code>58 90</code>,地址为<code>0x004019ab</code>，这代表<code>popq %rax  nop</code>，因此我们需要用<code>%rax</code>作介质传递<code>cookie</code>给<code>%rdi</code>，而在farm中我们也确实找到了<code>movq %rax, %rdi：48 89 c7</code>，地址为<code>0x004019c5</code>，一共用到了两个<code>gadget</code></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748308138-674aa437-9522-414c-afcf-828967ad2c1b.png" alt="image.png"></p>
<ol>
<li>按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750944719-6ccf095c-ffce-4020-8cb6-f5b0f0fde9f8.png" alt="yuque_diagram.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
</search>
