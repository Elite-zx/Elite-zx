{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"source/images/favicon-16.ico","path":"images/favicon-16.ico","modified":0,"renderable":0},{"_id":"source/images/favicon-32.ico","path":"images/favicon-32.ico","modified":0,"renderable":0},{"_id":"source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/categories/index.md","hash":"aac68ecccfc35c7057324dbbd7cbb8f484928d84","modified":1678148928071},{"_id":"source/_posts/assembly.md","hash":"91ad9e959a9cbc9a5c25825f6d561c397f1e909e","modified":1678679799287},{"_id":"source/images/avatar.png","hash":"a6d6f892a4354fdb94433a5e01fee9af0a9932ea","modified":1678275304886},{"_id":"source/tags/index.md","hash":"b71f59a14557015a72a5d85ca246d6b2131820ae","modified":1678358115712},{"_id":"source/images/favicon-16.ico","hash":"b9be1dc798b01d83a369bc5a4c54f25594518b2c","modified":1678514589000},{"_id":"source/about/index.md","hash":"ad1b8f6ac25bb91ac3775cd4fda5900b8fae4002","modified":1679922998527},{"_id":"source/_posts/csapp-lab.md","hash":"8f779cb19238629ad5b568f02bae8503f5c60df6","modified":1678722432903},{"_id":"source/images/favicon-32.ico","hash":"0aaee4b6f7487426d9d7edd9bbfaa499526caf1b","modified":1678514574000},{"_id":"source/images/alipay.jpg","hash":"56695d97b116f6ef4867e93f8bbbf819400814ab","modified":1678194904057},{"_id":"source/images/wechatpay.jpg","hash":"e4a2f37995c7637b317d7688827f71e7e7aa1912","modified":1678194169857},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"66c5c1be52003970185726b5f4d21046116b3682","modified":1680014108686},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"85b8539ced5c91ba05cbb5f66c631ccc77b467d9","modified":1680013569667},{"_id":"node_modules/hexo-theme-next/package.json","hash":"a192fe2e0904b490c885e8545a409536b41ef46e","modified":1678092470175},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1678092470183},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1678092470179},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1678092470187},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"46026e98fe279a9db5d68bf91afa5d8e41f9ccfb","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"74133a827c104d1d84509177f283947fe9327a80","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"c4fc18c338309271d1afe737e6c404a6fa313bbc","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"4bbdb4284afe495437cf7817b97b45f60e12d1e4","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"8b6d4a8a056df4362d20ae1f6ac7a590dd7246e5","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"1e256c8df039ddeba66526c5eb2d6c79177a7fc6","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"c4bad93b23c7eefa730fd7fec5b05ace3ce9ca4d","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"2436942610e38b73b175cb0f8ed1f8f23d42a7ce","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"4d6efcdaea89dfe751b7707d91858bf33d3538b7","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"a0906702d3c87d0e1661e300ad0bdf7e679a3d91","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1678092470179},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"25ee0d5b9a0464a91af7d2efb33293c09ad5abdf","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"10d80915c41328f31a4f2d8ac736bba020f373d8","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"8a4da307b4a19e3c96b90a07a2da8dc5d50e5d9e","modified":1678092470355},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"fa7c43ec872aee2739b25dd7260e0764ea9e26fd","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"16b96783ba363255b4c8156c3e1efebdb37676f8","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"034c5a0df49144e8f16ae2300dba9fde58b9329e","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/th.yml","hash":"4fac74a39d3906c4a727476be4750530a505933a","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"37d9af426b040004841273d163059cd49cd67d65","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"890f87f6a33ad8452b771607d4c3ff14810b35fa","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"fbaed3039ed8605b81422003a4ecb2a6514e339d","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"5cebea74f3198a4a20cacf23069c3b91e4f03d85","modified":1678092470363},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"a6ba04c743a5b494ac56612ce6b858d9ae3ae1bd","modified":1678092470359},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"8ab7219563dab13885840207a86055000d173465","modified":1678092470363},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"9fdce9d316e205fc132b2181254ef3b04007a97d","modified":1678092470363},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"fc0a45112f2dcfc2642404e8934ea32a793c3bd7","modified":1678092470191},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1678092470191},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1678092470227},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1678092470203},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"b0660b2af0ac7d3fda14ca4d9f2c9e79ef06c6f9","modified":1678092470243},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1678265614437},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1678092470263},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1678092470183},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1678092470247},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"7e8268fd5cbd552322b276f52459fd187c2453d2","modified":1678092470255},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1678092470263},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1678092470207},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"9c81879efbf91ccfa6af1bf929b8acdd2e0645b1","modified":1678193477999},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1678092470231},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1678092470243},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"e7f988ecddb2159313699a00827a45eca5622bd4","modified":1678092470271},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1678092470211},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1678092470183},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"aa37f8e98208177b63e3328d6e53b022c6edf3b2","modified":1678092470223},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1678092470243},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1678092470259},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1680013771323},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1678092470135},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1678092470115},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1678092470147},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"ce8477e7fb226525bae5872cd68a1c2c23ad50c8","modified":1678092470155},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1678092470167},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1678092470127},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1678092470159},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1678092470159},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1678092470159},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"fd24abfaba4d91923ddb6aecf0268b216678c8bd","modified":1678092470159},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1678092470123},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1678092470159},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1678092470099},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1678092470099},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1678092470099},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1678092470131},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1678092470135},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1678092470143},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1678092470143},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1678092470151},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1678092470163},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1678092470163},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1678092470167},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1678092470175},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1678092470275},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1678092470223},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"c132191108ebd7d1429c503d685780e73cc3d822","modified":1679654274438},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"83647a6207333b9609ba90b0946b3fa9548e6381","modified":1678092470291},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"9bbdbb0656505acceef9b9895a576164175fe888","modified":1678092470187},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1678092470083},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"ac3c4a7616ea80f0d32d68d6e53233952ba756dc","modified":1678092470187},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1678092470271},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1678092470271},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1678092470271},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1678092470111},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1678092470107},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1678092470159},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1678092470155},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1678092470107},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1678092470095},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"5e1cf39de050964e97fb3ba0825aeec7f4bc36dd","modified":1678092470171},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1678092470219},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1678092470199},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1678092470239},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1678092470239},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1678092470263},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1678092470219},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1678092470219},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1678092470199},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1678092470203},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1678092470243},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1678092470259},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1678092470263},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1678092470247},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1678092470247},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1678092470251},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1678092470255},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1678092470251},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-share.njk","hash":"3f28cc4411c0ffc0e41b7970d5ab329c7e46f497","modified":1678092470255},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1678092470191},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1678092470235},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1678092470219},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1678092470195},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1678092470215},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"70342218473a6e6aa9148de06bfffe121afb8548","modified":1678092470263},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1678092470215},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1678092470223},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1678092470207},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1678092470235},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1678092470239},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1678092470247},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/umami.njk","hash":"181f69b6718c7a8642a88652260cc0a26084a3ee","modified":1678092470263},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1678092470203},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1678092470211},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1678092470215},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1678092470227},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1678092470211},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1678092470235},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1678092470267},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1678092470207},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1678092470215},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1678092470235},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1678092470191},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1678092470263},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1678092470227},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1678092470227},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1678092470235},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1678092470199},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1678092470211},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1678092470227},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1678092470231},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1678092470239},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1678092470243},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"9ec51eb61f7fee612ffc5252f489003a0fa301fc","modified":1678092470111},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1678092470131},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1678092470139},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1678092470159},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1678092470171},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1678092470175},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1678092470103},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1678092470111},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1678092470115},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1678092470119},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1678092470119},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1678092470127},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1678092470139},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1678092470143},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1678092470171},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"b03ba78c6916ad2f390d55bc1bc18fafb64b0ebf","modified":1678092470167},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1678092470167},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"d71217bbd35637f42d184db786540e8e682479b1","modified":1679644956782},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"b57212e700c5ac2cc5eb83eba7a333aa3f4bfbe5","modified":1679646230864},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"a1418c9dc8c0f1a0ad4ded0f4627c45bf0db1a10","modified":1678092470335},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1678092470315},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","hash":"0c490e9ba82efbb8bdf8465e6b537fafd51e1ed7","modified":1678092470155},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1678092470335},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"7664491542046df9a3887cf40a06e00c0b4086a9","modified":1678092470299},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1678092470319},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1678092470323},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1678092470335},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1678092470311},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1678092470311},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1678092470299},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1678092470323},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1678092470335},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"782ee1fc5e669d3ddbfeb82b73ad7fe561f1a4fb","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1678092470123},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1678092470163},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1678092470167},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"77b85d4de5ab747e04008ab31200311b29748740","modified":1678092470275},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1678092470287},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"9dfe853c901bdc52fc950bacdf15484dbb9bf140","modified":1678092470327},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1678092470291},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1678092470291},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1678092470327},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"d856127cd7e0a28a88edf0b2eb860ede9c3fdb60","modified":1678092470279},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1678092470295},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"7fecfb76420f786d6bf60218a81705bb48fb1d18","modified":1678092470287},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"ac2dc0ce9c775a83ef7132ae957b54539366ac9c","modified":1678092470287},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1678092470291},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"4266eed6f75625bb30ef0280dc5d4093e7c3beb1","modified":1678092470291},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"91dbf3ca5c3a613d4e30618c120da535bf2d0336","modified":1678092470295},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1678092470295},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1678092470327},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1678092470327},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1678092470291},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"cef9c5f9524fd01b59b0a89e51904b42cbdedc8c","modified":1678092470295},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1678092470127},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1678092470095},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1678092470151},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1678092470131},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1678092470127},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1678092470107},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1678092470171},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1678092470127},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1678092470107},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1678092470119},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1678092470139},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1678092470175},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1678092470147},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1678092470119},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1678092470147},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1678092470139},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1678092470143},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1678092470123},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1678092470091},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1678092470311},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1678092470311},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1678092470319},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"40c9839d3288c3b7de0bf38ac2e18f6c8eba6227","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"1ecfd64507954810b07a9d21fb5305b5378feda0","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1678092470315},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1678092470315},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1678092470315},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"77550e0d3e029b7458e35d8c5ae1fbd612c9673b","modified":1678092470319},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1678092470335},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"0c79462439b1361034a03590cd69a8abb3a678a6","modified":1678092470319},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1678092470307},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1678092470315},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1678092470319},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"b750af2fb833c10c4313b5a4258237161a7833d7","modified":1678092470335},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"da5e88f8debd5ac8d7af5c6ba6240df66104955f","modified":1678092470323},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1678092470151},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1678092470343},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"c6a27beb3f741211a14576026f3b4cfc44cc6407","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"9a7c71560fbdc936ad4e736fe15063ea3e8a644b","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1678092470311},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"9056be572ec1cfa429abb22be4b45a662d5b0fb1","modified":1678092470323},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1678092470307},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1678092470315},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1678092470323},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1678092470331},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1678092470331},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1678092470335},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"98d4c20aff0f0fcfe1824017fb06ab21ef0d218e","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1678092470339},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1678092470351},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1678092470347},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1678092470319},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1678092470143},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1678092470163},{"_id":"node_modules/hexo-theme-next/README.md","hash":"36c4b25587ca494102323dab5a38de5490451a64","modified":1678092470187},{"_id":"public/search.xml","hash":"7e1ba06c954136db2f778237acf3f76290acb7ea","modified":1679996231668},{"_id":"public/about/index.html","hash":"54a270c03fdb4e59f0cbf969697cd529705d5ee8","modified":1680014621459},{"_id":"public/tags/index.html","hash":"fb9884280454a58419c5d138535494956001a241","modified":1680014621459},{"_id":"public/categories/index.html","hash":"a339f1e1e573a688b6b8d9861bb21205d45af5e5","modified":1680014621459},{"_id":"public/archives/index.html","hash":"8533eba0b55e96a0bc3bdb248ea13878b59571dc","modified":1680014621459},{"_id":"public/archives/2023/index.html","hash":"672de6cbbf168f97401d07d5c5ce5c44a0a99164","modified":1680014621459},{"_id":"public/archives/2023/03/index.html","hash":"7cf0463a4d8ccb35736e2af864a0873258e97d69","modified":1680014621459},{"_id":"public/categories/CSAPP/index.html","hash":"e78671c46b601e82d33bf1c9576c9017f2972bfd","modified":1680014621459},{"_id":"public/2023/03/06/assembly/index.html","hash":"0a33d8901d9a4dc8536b381efe0a5891f06ff9cb","modified":1680014621459},{"_id":"public/2023/03/06/csapp-lab/index.html","hash":"4e6798a12899d4a0537f50219b8d1109f1aabd21","modified":1680014621459},{"_id":"public/index.html","hash":"65076fc6b4b0d2d9a467c959cb471fd58b57713a","modified":1680014621459},{"_id":"public/tags/Foundation/index.html","hash":"5c7abac4861bcd1524cebb9dc9e1724b4b645bdf","modified":1680014621459},{"_id":"public/images/avatar.png","hash":"a6d6f892a4354fdb94433a5e01fee9af0a9932ea","modified":1679654951240},{"_id":"public/images/favicon-16.ico","hash":"b9be1dc798b01d83a369bc5a4c54f25594518b2c","modified":1679654951240},{"_id":"public/images/favicon-32.ico","hash":"0aaee4b6f7487426d9d7edd9bbfaa499526caf1b","modified":1679654951240},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1679654951240},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1679654951240},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1679654951240},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1679654951240},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1679654951240},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1679654951240},{"_id":"public/images/alipay.jpg","hash":"56695d97b116f6ef4867e93f8bbbf819400814ab","modified":1679654951240},{"_id":"public/images/wechatpay.jpg","hash":"e4a2f37995c7637b317d7688827f71e7e7aa1912","modified":1679654951240},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1679654951240},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1679654951240},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1679654951240},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1679654951240},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1679654951240},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1679654951240},{"_id":"public/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1679654951240},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1679654951240},{"_id":"public/js/schemes/muse.js","hash":"0c490e9ba82efbb8bdf8465e6b537fafd51e1ed7","modified":1679654951240},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1679654951240},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1679654951240},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1679654951240},{"_id":"public/js/pjax.js","hash":"b03ba78c6916ad2f390d55bc1bc18fafb64b0ebf","modified":1679654951240},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1679654951240},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1679654951240},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1679654951240},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1679654951240},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1679654951240},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1679654951240},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1679654951240},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1679654951240},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1679654951240},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1679654951240},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1679654951240},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1679654951240},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1679654951240},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1679654951240},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1679654951240},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1679654951240},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1679654951240},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1679654951240},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1679654951240},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1679654951240},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1679654951240},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1679654951240},{"_id":"public/css/main.css","hash":"2affa12e5e3132ab4b581a071248803c48ec793f","modified":1679654951240},{"_id":"public/js/utils.js","hash":"5e1cf39de050964e97fb3ba0825aeec7f4bc36dd","modified":1679654951240},{"_id":"source/_posts/cache.md","hash":"dca8f85693dfbbdc79d60a356c4fc942e14bfe6f","modified":1679965195991},{"_id":"source/_posts/D_A_C++.md","hash":"d341ddd73ebbe8a1b41c3c9227937d9840345190","modified":1679965833866},{"_id":"source/index.md","hash":"8b48bf6a9f878396828e3ce3802a9c15db6475d0","modified":1679996324969},{"_id":"public/archives/2022/index.html","hash":"e9b969d7768e199d23fe78e787b803bf3e2a4d09","modified":1680014621459},{"_id":"public/archives/2022/10/index.html","hash":"47f95806f7ec70f2538131e108b5551732a75c7a","modified":1680014621459},{"_id":"public/categories/Data-structure-and-Algorithm/index.html","hash":"b1a2c439c0973d42f4394bfce21f7f266d69f57e","modified":1680014621459},{"_id":"public/2022/10/25/D_A_C++/index.html","hash":"397ea3be68db9611b32be9319ba74aa5cff416a1","modified":1680014621459},{"_id":"public/2023/03/16/cache/index.html","hash":"c7c99bbd783dfaf2c7c27c93d4e3a5953f12604b","modified":1680014621459},{"_id":"public/default-index/index.html","hash":"f9d0a02c5dd2946739e0c61d9605c4c3b183cd3d","modified":1680014621459},{"_id":"source/archives/index.md","hash":"82f5df7ca7fa69fe7b08750b61913f27d5ad7102","modified":1679930844433},{"_id":"source/_posts/ubuntu_mac.md","hash":"5401a287cc1542179f7ad373bb67c4cddc9b2be7","modified":1679996163706},{"_id":"public/2023/03/27/ubuntu_mac/index.html","hash":"8711b1f9b87e3d6bcf0043398b8b3485148f76ed","modified":1680014621459},{"_id":"public/categories/gadget/index.html","hash":"11015d1ac66a5a611fde50dbf59c9eef1ac630ce","modified":1680014621459},{"_id":"public/tags/tutorial/index.html","hash":"ac3a5f871f441bbc3ded7b6e728b5e5e003c15fa","modified":1680014621459}],"Category":[{"name":"CSAPP","_id":"clfmf6v9s00051gva4w9b9z3q"},{"name":"Data structure and Algorithm","_id":"clfqu81k00004vymofy5la1xc"},{"name":"gadget","_id":"clfs2azfg0000ermob7x8gznp"}],"Data":[],"Page":[{"title":"about","date":"2023-03-07T05:12:19.000Z","type":"about","_content":"\nA man who love liberty :thumbsup:\nA CS student :computer:\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-03-07 00:12:19\ntype: about\n---\n\nA man who love liberty :thumbsup:\nA CS student :computer:\n","updated":"2023-03-27T13:16:38.527Z","path":"about/index.html","_id":"clfmf6v8400001gva7m2i6642","comments":1,"layout":"page","content":"<p>A man who love liberty 👍<br>\nA CS student 💻</p>\n","site":{"data":{}},"excerpt":"","more":"<p>A man who love liberty 👍<br>\nA CS student 💻</p>\n"},{"title":"tags","date":"2023-03-09T10:34:29.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-03-09 05:34:29\ntype: \"tags\"\n---\n","updated":"2023-03-09T10:35:15.712Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clfmf6v8600011gva2t4shvvb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2023-03-07T00:26:58.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-03-06 19:26:58\ntype: \"categories\"\n---\n","updated":"2023-03-07T00:28:48.071Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clfmf6v8700021gvafk1q5xbo","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"Hi there :wave:\nWelcome to my blog :sparkles:\nYou can find all my articles in the Archives on the sidebar :sunny:\n```c\n#include<stdio.h>\n\nvoid main(int argc, char* argv[])\n{\n\tprintf(\"Hello world!\");\n}\n```\n","source":"index.md","raw":"Hi there :wave:\nWelcome to my blog :sparkles:\nYou can find all my articles in the Archives on the sidebar :sunny:\n```c\n#include<stdio.h>\n\nvoid main(int argc, char* argv[])\n{\n\tprintf(\"Hello world!\");\n}\n```\n","date":"2023-03-28T09:38:44.973Z","updated":"2023-03-28T09:38:44.969Z","path":"index.html","_id":"clfquj6zs0000oqmo0fk4crpi","title":"","comments":1,"layout":"page","content":"<p>Hi there 👋<br>\nWelcome to my blog ✨<br>\nYou can find all my articles in the Archives on the sidebar ☀️</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Hi there 👋<br>\nWelcome to my blog ✨<br>\nYou can find all my articles in the Archives on the sidebar ☀️</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"archives","date":"2023-03-27T15:27:24.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2023-03-27 11:27:24\n---\n","updated":"2023-03-27T15:27:24.433Z","path":"archives/index.html","comments":1,"layout":"page","_id":"clfqzhug80000aomodibve7vs","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"汇编语言【王爽】实验流程","date":"2023-03-06T05:00:00.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"MTE7s\"></a>\n# 前言：\n前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的attack lab完成了\n<!--more-->\n---\n\n<a name=\"PhqOH\"></a>\n# 实验1 查看CPU和内存，用机器指令和汇编指令编程\n<a name=\"xymUo\"></a>\n## debug环境搭建：[参考此文](https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506)\n<a name=\"UrdzB\"></a>\n## assignment 1\n\n1. 用A命令向内存中写入汇编指令，用U命令查看\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249473372-3a80b2ab-d9e2-483c-ac41-140d30fdd765.png#averageHue=%23161616&clientId=uc99250e8-54b1-4&from=paste&height=248&id=ub963f2d1&name=image.png&originHeight=245&originWidth=374&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6659&status=done&style=none&taskId=u0fa9efb8-dccf-4ce1-b3ea-8d79929c540&title=&width=378)\n\n2. 用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249669344-d36231e5-8310-46ba-a3c6-155e2601ff58.png#averageHue=%230e0e0e&clientId=uc99250e8-54b1-4&from=paste&height=309&id=udc060390&name=image.png&originHeight=309&originWidth=608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7838&status=done&style=none&taskId=udc51570f-ded8-4f72-a2f5-ee442502176&title=&width=608)\n<a name=\"rTW1r\"></a>\n## assignment 2\n\n1. 写入并查看指令\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250172971-61fbb876-feda-4ca9-b81d-e558cc0e5a6a.png#averageHue=%23151515&clientId=uc99250e8-54b1-4&from=paste&height=174&id=u55f6e2fe&name=image.png&originHeight=174&originWidth=376&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4324&status=done&style=none&taskId=u9c9ba619-9a5c-4e5c-9e9d-45d5a6ea724&title=&width=376)\n\n2. 修改_CS:IP_指向\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250237721-ec3e62f5-f6bc-4890-8f25-b62f6d89e60e.png#averageHue=%230c0c0c&clientId=uc99250e8-54b1-4&from=paste&height=228&id=u87c23aee&name=image.png&originHeight=228&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7409&status=done&style=none&taskId=u0c70f1dc-bfd2-4472-a4d5-84a3fe97214&title=&width=642)\n\n3. 执行指令，计算$2^8$，结果为 $AX = 0100H$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250558182-3582fd8d-9783-421c-9731-0d83ae5c81a8.png#averageHue=%23121212&clientId=uc99250e8-54b1-4&from=paste&height=72&id=u92a48cc6&name=image.png&originHeight=72&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2934&status=done&style=none&taskId=ud124b271-ce25-43f5-aabf-1f9dd478c19&title=&width=583)\n<a name=\"QAZ3Z\"></a>\n## assignment 3\n\n1. 用D命令查找，最终在$FFFF5H \\to FFFFCH（FFFF:0005 \\to FFFF:000C）$发现$dd/mm/yy$字样的生产日期\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251622812-ca79ef23-5a2a-46b2-ba9f-326aa9d3bc54.png#averageHue=%23161616&clientId=uc99250e8-54b1-4&from=paste&height=68&id=ud8481a70&name=image.png&originHeight=68&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3411&status=done&style=none&taskId=u26b9075a-3732-4bca-831f-f7252d9a335&title=&width=630)\n\n2. 尝试用E命令修改，该操作失效，因为这是ROM\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251941938-25cdf39e-5c26-49a3-81da-f108dff28da7.png#averageHue=%230f0f0f&clientId=uc99250e8-54b1-4&from=paste&height=120&id=u23687460&name=image.png&originHeight=120&originWidth=632&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4133&status=done&style=none&taskId=uca81322b-a794-4e03-b596-0d7a694a021&title=&width=632)\n<a name=\"CHS7t\"></a>\n## assignment 4\n1.$A0000H \\to BFFFFH$对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253290191-823908a7-61e0-4e4d-ac20-66184b8a4509.png#averageHue=%23141414&clientId=uc99250e8-54b1-4&from=paste&height=24&id=udb4b1014&name=image.png&originHeight=24&originWidth=316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=646&status=done&style=none&taskId=uc1f68660-8c22-4e6b-81ab-8168f9d217e&title=&width=316)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253301915-ead25a09-d4a2-48f2-ba25-7bb4b7279d64.png#averageHue=%230000aa&clientId=uc99250e8-54b1-4&from=paste&height=46&id=u1f906edf&name=image.png&originHeight=46&originWidth=489&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1808&status=done&style=none&taskId=u8980a613-e82f-4ceb-a518-1e33c095648&title=&width=489)\n\n---\n\n<a name=\"hcb7h\"></a>\n# 实验2 用机器指令和汇编指令编程\n<a name=\"vDc8z\"></a>\n## assignment 1\n\n1. 用A指令向内存中写入汇编指令，用U指令查看\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596808599-b129a717-4d20-42a3-8823-64dc726440e3.png#averageHue=%23151515&clientId=u2caa9258-9642-4&from=paste&height=236&id=uc9b341b4&name=image.png&originHeight=236&originWidth=374&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6210&status=done&style=none&taskId=uf45debe0-8185-465e-b3c1-03874bac6c7&title=&width=374)\n\n2. 修改CS:IP使其指向代码段\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596896692-f6335ebe-e9b7-44cf-9a38-d686dde7d140.png#averageHue=%230a0a0a&clientId=u2caa9258-9642-4&from=paste&height=162&id=u325eac60&name=image.png&originHeight=162&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4064&status=done&style=none&taskId=uaa5719c7-c665-4f9e-baa5-b5de2b24fc8&title=&width=577)、\n\n3. t命令逐步执行指令后查看AX、BX、SP寄存器内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673597028389-791ccf84-0268-4f23-976f-53e6ecd97b36.png#averageHue=%23121212&clientId=u2caa9258-9642-4&from=paste&height=374&id=ueb563e3c&name=image.png&originHeight=374&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15302&status=done&style=none&taskId=u24406e7c-e085-4926-bf36-d7ff7eeb06a&title=&width=635)\n<a name=\"NB9fg\"></a>\n## assignment 2\n在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）\n\n---\n\n<a name=\"jpe3I\"></a>\n# 实验3 编程、编译、链接、跟踪\n<a name=\"QMUAH\"></a>\n## assignment 1\n\n1. 编译链接生成可执行文件\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673681789903-cb9f13be-b044-4c3f-be1d-8fa401195306.png#averageHue=%230b0b0b&clientId=ufc3ba72b-b1bc-4&from=paste&height=328&id=ufc540080&name=image.png&originHeight=328&originWidth=524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8289&status=done&style=none&taskId=uaf6acc9d-3a30-400a-b361-0bea1d87366&title=&width=524)\n<a name=\"bm7kI\"></a>\n## assignment 2\n\n1. debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为$DS=075C$，则PSP的地址为$075C:0$，程序的地址为$076C:0\\;(075C+10:0)$,$CS:IP = 076C:0000$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682350829-98451696-0d75-4414-87c5-b527b5c96169.png#averageHue=%23111111&clientId=ufc3ba72b-b1bc-4&from=paste&height=90&id=u24027707&name=image.png&originHeight=90&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3436&status=done&style=none&taskId=u88d9a7fb-f08c-4035-82ab-48a67509d8f&title=&width=583)\n\n2. 跟踪程序执行过程\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682565168-917f19d2-8e0c-44ab-84e5-453c301bcda0.png#averageHue=%23111111&clientId=ufc3ba72b-b1bc-4&from=paste&height=378&id=u739eac5d&name=image.png&originHeight=378&originWidth=593&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13977&status=done&style=none&taskId=u7a4cf037-0141-418c-a6bc-3a455f22fa1&title=&width=593)<br />用P命令执行`INT 21`<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682678668-4d6f6ba6-a61b-408a-8aa9-f84fdd1abc8a.png#averageHue=%230d0d0d&clientId=ufc3ba72b-b1bc-4&from=paste&height=386&id=ue3d6f0ce&name=image.png&originHeight=386&originWidth=620&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12637&status=done&style=none&taskId=ud602a7a4-6c24-495c-b269-66ce57ddba3&title=&width=620)\n<a name=\"fqp3r\"></a>\n## assignment 3\n\n1. 查看PSP的内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682886059-386e1af8-2b73-480f-92b1-d2ea01cce40a.png#averageHue=%23161616&clientId=ufc3ba72b-b1bc-4&from=paste&height=175&id=ueb72f5b4&name=image.png&originHeight=175&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6346&status=done&style=none&taskId=ufec3ae9d-8d07-4ba6-ae47-78454c6ed61&title=&width=625)\n\n---\n\n<a name=\"eTiIA\"></a>\n# 实验4 [bx]和loop的使用\n<a name=\"Ypsn2\"></a>\n## assignment 1\n\n1. 编写源程序\n```\nassume cs:codesg\n\ncodesg segment\n\nmov ax, 0020H\nmov ds, ax\nmov bx, 0\nmov dx, 0\nmov cx, 64\n\ns: \nmov [bx],dx\ninc bx\ninc dx\nloop s\n\nmov ax, 4c00h \nint 21h\n\ncodesg ends\nend\n```\n\n2. 编译，链接生成可执行文件\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673769654198-dcf5a11b-b298-4d67-ac52-e6412baa7953.png#averageHue=%230a0a0a&clientId=ua6d781cd-6a2a-4&from=paste&height=308&id=ucb1b0e3f&name=image.png&originHeight=308&originWidth=563&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9162&status=done&style=none&taskId=ud2798294-b700-4d36-9278-b89b6f31b7e&title=&width=563)\n\n3. 查看载入内存的程序，可以看见标签s已被替换为地址$076C:000E$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770040980-f6175097-5e41-41f0-a0d4-ed6dcc9e2d26.png#averageHue=%230f0f0f&clientId=ua6d781cd-6a2a-4&from=paste&height=257&id=ub7d89c02&name=image.png&originHeight=257&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9471&status=done&style=none&taskId=u76baa400-787b-4ed1-b282-488abb7c243&title=&width=601)\n\n4. 执行程序，验证结果，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770269260-0b535c86-7318-4bea-9b9b-151df8786503.png#averageHue=%23151515&clientId=ua6d781cd-6a2a-4&from=paste&height=144&id=u9760e10a&name=image.png&originHeight=144&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4621&status=done&style=none&taskId=u407ff41a-3998-40b9-80e2-b904a9486e8&title=&width=480)\n<a name=\"q95Oy\"></a>\n## assignment 2 \n\n1. 编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令\n```\nassume cs:codesg\n\ncodesg segment\n\nmov ax, 0020H\nmov ds, ax\nmov bx, 0\nmov cx, 64\n\ns: \nmov [bx],bx\ninc bx\nloop s\n\nmov ax, 4c00h \nint 21h\n\ncodesg ends\nend\n```\n\n2. 其它步骤与assigment 1一致，验证结果，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673771416582-e853218d-46c6-4bf8-98d6-cacae4200dbb.png#averageHue=%231a1a1a&clientId=u7cc11769-d150-4&from=paste&height=359&id=u85d074a9&name=image.png&originHeight=373&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9679&status=done&style=none&taskId=uca7996c4-5515-4485-9bd2-5bed6cf48b4&title=&width=472)\n<a name=\"b3BKL\"></a>\n## assignment 3\n\n1. 复制的是什么：复制程序的第一条指令`mov ax,cs`到 `loop s` 指令至内存地址$0020:0000$处\n2. 如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在`mov cx,_____` 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：$076C:0000 \\to 076C:0015$，共$16H\\,(23D)$个字节,因此第二个空应该填入$16H$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673774640766-de55642e-4594-4add-9f75-ac17f9cf3628.png#averageHue=%230d0d0d&clientId=u7cc11769-d150-4&from=paste&height=282&id=u704b4ac0&name=image.png&originHeight=282&originWidth=616&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9580&status=done&style=none&taskId=u46b6c23e-98fc-45b4-ad17-7f7d7bef327&title=&width=616)\n\n---\n\n<a name=\"l6DRo\"></a>\n# 实验5 编写、调试具有多个段的程序\n<a name=\"y07m5\"></a>\n## assignment 1\n\n1. 将程序载入内存后查看，可知data段段地址为$076C$, stack段段地址为$076D$，code段段地址为$076E$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877104816-d24fcee5-293b-4965-a116-55b74e84812c.png#averageHue=%23101010&clientId=u1b2351c9-0f42-4&from=paste&height=266&id=u68a1fe4a&name=image.png&originHeight=266&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10189&status=done&style=none&taskId=u25c1d019-e4f1-4cb3-9fef-a5363cacec8&title=&width=619)\n\n2. Q1：`G 001D`执行程序至程序返回前，用U命令查看data段内容: $0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H$，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877337524-5a528fcf-a7ec-47a7-ba04-6014616d76ff.png#averageHue=%231a1a1a&clientId=u1b2351c9-0f42-4&from=paste&height=51&id=u84a23991&name=image.png&originHeight=51&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1917&status=done&style=none&taskId=u5609cee2-98bd-479e-9a89-84510ea0a9d&title=&width=480)\n\n3. Q2：R命令查看各个段寄存器的值  $\\to \\;CS:076E$、 $DS:076C$、$SS:076D$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877858110-72e7472f-1574-4c88-ae28-a064f40894e4.png#averageHue=%23131313&clientId=u1b2351c9-0f42-4&from=paste&height=73&id=u1f2d1ce2&name=image.png&originHeight=73&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3486&status=done&style=none&taskId=ub88918a8-2d91-4abe-b21e-299699ae7ce&title=&width=592)\n\n4. Q3：data段和stack段分别占16个字节，因此设code段段地址为$X$，那么stack段段地址为$X-1H$，data段段地址为$X-2H$（做了assignment2后可以发现这里说法并不准确）\n<a name=\"qSFne\"></a>\n## assignment 2\n\n1. 步骤与assigment1 完全一致\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878358257-7f67627a-48a8-45cf-bc4a-1f51e9552faa.png#averageHue=%230f0f0f&clientId=u1b2351c9-0f42-4&from=paste&height=265&id=u246ed639&name=image.png&originHeight=265&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=true&size=9903&status=done&style=none&taskId=ud7500b3a-6b24-43c1-8498-3e220eabeef&title=%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E5%90%8E%E7%94%A8U%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%90%84%E4%B8%AA%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&width=615 \"源程序载入内存后用U命令查看，发现各个段的地址与assignment1完全一致\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878450151-f2a27665-630b-4784-9a07-7c364c930469.png#averageHue=%23111111&clientId=u1b2351c9-0f42-4&from=paste&height=84&id=u67d44730&name=image.png&originHeight=84&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=true&size=3313&status=done&style=none&taskId=u45570d21-23d5-4112-8fa2-e8d2f41ad8a&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D&width=582 \"执行程序至程序返回前\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878510541-e58f6906-dc84-4df0-a6a2-59cfdf0b4a07.png#averageHue=%231a1a1a&clientId=u1b2351c9-0f42-4&from=paste&height=54&id=u68b4b398&name=image.png&originHeight=54&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=true&size=2010&status=done&style=none&taskId=u823673f9-a9eb-4ebf-a4ee-ae34390d952&title=%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%80%E8%87%B4%EF%BC%8C%E6%9C%AA%E6%94%B9%E5%8F%98&width=504 \"查看data段数据，与源程序一致，未改变\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878562565-32d00b48-a53b-4868-916e-9e7ddb4a279d.png#averageHue=%23131313&clientId=u1b2351c9-0f42-4&from=paste&height=72&id=udc9f18e6&name=image.png&originHeight=72&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=true&size=3334&status=done&style=none&taskId=uf3897f64-0600-409f-903a-e0c60d2a195&title=%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%EF%BC%8C%E5%90%84%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&width=598 \"查看寄存器内容，各段寄存器内容与assignment1完全一致\")\n\n2. 得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍\n<a name=\"AiceH\"></a>\n## assignment 3\n\n1. 步骤与assignment1完全一致\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879121558-74eaedb2-acd9-4a9c-a318-e028bba49db2.png#averageHue=%23101010&clientId=u1b2351c9-0f42-4&from=paste&height=264&id=u5b46f0b2&name=image.png&originHeight=264&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=true&size=9249&status=done&style=none&taskId=uab9b0f8d-e010-40c9-ba7f-3de6b6e1d63&title=%E8%B5%B7%E5%A7%8B%E6%AE%B5%E4%B8%BAcode%E6%AE%B5%20%28076C%29%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9D%80data%E6%AE%B5%28076F%29%E5%92%8Cstack%E6%AE%B5%280770%29&width=583 \"起始段为code段 (076C)，后面跟着data段(076F)和stack段(0770)\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879373761-d05b59a9-6591-4c25-8033-e83698bff61e.png#averageHue=%23171717&clientId=u1b2351c9-0f42-4&from=paste&height=294&id=u7e2149b7&name=image.png&originHeight=294&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=true&size=10607&status=done&style=none&taskId=u25c23b4d-250b-45e7-aa47-be84b0e1458&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D%EF%BC%8C%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E5%86%85%E5%AE%B9%E5%92%8C%E5%90%84%E4%B8%AA%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC&width=625 \"执行程序至程序返回前，查看data段内容和各个段寄存器的值\")<br />2， 设code段段地址为$X$，那么data段段地址为$X+3H$，stack段段地址为$X+4H$\n<a name=\"NxsNH\"></a>\n## assignment 4\n如果去掉通知编译器程序的入口的`end start `语句，那么唯一可正确运行的是起始段为code段的程序3\n<a name=\"oVwXx\"></a>\n## assignment 5\n\n1. 编写源程序，注意在将段地址写入$DS$时，要借助一个寄存器充当介质，因为立即数无法直接写入$DS$\n```\nassume cs:code\n\na segment \ndb 1,2,3,4,5,6,7,8\na ends\n\nb segment\ndb 1,2,3,4,5,6,7,8\nb ends\n\nc segment \ndb 0,0,0,0,0,0,0,0\nc ends\n\ncode segment\nstart:\nmov bx, 0\nmov cx, 8\ns:\nmov dx, a\nmov ds,dx\nmov ax, [bx]\nmov dx, b\nmov ds,dx\nadd ax, [bx]\nmov dx, c\nmov ds,dx\nmov [bx], ax\ninc bx\nloop s\n\nmov ax,4c00H\nint 21H\n\ncode ends\n\nend start\n\n```\n\n2. 用debug跟踪程序，可以看到a段段地址：$076C$、b段段地址：$076D$、c段段地址：$076E$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882442409-a3ef513e-eb43-4f18-abf5-ea6f262cc3f6.png#averageHue=%230e0e0e&clientId=u1b2351c9-0f42-4&from=paste&height=333&id=u80ddd30c&name=image.png&originHeight=333&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11543&status=done&style=none&taskId=u0f76c72f-ed96-431c-8d71-352a3ca1f86&title=&width=603)\n\n3. 执行程序，查看c段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882790995-352f2b4b-203d-458a-b5a2-878acfd29335.png#averageHue=%231e1e1e&clientId=u1b2351c9-0f42-4&from=paste&height=59&id=uc023038f&name=image.png&originHeight=59&originWidth=498&originalType=binary&ratio=1&rotation=0&showTitle=true&size=2633&status=done&style=none&taskId=ucae589f2-04bc-4644-899d-6fdbd17e620&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%89%8D%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&width=498 \"执行程序前，C段内容\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882830219-1912f93e-456b-47b1-b06a-32816e308e07.png#averageHue=%23171717&clientId=u1b2351c9-0f42-4&from=paste&height=95&id=ud9a53aa1&name=image.png&originHeight=95&originWidth=479&originalType=binary&ratio=1&rotation=0&showTitle=true&size=3576&status=done&style=none&taskId=udb82a728-cd51-436e-9481-a8a6f072f71&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&width=479 \"执行程序后，C段内容\")\n<a name=\"azFBM\"></a>\n## assignment 6\n\n1. 编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的\n```\nassume cs:code\na segment\ndw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh\na ends\n\nb segment \ndw 0,0,0,0,0,0,0,0\nb ends\n\ncode segment \nstart:\nmov ax, a\nmov ds, ax\nmov ax, b \nmov ss, ax\nmov sp, 0010H\nmov bx, 0\nmov cx, 8\ns:\npush [bx]\nadd bx, 2\nloop s\n\nmov ax, 4c00H\nint 21H\n\ncode ends\n\nend start\n```\n\n2. 用debug跟踪程序，可以看到a段段地址： $076C$ 、 b段段地址：$076E$、code段段地址：$076F$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885232599-a5e6bf92-ae97-421b-ad5b-904f427aef76.png#averageHue=%230f0f0f&clientId=u1b2351c9-0f42-4&from=paste&height=296&id=ub52c7fd8&name=image.png&originHeight=296&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10267&status=done&style=none&taskId=ub78885e9-2d92-486e-abce-ac5186f563b&title=&width=590)\n\n3. 执行程序，查看b段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885271367-eddf0cc8-98aa-4fe8-a38f-a014ed5f8179.png#averageHue=%231b1b1b&clientId=u1b2351c9-0f42-4&from=paste&height=228&id=ud387c905&name=image.png&originHeight=228&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10970&status=done&style=none&taskId=u9df34674-6438-4f64-8810-2056308e5b5&title=&width=525)\n\n---\n\n<a name=\"O7BgM\"></a>\n# 实验6 实践课程中的程序\n<a name=\"dyxQS\"></a>\n## assignment 1\n\n1. 这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下\n```\nassume cs:codesg, ds:datasg, ss:stacksg\n\ndatasg segment \ndb 'ibm             '\ndb 'dec             '\ndb 'dos             '\ndb 'vax             '\ndatasg ends\n\nstacksg segment\ndw 0,0,0,0,0,0,0,0\nstacksg ends\n\ncodesg segment\nstart:\nmov ax, stacksg\nmov ss, ax\nmov sp, 10H\nmov ax, datasg\nmov ds, ax\nmov bx, 0\nmov cx, 4\ns0:\npush cx\nmov si, 0\nmov cx, 3\ns:\nmov al, [bx+si]\nand al, 11011111B\nmov [bx+si], al\ninc si\nloop s \n\npop cx\nadd bx, 10H\nloop s0\n\nmov ax, 4c00H\nint 21H\n\ncodesg ends\n\nend start\n```\n\n2. 跟踪程序，查看data段内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954476992-988989f0-7ba5-4132-8b53-011e5cfe1ce7.png#averageHue=%23111111&clientId=ue12bca8e-25be-4&from=paste&height=332&id=u6d512701&name=image.png&originHeight=332&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11651&status=done&style=none&taskId=uac27a62a-e7e2-4573-8364-30a015779f0&title=&width=619)\n\n3. 执行程序后，查看data段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954644257-b63d5af0-f266-4057-b1e1-c513e09c9298.png#averageHue=%23151515&clientId=ue12bca8e-25be-4&from=paste&height=114&id=u73878512&name=image.png&originHeight=114&originWidth=574&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4009&status=done&style=none&taskId=u92fc65de-f6f5-42c1-84b2-350c1e4d948&title=&width=574)\n<a name=\"pHbEJ\"></a>\n## assignment 2\n\n1. 编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突\n```\nassume cs:codesg, ds:datasg, ss:stacksg\n\nstacksg segment\ndw 0,0,0,0,0,0,0,0\nstacksg ends\n\ndatasg segment \ndb '1. display      '\ndb '2. brows        '\ndb '3. replace      '\ndb '4. modify       '\ndatasg ends\n\ncodesg segment\nstart:\nmov ax, stacksg\nmov ss, ax\nmov sp, 10H \nmov ax, datasg\nmov ds, ax\nmov bx, 0\nmov cx, 4\ns0:\npush cx\nmov cx, 4\nmov si, 0\ns: \nmov al, [bx+3+si]\nand al, 11011111B\nmov [bx+3+si], al\ninc si\nloop s\n\npop cx\nadd bx, 10H\nloop s0\n\nmov ax, 4c00H\nint 21H\n\ncodesg ends\n\nend start\n\n\n\n```\n\n2. 跟踪程序，查看data段内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955793129-198d15a6-56f1-4375-a4c1-fa6d84e6aa7c.png#averageHue=%23111111&clientId=ue12bca8e-25be-4&from=paste&height=311&id=u5ce4b731&name=image.png&originHeight=311&originWidth=623&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12680&status=done&style=none&taskId=u132e706b-1ed7-4582-becb-0f6cd930428&title=&width=623)\n\n3. 执行程序，查看data段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955864652-707fd6d7-d65d-4be6-b3f9-bbcbbc27484b.png#averageHue=%23151515&clientId=ue12bca8e-25be-4&from=paste&height=110&id=ubb174b39&name=image.png&originHeight=110&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5260&status=done&style=none&taskId=u786ee51b-5382-4915-8eb1-9feeb54fdba&title=&width=618)\n\n---\n\n<a name=\"MJU1z\"></a>\n# 实验7 寻址方式在结构化数据访问中的应用\n\n1. 编写源程序，用`word ptr / byte ptr`指定内存单元大小主要应用在`div`指令或用于向内存写入立即数\n```\nassume cs:codesg\n\nstack segment\ndw 0,0,0,0,0,0,0,0\nstack ends\n\ndata segment\ndb '1975','1976', '1977', '1978', '1979', '1980', '1981', '1982','1983'\ndb '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992'\ndb '1993', '1994', '1995'\n\ndd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514\ndd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000\n\ndw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226\ndw 11542,14430,15257,17800\ndata ends\n\ntable segment\ndb 21 dup ('year summ ne ?? ')\ntable ends\n\ncodesg segment\nstart:\nmov ax, stack ;0776C\nmov ss, ax\nmov sp, 10H\nmov ax, data ; 076D\nmov es, ax\nmov ax, table ; 077b\nmov ds, ax\nmov bx,0\nmov si,0\nmov cx,21\n\nyear:\npush cx\nmov cx, 4\nmov di, 0\nchar:\nmov al, es:[si]\nmov [bx+di], al\ninc di\ninc si\nloop char\npop cx\nadd bx, 10H\nloop year\n\nmov cx, 21\nmov bx, 0\nincome:\npush cx\nmov cx, 2\nmov di, 0\ndwInt:\nmov ax, es:[si]\nmov [bx].5[di], ax\nadd si, 2\nadd di, 2\nloop dwInt\npop cx\nadd bx, 10H\nloop income\n\nmov cx, 21\nmov bx, 0\nstaff:\nmov ax, es:[si]\nmov [10+bx], ax\nadd si, 2;\nadd bx, 10H\nloop staff\n\nmov cx, 21\nmov bx, 0\naverage:\nmov dx, [bx+7]\nmov ax, [bx+5]\ndiv word ptr [bx+0AH]\nmov [bx+0Dh], ax\nadd bx, 10H\nloop average\n\nmov ax, 4C00H\nint 21H\ncodesg ends\nend start \n```\n\n2. 查看原始table段的内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054412418-905eb553-63b9-4352-8fd3-87d9c57ec955.png#averageHue=%231d1d1d&clientId=u59b02d03-003e-4&from=paste&height=312&id=ue1c1140e&name=image.png&originHeight=312&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19887&status=done&style=none&taskId=ue6fc1e9d-9b84-43c0-852e-a69d953b492&title=&width=640)\n\n3. 执行程序后，查看table段的内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054465034-493bafb1-d935-4da9-b3d0-07b0bdd54911.png#averageHue=%231b1b1b&clientId=u59b02d03-003e-4&from=paste&height=378&id=u98d88789&name=image.png&originHeight=378&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21611&status=done&style=none&taskId=u95e0d8ba-0b80-4cd2-9a0a-a3aaec2f835&title=&width=630)\n<a name=\"wI3bu\"></a>\n# 实验8 分析一个奇怪的程序\n\n1. 程序从$start$入口处开始执行，一个`nop`指令占一个字节并表示No operation，此处用了两个`nop`指令的目的是在$s$处预留两个字节的空间，程序执行`mov cs:[di], ax`之后$s$处的两个字节被试图写入`jmp short s1`，接着程序向下执行`jmp short s`使得程序跳转回$s$处开始执行。\n2. `jmp short s1`到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从$s2$跳转到$s1$，即从$s2$处的jmp指令的下一指令`nop`$(076C:0022)$跳转到$s1$处的`mov ax, 0`$(076C:0018)$，因为`jmp short 标号`是依据位移进行转移的指令，而此处位移大小为$0022H-0018H =-10D(F6H)$，所以$s$处的`jmp short s`指令的机器码为`EBF6`（刚好占两个字节，因此可以被正确写入$s$处）\n3. 执行$s$处的跳转指令，使得$IP = IP+(-10)$,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为`mov ax, 4c00H`$(000AH-0010H=0000H)$，程序从此处开始向下执行，最终可以正确退出\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674306714709-54439679-a96b-496d-97b1-de0f2c3abf77.png#averageHue=%230d0d0d&clientId=u6f9c44da-f55a-4&from=paste&height=383&id=u78c30e80&name=image.png&originHeight=383&originWidth=595&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10505&status=done&style=none&taskId=uae9cedf9-248f-4122-b32a-b23020dad5f&title=&width=595)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674308784974-d476fbd5-6642-45a7-8e5a-a3db1e5ed646.png#averageHue=%230a0a0a&clientId=u6f9c44da-f55a-4&from=paste&height=150&id=ua98d7cca&name=image.png&originHeight=150&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3506&status=done&style=none&taskId=ufcfb45ef-5abd-4191-9c60-6ca3d7ac8c6&title=&width=640)\n<a name=\"lZyJr\"></a>\n# 实验9 根据材料编程\n\n1. 编写源程序：最开始我试图用`mov address，data`的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据`welcome to masm!`，利用寄存器$ax$作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据\n```\nassume cs:codesg\n\ndata segment\ndb 'welcome to masm!'\ndata ends\n\ncodesg segment\nstart: \nmov ax, data\nmov ds, ax\nmov ax, 0B800H\nmov es, ax\n\nmov bx, 0\nmov si, 1824\nmov cx, 10H\ns0:\nmov ah, 82H\nmov al, [bx]\nmov es:[si], ax\ninc bx\nadd si, 2\nloop s0\n\nmov bx, 0 \nmov si, 1984\nmov cx, 10H\ns1:\nmov ah, 0A4H\nmov al, [bx]\nmov es:[si], ax\ninc bx\nadd si, 2\nloop s1\n\nmov bx, 0 \nmov si, 2144\nmov cx, 10H\ns2:\nmov ah, 11110001B\nmov al, [bx]\nmov es:[si], ax\ninc bx\nadd si, 2\nloop s2\n\nmov ax, 4c00H\nint 21H\ncodesg ends\n\nend start\n```\n\n2. 最终效果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674447541217-19494cef-6da4-4fd3-b28c-6ad18c755471.png#averageHue=%23080808&clientId=u2be92af7-bf87-4&from=paste&height=400&id=u7d46ece7&name=image.png&originHeight=400&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8808&status=done&style=none&taskId=u5b2b0b44-a96d-458a-878e-8f9b74b9697&title=&width=640)\n\n<a name=\"zPzcC\"></a>\n# 实验10 编写子程序\n<a name=\"Z9mXL\"></a>\n## assignment 1\n\n1. 编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（**注意入栈顺序与出栈顺序相反**）\n```\nassume cs:code\ndata segment\ndb \"welcome to masm!\", 0\ndata ends\n\nstack segment\ndw 16 dup (0)\nstack ends\n\ncode segment\nstart:\nmov dh, 8\nmov dl, 3\nmov cl, 2\nmov ax, data\nmov ds, ax\nmov ax, stack\nmov sp, 20H\nmov si, 0\ncall show_str\n\nmov ax, 4C00H\nint 21H\n\nshow_str:\npush ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复\npush bx\npush cx\npush dx\npush es\npush si\n\nmov ax, 0B800H; 80×25彩色模式显示缓冲区\nmov es, ax\n\nmov al, 160 ; 设置指定打印位置\ninc dh ; 行数从0开始\nmul dh ; 8位乘法，结果存储在ax中\nmov bx, ax\nmov al, 2\nmul dl\nadd bx, ax\nmov ah, cl\n\nprint:\nmov cl, [si] ; 设置cx\nmov ch, 0\njcxz ok ;判断字符串是否结束\n\nmov al, cl ; 设置字符属性和值\nmov es:[bx],ax\ninc si\nadd bx, 2\njmp print\n\nok:\npop si\npop es\npop dx\npop cx\npop bx\npop ax\nret \n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674959885930-a6c4181a-e6a1-44cb-9ec8-cc5013b1314e.png#averageHue=%23141414&clientId=ue48ee0fc-f4a6-4&from=paste&height=427&id=u8c981b1c&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12224&status=done&style=none&taskId=u3854a69e-62d2-4b34-89c5-98dd0c0fb70&title=&width=642)\n<a name=\"gCr3l\"></a>\n## assignment 2\n\n1. 编写源程序，利用除法溢出公式 \n\n                   $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$<br />该公式的基本思想是将可能发生除法溢出的32位除法$X/n$，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法<br />$(H/n)*65536 + (L/n)$<br />**商（32位）：**<br />高十六位为$int(H/2)*65536$,低十六为$int([rem(H/n)*65536+L]/n)$<br />**余数（16位）：**<br />$rem([rem(H/n)*65536+L]/n)$<br />（注：对这个公式的理解有限）\n```\nassume cs:code\n\nstack segment\ndw 16 dup (0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\nmov ax, 4240H\nmov dx, 000FH\nmov cx, 0AH\ncall divdw\n\nmov ax, 4C00H\nint 21H\n\ndivdw:\npush bx\n\nmov bx, ax ; 暂存L\nmov ax, dx ; H/N\nmov dx, 0\ndiv cx ; int(H/N)在ax中，rem(H/N)在dx中\n\npush ax ; 暂存int(H/N)，除数\n\nmov ax, bx; dx and ax constitute rem(H/N)*65535+L\ndiv cx ; ax store the result\nmov cx, dx\n\npop dx ; int(H/N)\n\npop bx\nret\n\n\n\ncode ends\nend start\n```\n\n2. 运行结果正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675050216892-a6c856a5-19e3-42a9-9dae-62052e8d077c.png#averageHue=%23191919&clientId=u68f84982-1dce-4&from=paste&height=427&id=u69ef2d14&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16724&status=done&style=none&taskId=u6de69850-12af-46ff-80ef-d1f8f4817f4&title=&width=642)\n<a name=\"wHNVn\"></a>\n## assignment 3\n\n1. 编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过\n```\nassume cs:code\n\ndata segment\ndb 10 dup(0)\ndata ends\n\nstack segment\ndw 16 dup(0)\nstack ends\n\ncode segment\nstart:\nmov ax, 12666\nmov bx, data\nmov ds, bx\nmov si, 0\nmov bx, stack\nmov ss, bx\nmov sp, 20H\ncall dtoc\n\nmov dh, 8\nmov dl, 3\nmov cl, 2\ncall show_str\n\nmov ax, 4C00H\nint 21H\n\ndtoc:\npush ax\npush bx\npush cx\npush dx\npush si\npush di\n\nmov dx, 0 ; 被除数高16位 置0\nmov bx, 10\nmov di, 0 ; 字符计数\n\ndivide:\nmov cx, ax \njcxz over\ninc di\ndiv bx ; 32位除法，商在ax，余数在dx\nadd dx, 30H\npush dx\nmov dx, 0\njmp divide\n\nover:\nmov cx, di\nmove: \npop bx\nmov [si], bl\ninc si\nloop move\n\npop di\npop si\npop dx\npop cx\npop bx\npop ax\nret\n\nshow_str:\npush ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复\npush bx\npush cx\npush dx\npush es\npush si\n\nmov ax, 0B800H; 80×25彩色模式显示缓冲区\nmov es, ax\n\nmov al, 160 ; 设置指定打印位置\ninc dh ; 行数从0开始\nmul dh ; 8位乘法，结果存储在ax中\nmov bx, ax\nmov dh, 0\nmov al, 2\nmul dl\nadd bx, ax\nmov ah, cl\n\nprint:\nmov cl, [si] ; 设置cx\nmov ch, 0\njcxz ok ;判断字符串是否结束\n\nmov al, cl ; 设置字符属性和值\nmov es:[bx],ax\ninc si\nadd bx, 2\njmp print\n\nok:\npop si\npop es\npop dx\npop cx\npop bx\npop ax\nret \n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070403817-35e5aa0f-3d0c-42ab-803a-9d7dbf5bcb8a.png#averageHue=%231f1f1e&clientId=u9270fba6-a6a8-4&from=paste&height=427&id=uc1ace679&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=16905&status=done&style=none&taskId=uf4805ca7-fbac-43eb-a257-f1c820ade31&title=%E6%AD%A3%E7%A1%AE%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%AE%B5&width=642 \"正确写入数据段\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070685747-6e72ffff-b062-418d-9d09-67596698a4ca.png#averageHue=%23141313&clientId=u9270fba6-a6a8-4&from=paste&height=427&id=ub539738e&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=12534&status=done&style=none&taskId=u448c5569-17ad-4eec-8879-9d56a9e0d67&title=%E6%AD%A3%E7%A1%AE%E6%89%93%E5%8D%B0&width=642 \"正确打印\")\n<a name=\"ww3wC\"></a>\n# 实验11 编写子程序\n\n1. 编写源程序：主要用到了`cmp`指令和条件转移指令组合形成的if逻辑\n```\nassume cs:codesg\ndatasg segment\ndb \"Beginner's All-purpose Symbolic Instruction Code.\",0\ndatasg ends\n\ncodesg segment\nbegin:\nmov ax, datasg\nmov ds, ax\nmov si, 0\ncall letterc\n\nmov ax, 4C00H\nint 21H\n\nletterc:\npush ax\npush cx\n\nCapital:\nmov al, [si]\nmov cl, al\nmov ch, 0\njcxz OK\ncmp al, 97\njb NO\ncmp al, 122\nja NO\nand al, 11011111B\nmov [si], al\t\n\nNO:\ninc si\njmp short Capital\n\nOK:\npop cx\npop ax\nret\n\ncodesg ends\nend begin\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142887049-1e6b7958-8779-4745-81f5-c6a536a232ca.png#averageHue=%231d1d1d&clientId=u14a9d0ea-1971-4&from=paste&height=427&id=u9451414e&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=18343&status=done&style=none&taskId=u733f3e2b-82d2-436e-a8de-95b8faa1f07&title=%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81&width=642 \"初始状态\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142878774-286c5ae3-e961-424a-96db-dae987c9a153.png#averageHue=%23212121&clientId=u14a9d0ea-1971-4&from=paste&height=427&id=ub5c49ec4&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=19861&status=done&style=none&taskId=u7a2a2568-c507-4078-a32b-b75eef2ec62&title=%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99&width=642 \"全部大写\")\n<a name=\"bk4z5\"></a>\n# 实验12 编写0号中断的处理程序\n\n1. 编写源程序\n\n总体来说就3个任务：\n\n- 编写中断处理程序 \n- 复制中断处理程序至内存空闲区域($0000:0200H\\to0000:02FFH$)  \n- 修改中断向量表（中断处理程序地址入口表）\n\n注意在用`jcxz`条件转移指令时，要`jmp short`回程序开头\n```\nassume cs:code\n\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset do0 ; 076C:0028\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset do0end- offset do0; 0034H\ncld\nrep movsb ; 复制程序到0:200\n\nmov word ptr es:[0], 0200H\nmov word ptr es:[0+2], 0 ; 修改中断向量表\n\nmov ax, 4C00H\nint 21H\n\ndo0:\njmp short do0start\ndb \"divide error\",0 \n\ndo0start:\nmov ax, 0B800H\nmov es, ax\nmov di, 160*12+34*2\n\nmov ax, cs\nmov ds, ax\nmov si, 202H\n\nprint:\nmov cL, [si]\nmov ch, 0\njcxz ok\nmov ah, 04h ;red\nmov al, cl\nmov es:[di], ax\ninc si\nadd di, 2 \njmp short print\n\nok:\nmov ax, 4C00H\nint 21H\n\ndo0end: ;005C\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675159533550-89caf027-f6da-4345-aa8c-e03159df600e.png#averageHue=%23141414&clientId=u2ec176e2-9874-4&from=paste&height=427&id=u6679d84b&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12440&status=done&style=none&taskId=u7d87f433-7092-4f23-a3d6-b1339bf6fe9&title=&width=642)\n<a name=\"YSdgF\"></a>\n# 实验13 编写、应用中断例程\n<a name=\"HHw6N\"></a>\n## assignment 1\n\n1. 编写源程序：与lab10-1的show_str基本一致，只需将`call-ret`更改为 `int 7cH - iret`\n```\nassume cs:code\n\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset print\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset printed - offset print\ncld\nrep  movsb\n\nmov word ptr es:[7cH*4], 0200H\nmov word ptr es:[7cH*4+2], 0 \n\nmov ax, 4C00H\nint 21H\n\nprint:\npush bx\npush cx\npush es\npush si\npush ax\npush dx\n\nmov ax, 0B800H\nmov es, ax\n\nmov al, 160\ninc dh\nmul dh ; 160*(10+1) in ax\nmov bx, ax\nmov al, 2\nmul dl ; 10*2 in ax\nadd bx, ax\nmov ah, cl\n\nstPrint:\nmov ch, 0\nmov cl, [si]\njcxz ok\n\nmov al, cl\nmov es:[bx], ax\nadd bx, 2\ninc si\njmp short stPrint\n\nok:\npop dx\npop ax\npop si\npop es\npop cx\npop bx\niret\n\nprinted:\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675224733068-a783d5cd-5d35-46b5-8032-3c8938e8347a.png#averageHue=%23131313&clientId=u8a54de4a-c425-4&from=paste&height=427&id=u9672685d&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12092&status=done&style=none&taskId=u4599fb35-92fc-4ea1-b9cb-e60668d8629&title=&width=642)\n<a name=\"LKaNX\"></a>\n## assignment 2\n\n1. 编写源程序\n\n用中断例程实现loop指令，主要需要解决三个问题\n\n- 怎么取得标号$S$的段地址和偏移地址？\n\n有一对段地址$CS$和偏移地址$IP$在中断过程时被压入栈，标号的段地址就是该CS，标号\t       的偏移地址可由该IP加上转移地址(`offset s - offset se`)得到\n\n- 得到$S$的段地址和偏移地址后，如何设置$CS:IP$\n\n用`iret`指令：`pop IP , pop CS ,  popf`\n```\nassume cs:code\n\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset lp\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset lped - offset lp\ncld\nrep  movsb\n\nmov word ptr es:[7cH*4], 0200H\nmov word ptr es:[7cH*4+2], 0 \n\nmov ax, 4C00H\nint 21H\n\nlp:\ndec cx\njcxz lpret\npush bp\nmov bp, sp\nadd [bp+2], bx\nlpret:\npop bp\niret\n\nlped:\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675237825483-f1ed3d6d-00cc-453b-91b3-757823355468.png#averageHue=%23171515&clientId=ub529a018-e1a0-4&from=paste&height=427&id=u272d8fd4&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12787&status=done&style=none&taskId=u38f1e876-6c89-499b-b704-a23609bf566&title=&width=642)\n<a name=\"TCCAl\"></a>\n## assignment 3\n```\nassume cs:code\ncode segment\ns1: db 'Good,better,best,','$'\ns2: db 'Never let it rest,','$' \ns3: db 'Till good is better,','$'\ns4: db 'And better,best.', '$'\ns: dw offset s1, offset s2, offset s3, offset s4 \nrow: db 2,4,6,8\n\nstart:\nmov ax, cs \nmov ds, ax\nmov bx, offset s\nmov si, offset row\nmov cx, 4\nok:\nmov bh, 0 \nmov dh, [si]\nmov dl, 0\nmov ah, 2 ; BIOS中断例程--设置光标\nint 10h \n\nmov dx, [bx]                                           \nmov ah, 9 ; DOS中断例程--打印字符串\nint 21h\ninc si\nadd bx, 2\nloop ok\n\nmov ax, 4C00H; DOS中断例程--程序返回，返回值在al\nint 21H\ncode ends\nend start\n```\n<a name=\"zGspx\"></a>\n# 实验14 访问 CMOS RAM\n\n1. 编写源程序\n```\nassume cs:code\n\nstack segment\ndw 16 dup (0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\nmov ax, 0B800H\nmov ds, ax\n\nmov al, 9\nmov bx, 160*12+36*2\ncall GetAscill\nmov byte ptr [bx+4], '/'\n\nmov al, 8\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], '/'\n\nmov al, 7\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], ' '\n\nmov al, 4\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], ':'\n\nmov al, 2\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], ':'\n\nmov al, 0\nadd bx, 6\ncall GetAscill\n\nmov ax, 4C00H\nint 21H\n\nGetAscill:\npush ax\npush bx\npush cx\npush dx\n\nout 70H, al\nin al, 71H\n\nmov ah, al\nmov cl, 4\nshr ah, cl\nand al, 00001111B\n\nadd ah, 30H\nadd al, 30H\n\nmov dx, 0B800H\nmov es, dx\nmov es:[bx], ah \nmov byte ptr es:[bx+1], 02H ; green\nmov es:[bx+2], al\nmov byte ptr es:[bx+3], 02H\n\npop dx\npop cx\npop bx\npop ax\nret\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675253920788-8fc4fee5-abeb-4e49-93bf-97e3873b6599.png#averageHue=%23141413&clientId=uf0bf1a62-8c66-4&from=paste&height=388&id=u067d841f&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11685&status=done&style=none&taskId=u21f4afac-9bb2-4466-b21a-1a578f58efb&title=&width=583.6363509863864)\n<a name=\"yTwL0\"></a>\n# 实验15 安装新的int 9 中断例程\n<a name=\"TIrMX\"></a>\n## 前置练习1\n在屏幕中间依次显示$a\\to z$,按Esc键后改变与颜色\n\n1. 编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把`call dword ptr ds:[0]`写成了`call word ptr ds:[0]`，导致整个系统没有正确的int 9中断例程，因此出现了错误。\n```\nassume cs:code\n\nstack segment\ndb 64 dup(0)\nstack ends\n\ndata segment\ndw 0,0\ndata ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 40H\nmov ax, data\nmov ds, ax\n\nmov ax, 0\nmov es, ax\n\npush es:[9*4]\npop ds:[0]\npush es:[9*4+2]\npop ds:[2] ; 保存原int 9中断例程的入口地址\n\ncli\nmov word ptr es:[9*4], offset int9\nmov es:[9*4+2], cs;设置新的入口地址\nsti\n\n\nmov ax, 0B800H\nmov es,ax\nmov dh, 'a'\ns:\nmov es:[160*12+40*2], dh\ncall delay\ninc dh\ncmp dh, 'z'\njna s ; 依次打印a~z\n\n\nmov ax, 0 \nmov es, ax\n\ncli\npush ds:[0]\npop es:[9*4]\npush ds:[2]\npop es:[9*4+2] ;恢复原int 9中断例程的入口地址\nsti\n\n\nmov ax, 4C00h\nint 21H\n\ndelay:\npush ax\npush dx\nmov ax, 0\nmov dx, 10H\nse:\nsub ax, 1 ; 不能用dec\nsbb dx, 0\ncmp ax, 0\njne se\ncmp dx, 0\njne se\n\npop dx\npop ax\nret ; 延时\n\nint9:\npush ax\npush es\nin al, 60H\n\npushf\ncall dword ptr ds:[0]\n\ncmp al, 01H\njne int9ret\nmov ax, 0B800H\nmov es, ax\ninc byte ptr es:[160*12+40*2+1] ; 修改字符属性\n\nint9ret:\npop es\npop ax\niret\n\ncode ends\nend start\n\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319548168-77f7b5a6-54bb-4526-b234-adb0e561004e.png#averageHue=%237ab44c&clientId=u17647ab4-03d9-4&from=paste&height=388&id=u49a1ed0a&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13571&status=done&style=none&taskId=u61859af5-760b-45d0-8b8d-c62aa3a3245&title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B21&width=583.6363509863864 \"按Esc改变颜色1\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319563355-013b242f-ab37-4a8f-a956-6222d6e1847c.png#averageHue=%238dd756&clientId=u17647ab4-03d9-4&from=paste&height=388&id=u9a049927&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13830&status=done&style=none&taskId=u52c59e7d-a185-4177-8537-a05965e054e&title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B22&width=583.6363509863864 \"按Esc改变颜色2\")\n<a name=\"vlBjq\"></a>\n## 前置练习2\n在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理\n\n1. 编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在$0:0200 \\to 0:0203$,可在新int 9中断例程中通过`cs:[200H]`访问\n```\nassume cs:code, ss:stack\n\nstack segment\ndb 32 dup(0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\n\nmov ax, 0\nmov es, ax\nmov di, 0204H\nmov ax, cs\nmov ds, ax\nmov si, offset int9\n\nmov cx, offset int9ed - offset int9\ncld\nrep movsb; 安装\n\npush es:[9*4]\npop es:[200H]\npush es:[9*4+2]\npop es:[202H] ; 保存原int 9入口地址\n\ncli\nmov word ptr es:[9*4], 204H\nmov word ptr es:[9*4+2], 0 ; 修改中断向量表\nsti\n\nmov ax, 4C00H\nint 21H\n\nint9:\npush ax\npush cx\npush es\npush di\n\nin al, 60H\n\npushf\ncall dword ptr cs:[200H] ; 调用原int 9\n\ncmp al, 3BH\njne int9ret\n\nmov ax, 0B800H\nmov es, ax\nmov di, 1\nmov cx, 2000\ns:\ninc byte ptr es:[di]\nadd di, 2\nloop s\n\nint9ret:\npop di\npop es\npop cx\npop ax\niret\n\n\nint9ed:\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322759364-2785ad21-17c7-4499-b1a3-fe6726975b02.png#averageHue=%230d0d0d&clientId=ud2f6d655-0b50-4&from=paste&height=388&id=u4340ef70&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=12813&status=done&style=none&taskId=uc1c9e4ff-ae09-465d-a787-aba159b8b98&title=%E6%8C%89%E4%B8%8BF1%201&width=583.6363509863864 \"按下F1 1\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322817620-9b94c323-5bcb-4465-ba63-7a2721ba4d46.png#averageHue=%23aeaeae&clientId=ud2f6d655-0b50-4&from=paste&height=388&id=u019e66f9&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8862&status=done&style=none&taskId=ue0c4ae51-d75f-4e13-8d7c-a26ee51e20f&title=%E6%8C%89%E4%B8%8BF1%202&width=583.6363509863864 \"按下F1 2\")\n<a name=\"XyIu0\"></a>\n## assignment 1\n\n1. 编写源程序\n\n与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码`cmp aL, 1EH+80H`\n```\nassume cs:code, ss:stack\n\nstack segment\ndb 32 dup(0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\n\nmov ax, 0\nmov es, ax\nmov di, 0204H\nmov ax, cs\nmov ds, ax\nmov si, offset int9\n\nmov cx, offset int9ed - offset int9\ncld\nrep movsb; 安装\n\npush es:[9*4]\npop es:[200H]\npush es:[9*4+2]\npop es:[202H] ; 保存原int 9入口地址\n\ncli\nmov word ptr es:[9*4], 204H\nmov word ptr es:[9*4+2], 0 ; 修改中断向量表\nsti\n\nmov ax, 4C00H\nint 21H\n\nint9:\npush ax\npush cx\npush es\npush di\n\nin aL,60h\n\npushf\ncall dword ptr cs:[200H]\n\ncmp aL, 1EH+80H\njne int9ret\n\nmov cx, 2000\nmov ax, 0B800H\nmov es, ax\nmov di, 0\ns:\nmov byte ptr es:[di], 'A'\nmov byte ptr es:[di+1], 02H\nadd di, 2\nloop s\n\nint9ret:\npop di\npop es\npop cx\npop ax\niret\n\nint9ed:\nnop\n\ncode ends\nend start\n\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675329053483-60588212-d9b5-4cef-acf7-06c70f65db5f.png#averageHue=%23141313&clientId=ud2f6d655-0b50-4&from=paste&height=388&id=u7a90e8bd&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=7755&status=done&style=none&taskId=u3c74959a-2b05-4756-8089-500ac2f8893&title=%E6%8C%89%E4%B8%8BA%E5%90%8E%E6%9D%BE%E5%BC%80&width=583.6363509863864 \"按下A后松开\")\n<a name=\"YodIM\"></a>\n# 实验16 编写包含多个功能子程序的中断例程\n\n1. 编写源程序\n\n注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H\n```\nassume cs:code\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset int7ch\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset int7ched - offset int7ch\ncld\nrep  movsb\n\nmov word ptr es:[7cH*4], 0200H\nmov word ptr es:[7cH*4+2], 0 \n\nmov ax, 4C00H\nint 21H\n\nint7ch:\njmp short int7chStart\ntable dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200H\n\nint7chStart:\npush ax\npush bx\ncmp ah, 3\nja int7chRet\nmov bl, ah\nmov bh, 0\nadd bx, bx\ncall word ptr cs:(table-int7ch+200H)[bx]\n\nint7chRet:\npop bx\npop ax\niret\n\nSub1:\npush ax\npush bx\npush cx\npush ds\nmov ax, 0B800H\nmov ds, ax\nmov cx, 2000\nmov bx, 0\ns1:\nmov byte ptr [bx], ' '\nadd bx, 2\nloop s1\npop ds\npop cx\npop bx\npop ax\nret\n\nSub2:\npush ax\npush bx\npush cx\npush ds\nmov bx, 0B800H\nmov ds, bx\nmov cx, 2000\nmov bx, 1\ns2:\nand byte ptr [bx], 11111000B ; 只设置最后3位\nor byte ptr [bx], al\nadd bx, 2\nloop s2\npop ds\npop cx\npop bx\npop ax\nret\n\nSub3:\npush ax\npush bx\npush cx\npush ds\nmov bx, 0B800H\nmov ds, bx\nmov cl, 4\nshl al, cl\nmov cx, 2000\nmov bx, 1\ns3:\nand byte ptr [bx], 10001111B\nor [bx], al\nadd bx, 2\nloop s3\npop ds\npop cx\npop bx\npop ax\nret\n\nSub4:\npush ax\npush bx\npush cx\npush ds\npush es\npush si\npush di\nmov bx, 08B00H\nmov es, bx\nmov ds, bx\nmov si, 160\nmov di, 0\ncld\nmov cx, 24\n\ns4:\npush cx\nmov cx, 160\nrep movsb\npop cx\nloop s4\n\nmov cx, 80\nmov si, 0\ns41:\nmov byte ptr [160*24+si], ' '\nadd si ,2\nloop s41\npop di\npop si\npop es\npop ds\npop cx\npop bx\npop ax\nret\n\nint7ched:\nnop\n\ncode ends\nend start\n```\n```\nassume cs:code\n\ncode segment\nstart:\nmov ah,1 ; 0 2 3\nmov al,2\nint 7CH\n\nmov ax, 4C00H\nint 21H\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411618416-c6c100a2-f4d1-4bc9-b3e6-22f83fcdcaee.png#averageHue=%230d0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u97049213&name=image.png&originHeight=427&originWidth=620&originalType=binary&ratio=1&rotation=0&showTitle=true&size=5698&status=done&style=none&taskId=udfd4d7d0-2546-4521-8884-82d74fe5421&title=%E5%8A%9F%E8%83%BD1%EF%BC%9A%E6%B8%85%E5%B1%8F&width=620 \"功能1：清屏\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411466691-92faf4b3-fbd7-4859-b68b-e403f87d23e1.png#averageHue=%230e0e0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u0af61a75&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=11776&status=done&style=none&taskId=ud7c332b2-9214-4185-917e-392d79cda17&title=%E5%8A%9F%E8%83%BD2%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%89%8D%E6%99%AF%E8%89%B2&width=642 \"功能2：设置前景色\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411696534-79bed444-6b2a-4a77-ad72-027fb2081a4b.png#averageHue=%2300a900&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ue6689a35&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=11354&status=done&style=none&taskId=u07994587-f0a4-4e4c-b31e-52a54f59cd3&title=%E5%8A%9F%E8%83%BD3%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E8%89%B2&width=642 \"功能3：设置背景色\")\n<a name=\"IRx7s\"></a>\n# 实验17 编写包含多个功能子程序的中断例程\n第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了\n<a name=\"upigZ\"></a>\n## 练习17-1\n接受用户的键盘输入，输入\"r\"，\"g\",“b”分别将屏幕上的字符设置为红色，绿色，蓝色\n\n1. 编写源程序\n\n用功能号为0的int 16H中断例程读取键盘输入即可\n```\nassume cs:code\n\ncode segment\nstart:\n\nshow:\npush ax\npush es\npush di\n\nmov ah, 0\nint 16H\n\nmov bl, 1\ncmp al,'b'\nje showst\nshl bl, 1\ncmp al, 'g'\nje showst\nshl bl, 1\ncmp al, 'r'\nje showst\njmp short FRet\n\nshowst:\nmov ax, 0B800H\nmov es, ax\nmov di, 1\nmov cx, 2000\ns:\nand byte ptr es:[di], 11111000B\nor es:[di], bl\nadd di, 2\nloop s\n\nFRet:\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431818731-db0edf92-bc54-4bfc-a35f-613c796dddda.png#averageHue=%230f0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u2f889938&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8416&status=done&style=none&taskId=u3c7affc7-f57c-470f-9cab-1a94bcb3c74&title=r-red&width=642 \"r-red\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431840911-15621108-ffb6-42ce-94ab-603c36fe9540.png#averageHue=%230d0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u1bb9ce94&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8174&status=done&style=none&taskId=u26c95d33-ee9d-414a-9861-7aa91427bc6&title=g-green&width=642 \"g-green\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431855013-727c9bbb-b9bf-43a5-9ca6-ea80957dfa92.png#averageHue=%230d0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ucb1b0f24&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8133&status=done&style=none&taskId=ub45cc602-bef7-4fba-9ec7-3d4b52f4485&title=b-blue&width=642 \"b-blue\")\n<a name=\"Wyllk\"></a>\n# Other\n<a name=\"QMCD1\"></a>\n## 1. 理解assume伪指令的作用\n```\nassume cs:code, ds:data\ndata segment\na db 1,2,3,4,5,6,7,8\nb dw 0\ndata ends\n\ncode segment\nstart:\nmov ax, data\nmov ds, ax\n\nmov si, 0\nmov cx, 8\n\ns:\nmov ah, 0\nmov al, a[si]\nadd b, ax\ninc si\nloop s\n\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n\n1. `assume ds:data ss:stack`\n- assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器$DS、SS$中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:`mov ax, data ``mov ds, ax`\n- assume是伪指令，用于指示编译器将$DS、SS$分别与data段和stack段关联。①关联是什么意思呢？就是**在编译时默认data段中的数据标号a、b的段地址在**$DS$**中**，因此如果要正确访问到a、b的内容，必须用指令将data填入$DS$中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此`mov ax, data`在编译器看来是`mov ax, data段段地址`，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax\n\n如果在程序中省略`assume ds:data`，则会出现_不能用段寄存器寻址_的错误<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675343108877-68cf68d3-97ef-4ecb-8b4f-6da330149c94.png#averageHue=%23161616&clientId=u3f46bb08-d532-4&from=paste&height=388&id=uffd0ec43&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13264&status=done&style=none&taskId=ud9fb02f3-e117-4559-bfe1-1659d6727ee&title=&width=583.6363509863864)\n\n2. `assume cs:codesg`\n\n将$CS$与代码段关联，在程序加载时将代码段(codesg)的段地址放入$CS$中. 如果去掉该语句，则程序编译不通过，因为$CS$的值不确定<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675341791119-4c9029f0-b9e3-4e2f-b1b9-aa5d02685f8f.png#averageHue=%230d0d0d&clientId=u3f46bb08-d532-4&from=paste&height=276&id=u952199f2&name=image.png&originHeight=304&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9905&status=done&style=none&taskId=ud6cc6c48-9ce9-4df5-a654-02e53729a4d&title=&width=581.8181692076126)\n<a name=\"wwfwW\"></a>\n## 2. 理解数据标号\n\n1. 数据标号与地址标号的不同\n\n地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）\n```\nassume cs:code, es:data\ndata segment\na db 1,2,3,4,5,6,7,8\nb dw 0\ndata ends\n\ncode segment\nstart:\nmov ax, data\nmov es, ax\n\nmov si, 0\nmov cx, 8\n\ns:\nmov ah, 0\nmov al, a[si]\nadd b, ax\ninc si\nloop s\n\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n这里的a和b分别指代了\n\n- **地址为**`**seg data:0**`**, 长度为byte的字节单元**\n- **地址为**`**seg data:8**`**, 长度为word的字单元**\n2. 如何用数据标号以简洁形式访问内存中的数据\n\n在上一个程序中，我们用`mov al, a[si]` `add b, ax`访问了data段的内容，在编译器看来，这两条语句是这样的: `mov al, es:0[si]``add es:[8], ax`<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409971871-70ff728a-fa74-48ac-a742-be8ec319d677.png#averageHue=%23191919&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u6e4d3ff6&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14859&status=done&style=none&taskId=ua1726f99-29ec-46f7-ac48-ad448e15a63&title=&width=642)<br />我们现在用更熟悉的`mov al, [si+a]` `add b[0], ax`形式，从编译器角度来看，这两种形式没有区别<br />这说明了在指令中**a等价于**`**byte ptr [0]**`**，b等价于**`**word ptr [8]**`（仅含偏移地址信息，默认段地址在es中，因为`assume es:data`）<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675410379440-d032239f-bb7d-480f-a45d-f96f7d064cd3.png#averageHue=%231a1919&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ubbac8493&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15290&status=done&style=none&taskId=uce443a00-0b21-4ac2-89ac-bb7e70f3432&title=&width=642)\n\n3. 将标号当作数据定义\n```\nassume cs:code, ds:data\ndata segment\na db 1,2,3,4,5,6,7,8\nb dw 0\nc dw a, b\ndata ends\n\ncode segment\nstart:\nmov ax, data\nmov ds, ax\n\nmov dx, 2\nmov dx, c\nmov ax, c[1]\n\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n`c dw a, b`将数据标号当作数据定义，c指代地址为`seg data:000A`的字单元，**该字单元的内容是a的偏移地址**$0000$，下面是验证<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409382345-20e1a2f2-8973-4150-992a-2a8acb141fa9.png#averageHue=%23191919&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ud990b41d&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15496&status=done&style=none&taskId=u9d64f540-f9d7-4f4d-a179-67094b0601b&title=&width=642)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409496753-347acc0d-300d-4502-b228-e202ee4504a4.png#averageHue=%23101010&clientId=uaa2840e8-10be-4&from=paste&height=400&id=u97a8ca97&name=image.png&originHeight=400&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12100&status=done&style=none&taskId=u65363c06-9a66-4677-9782-717ab71b1b6&title=&width=640)\n\n","source":"_posts/assembly.md","raw":"---\ntitle: \"汇编语言【王爽】实验流程\"\ndate: 2023-03-06\ncategories: \n- CSAPP\ntag: \n- Foundation\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"MTE7s\"></a>\n# 前言：\n前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的attack lab完成了\n<!--more-->\n---\n\n<a name=\"PhqOH\"></a>\n# 实验1 查看CPU和内存，用机器指令和汇编指令编程\n<a name=\"xymUo\"></a>\n## debug环境搭建：[参考此文](https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506)\n<a name=\"UrdzB\"></a>\n## assignment 1\n\n1. 用A命令向内存中写入汇编指令，用U命令查看\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249473372-3a80b2ab-d9e2-483c-ac41-140d30fdd765.png#averageHue=%23161616&clientId=uc99250e8-54b1-4&from=paste&height=248&id=ub963f2d1&name=image.png&originHeight=245&originWidth=374&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6659&status=done&style=none&taskId=u0fa9efb8-dccf-4ce1-b3ea-8d79929c540&title=&width=378)\n\n2. 用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249669344-d36231e5-8310-46ba-a3c6-155e2601ff58.png#averageHue=%230e0e0e&clientId=uc99250e8-54b1-4&from=paste&height=309&id=udc060390&name=image.png&originHeight=309&originWidth=608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7838&status=done&style=none&taskId=udc51570f-ded8-4f72-a2f5-ee442502176&title=&width=608)\n<a name=\"rTW1r\"></a>\n## assignment 2\n\n1. 写入并查看指令\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250172971-61fbb876-feda-4ca9-b81d-e558cc0e5a6a.png#averageHue=%23151515&clientId=uc99250e8-54b1-4&from=paste&height=174&id=u55f6e2fe&name=image.png&originHeight=174&originWidth=376&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4324&status=done&style=none&taskId=u9c9ba619-9a5c-4e5c-9e9d-45d5a6ea724&title=&width=376)\n\n2. 修改_CS:IP_指向\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250237721-ec3e62f5-f6bc-4890-8f25-b62f6d89e60e.png#averageHue=%230c0c0c&clientId=uc99250e8-54b1-4&from=paste&height=228&id=u87c23aee&name=image.png&originHeight=228&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7409&status=done&style=none&taskId=u0c70f1dc-bfd2-4472-a4d5-84a3fe97214&title=&width=642)\n\n3. 执行指令，计算$2^8$，结果为 $AX = 0100H$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250558182-3582fd8d-9783-421c-9731-0d83ae5c81a8.png#averageHue=%23121212&clientId=uc99250e8-54b1-4&from=paste&height=72&id=u92a48cc6&name=image.png&originHeight=72&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2934&status=done&style=none&taskId=ud124b271-ce25-43f5-aabf-1f9dd478c19&title=&width=583)\n<a name=\"QAZ3Z\"></a>\n## assignment 3\n\n1. 用D命令查找，最终在$FFFF5H \\to FFFFCH（FFFF:0005 \\to FFFF:000C）$发现$dd/mm/yy$字样的生产日期\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251622812-ca79ef23-5a2a-46b2-ba9f-326aa9d3bc54.png#averageHue=%23161616&clientId=uc99250e8-54b1-4&from=paste&height=68&id=ud8481a70&name=image.png&originHeight=68&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3411&status=done&style=none&taskId=u26b9075a-3732-4bca-831f-f7252d9a335&title=&width=630)\n\n2. 尝试用E命令修改，该操作失效，因为这是ROM\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251941938-25cdf39e-5c26-49a3-81da-f108dff28da7.png#averageHue=%230f0f0f&clientId=uc99250e8-54b1-4&from=paste&height=120&id=u23687460&name=image.png&originHeight=120&originWidth=632&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4133&status=done&style=none&taskId=uca81322b-a794-4e03-b596-0d7a694a021&title=&width=632)\n<a name=\"CHS7t\"></a>\n## assignment 4\n1.$A0000H \\to BFFFFH$对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253290191-823908a7-61e0-4e4d-ac20-66184b8a4509.png#averageHue=%23141414&clientId=uc99250e8-54b1-4&from=paste&height=24&id=udb4b1014&name=image.png&originHeight=24&originWidth=316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=646&status=done&style=none&taskId=uc1f68660-8c22-4e6b-81ab-8168f9d217e&title=&width=316)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253301915-ead25a09-d4a2-48f2-ba25-7bb4b7279d64.png#averageHue=%230000aa&clientId=uc99250e8-54b1-4&from=paste&height=46&id=u1f906edf&name=image.png&originHeight=46&originWidth=489&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1808&status=done&style=none&taskId=u8980a613-e82f-4ceb-a518-1e33c095648&title=&width=489)\n\n---\n\n<a name=\"hcb7h\"></a>\n# 实验2 用机器指令和汇编指令编程\n<a name=\"vDc8z\"></a>\n## assignment 1\n\n1. 用A指令向内存中写入汇编指令，用U指令查看\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596808599-b129a717-4d20-42a3-8823-64dc726440e3.png#averageHue=%23151515&clientId=u2caa9258-9642-4&from=paste&height=236&id=uc9b341b4&name=image.png&originHeight=236&originWidth=374&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6210&status=done&style=none&taskId=uf45debe0-8185-465e-b3c1-03874bac6c7&title=&width=374)\n\n2. 修改CS:IP使其指向代码段\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596896692-f6335ebe-e9b7-44cf-9a38-d686dde7d140.png#averageHue=%230a0a0a&clientId=u2caa9258-9642-4&from=paste&height=162&id=u325eac60&name=image.png&originHeight=162&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4064&status=done&style=none&taskId=uaa5719c7-c665-4f9e-baa5-b5de2b24fc8&title=&width=577)、\n\n3. t命令逐步执行指令后查看AX、BX、SP寄存器内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673597028389-791ccf84-0268-4f23-976f-53e6ecd97b36.png#averageHue=%23121212&clientId=u2caa9258-9642-4&from=paste&height=374&id=ueb563e3c&name=image.png&originHeight=374&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15302&status=done&style=none&taskId=u24406e7c-e085-4926-bf36-d7ff7eeb06a&title=&width=635)\n<a name=\"NB9fg\"></a>\n## assignment 2\n在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）\n\n---\n\n<a name=\"jpe3I\"></a>\n# 实验3 编程、编译、链接、跟踪\n<a name=\"QMUAH\"></a>\n## assignment 1\n\n1. 编译链接生成可执行文件\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673681789903-cb9f13be-b044-4c3f-be1d-8fa401195306.png#averageHue=%230b0b0b&clientId=ufc3ba72b-b1bc-4&from=paste&height=328&id=ufc540080&name=image.png&originHeight=328&originWidth=524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8289&status=done&style=none&taskId=uaf6acc9d-3a30-400a-b361-0bea1d87366&title=&width=524)\n<a name=\"bm7kI\"></a>\n## assignment 2\n\n1. debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为$DS=075C$，则PSP的地址为$075C:0$，程序的地址为$076C:0\\;(075C+10:0)$,$CS:IP = 076C:0000$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682350829-98451696-0d75-4414-87c5-b527b5c96169.png#averageHue=%23111111&clientId=ufc3ba72b-b1bc-4&from=paste&height=90&id=u24027707&name=image.png&originHeight=90&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3436&status=done&style=none&taskId=u88d9a7fb-f08c-4035-82ab-48a67509d8f&title=&width=583)\n\n2. 跟踪程序执行过程\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682565168-917f19d2-8e0c-44ab-84e5-453c301bcda0.png#averageHue=%23111111&clientId=ufc3ba72b-b1bc-4&from=paste&height=378&id=u739eac5d&name=image.png&originHeight=378&originWidth=593&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13977&status=done&style=none&taskId=u7a4cf037-0141-418c-a6bc-3a455f22fa1&title=&width=593)<br />用P命令执行`INT 21`<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682678668-4d6f6ba6-a61b-408a-8aa9-f84fdd1abc8a.png#averageHue=%230d0d0d&clientId=ufc3ba72b-b1bc-4&from=paste&height=386&id=ue3d6f0ce&name=image.png&originHeight=386&originWidth=620&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12637&status=done&style=none&taskId=ud602a7a4-6c24-495c-b269-66ce57ddba3&title=&width=620)\n<a name=\"fqp3r\"></a>\n## assignment 3\n\n1. 查看PSP的内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682886059-386e1af8-2b73-480f-92b1-d2ea01cce40a.png#averageHue=%23161616&clientId=ufc3ba72b-b1bc-4&from=paste&height=175&id=ueb72f5b4&name=image.png&originHeight=175&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6346&status=done&style=none&taskId=ufec3ae9d-8d07-4ba6-ae47-78454c6ed61&title=&width=625)\n\n---\n\n<a name=\"eTiIA\"></a>\n# 实验4 [bx]和loop的使用\n<a name=\"Ypsn2\"></a>\n## assignment 1\n\n1. 编写源程序\n```\nassume cs:codesg\n\ncodesg segment\n\nmov ax, 0020H\nmov ds, ax\nmov bx, 0\nmov dx, 0\nmov cx, 64\n\ns: \nmov [bx],dx\ninc bx\ninc dx\nloop s\n\nmov ax, 4c00h \nint 21h\n\ncodesg ends\nend\n```\n\n2. 编译，链接生成可执行文件\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673769654198-dcf5a11b-b298-4d67-ac52-e6412baa7953.png#averageHue=%230a0a0a&clientId=ua6d781cd-6a2a-4&from=paste&height=308&id=ucb1b0e3f&name=image.png&originHeight=308&originWidth=563&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9162&status=done&style=none&taskId=ud2798294-b700-4d36-9278-b89b6f31b7e&title=&width=563)\n\n3. 查看载入内存的程序，可以看见标签s已被替换为地址$076C:000E$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770040980-f6175097-5e41-41f0-a0d4-ed6dcc9e2d26.png#averageHue=%230f0f0f&clientId=ua6d781cd-6a2a-4&from=paste&height=257&id=ub7d89c02&name=image.png&originHeight=257&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9471&status=done&style=none&taskId=u76baa400-787b-4ed1-b282-488abb7c243&title=&width=601)\n\n4. 执行程序，验证结果，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770269260-0b535c86-7318-4bea-9b9b-151df8786503.png#averageHue=%23151515&clientId=ua6d781cd-6a2a-4&from=paste&height=144&id=u9760e10a&name=image.png&originHeight=144&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4621&status=done&style=none&taskId=u407ff41a-3998-40b9-80e2-b904a9486e8&title=&width=480)\n<a name=\"q95Oy\"></a>\n## assignment 2 \n\n1. 编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令\n```\nassume cs:codesg\n\ncodesg segment\n\nmov ax, 0020H\nmov ds, ax\nmov bx, 0\nmov cx, 64\n\ns: \nmov [bx],bx\ninc bx\nloop s\n\nmov ax, 4c00h \nint 21h\n\ncodesg ends\nend\n```\n\n2. 其它步骤与assigment 1一致，验证结果，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673771416582-e853218d-46c6-4bf8-98d6-cacae4200dbb.png#averageHue=%231a1a1a&clientId=u7cc11769-d150-4&from=paste&height=359&id=u85d074a9&name=image.png&originHeight=373&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9679&status=done&style=none&taskId=uca7996c4-5515-4485-9bd2-5bed6cf48b4&title=&width=472)\n<a name=\"b3BKL\"></a>\n## assignment 3\n\n1. 复制的是什么：复制程序的第一条指令`mov ax,cs`到 `loop s` 指令至内存地址$0020:0000$处\n2. 如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在`mov cx,_____` 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：$076C:0000 \\to 076C:0015$，共$16H\\,(23D)$个字节,因此第二个空应该填入$16H$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673774640766-de55642e-4594-4add-9f75-ac17f9cf3628.png#averageHue=%230d0d0d&clientId=u7cc11769-d150-4&from=paste&height=282&id=u704b4ac0&name=image.png&originHeight=282&originWidth=616&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9580&status=done&style=none&taskId=u46b6c23e-98fc-45b4-ad17-7f7d7bef327&title=&width=616)\n\n---\n\n<a name=\"l6DRo\"></a>\n# 实验5 编写、调试具有多个段的程序\n<a name=\"y07m5\"></a>\n## assignment 1\n\n1. 将程序载入内存后查看，可知data段段地址为$076C$, stack段段地址为$076D$，code段段地址为$076E$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877104816-d24fcee5-293b-4965-a116-55b74e84812c.png#averageHue=%23101010&clientId=u1b2351c9-0f42-4&from=paste&height=266&id=u68a1fe4a&name=image.png&originHeight=266&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10189&status=done&style=none&taskId=u25c1d019-e4f1-4cb3-9fef-a5363cacec8&title=&width=619)\n\n2. Q1：`G 001D`执行程序至程序返回前，用U命令查看data段内容: $0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H$，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877337524-5a528fcf-a7ec-47a7-ba04-6014616d76ff.png#averageHue=%231a1a1a&clientId=u1b2351c9-0f42-4&from=paste&height=51&id=u84a23991&name=image.png&originHeight=51&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1917&status=done&style=none&taskId=u5609cee2-98bd-479e-9a89-84510ea0a9d&title=&width=480)\n\n3. Q2：R命令查看各个段寄存器的值  $\\to \\;CS:076E$、 $DS:076C$、$SS:076D$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877858110-72e7472f-1574-4c88-ae28-a064f40894e4.png#averageHue=%23131313&clientId=u1b2351c9-0f42-4&from=paste&height=73&id=u1f2d1ce2&name=image.png&originHeight=73&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3486&status=done&style=none&taskId=ub88918a8-2d91-4abe-b21e-299699ae7ce&title=&width=592)\n\n4. Q3：data段和stack段分别占16个字节，因此设code段段地址为$X$，那么stack段段地址为$X-1H$，data段段地址为$X-2H$（做了assignment2后可以发现这里说法并不准确）\n<a name=\"qSFne\"></a>\n## assignment 2\n\n1. 步骤与assigment1 完全一致\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878358257-7f67627a-48a8-45cf-bc4a-1f51e9552faa.png#averageHue=%230f0f0f&clientId=u1b2351c9-0f42-4&from=paste&height=265&id=u246ed639&name=image.png&originHeight=265&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=true&size=9903&status=done&style=none&taskId=ud7500b3a-6b24-43c1-8498-3e220eabeef&title=%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E5%90%8E%E7%94%A8U%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%90%84%E4%B8%AA%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&width=615 \"源程序载入内存后用U命令查看，发现各个段的地址与assignment1完全一致\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878450151-f2a27665-630b-4784-9a07-7c364c930469.png#averageHue=%23111111&clientId=u1b2351c9-0f42-4&from=paste&height=84&id=u67d44730&name=image.png&originHeight=84&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=true&size=3313&status=done&style=none&taskId=u45570d21-23d5-4112-8fa2-e8d2f41ad8a&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D&width=582 \"执行程序至程序返回前\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878510541-e58f6906-dc84-4df0-a6a2-59cfdf0b4a07.png#averageHue=%231a1a1a&clientId=u1b2351c9-0f42-4&from=paste&height=54&id=u68b4b398&name=image.png&originHeight=54&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=true&size=2010&status=done&style=none&taskId=u823673f9-a9eb-4ebf-a4ee-ae34390d952&title=%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%80%E8%87%B4%EF%BC%8C%E6%9C%AA%E6%94%B9%E5%8F%98&width=504 \"查看data段数据，与源程序一致，未改变\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878562565-32d00b48-a53b-4868-916e-9e7ddb4a279d.png#averageHue=%23131313&clientId=u1b2351c9-0f42-4&from=paste&height=72&id=udc9f18e6&name=image.png&originHeight=72&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=true&size=3334&status=done&style=none&taskId=uf3897f64-0600-409f-903a-e0c60d2a195&title=%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%EF%BC%8C%E5%90%84%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&width=598 \"查看寄存器内容，各段寄存器内容与assignment1完全一致\")\n\n2. 得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍\n<a name=\"AiceH\"></a>\n## assignment 3\n\n1. 步骤与assignment1完全一致\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879121558-74eaedb2-acd9-4a9c-a318-e028bba49db2.png#averageHue=%23101010&clientId=u1b2351c9-0f42-4&from=paste&height=264&id=u5b46f0b2&name=image.png&originHeight=264&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=true&size=9249&status=done&style=none&taskId=uab9b0f8d-e010-40c9-ba7f-3de6b6e1d63&title=%E8%B5%B7%E5%A7%8B%E6%AE%B5%E4%B8%BAcode%E6%AE%B5%20%28076C%29%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9D%80data%E6%AE%B5%28076F%29%E5%92%8Cstack%E6%AE%B5%280770%29&width=583 \"起始段为code段 (076C)，后面跟着data段(076F)和stack段(0770)\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879373761-d05b59a9-6591-4c25-8033-e83698bff61e.png#averageHue=%23171717&clientId=u1b2351c9-0f42-4&from=paste&height=294&id=u7e2149b7&name=image.png&originHeight=294&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=true&size=10607&status=done&style=none&taskId=u25c23b4d-250b-45e7-aa47-be84b0e1458&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D%EF%BC%8C%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E5%86%85%E5%AE%B9%E5%92%8C%E5%90%84%E4%B8%AA%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC&width=625 \"执行程序至程序返回前，查看data段内容和各个段寄存器的值\")<br />2， 设code段段地址为$X$，那么data段段地址为$X+3H$，stack段段地址为$X+4H$\n<a name=\"NxsNH\"></a>\n## assignment 4\n如果去掉通知编译器程序的入口的`end start `语句，那么唯一可正确运行的是起始段为code段的程序3\n<a name=\"oVwXx\"></a>\n## assignment 5\n\n1. 编写源程序，注意在将段地址写入$DS$时，要借助一个寄存器充当介质，因为立即数无法直接写入$DS$\n```\nassume cs:code\n\na segment \ndb 1,2,3,4,5,6,7,8\na ends\n\nb segment\ndb 1,2,3,4,5,6,7,8\nb ends\n\nc segment \ndb 0,0,0,0,0,0,0,0\nc ends\n\ncode segment\nstart:\nmov bx, 0\nmov cx, 8\ns:\nmov dx, a\nmov ds,dx\nmov ax, [bx]\nmov dx, b\nmov ds,dx\nadd ax, [bx]\nmov dx, c\nmov ds,dx\nmov [bx], ax\ninc bx\nloop s\n\nmov ax,4c00H\nint 21H\n\ncode ends\n\nend start\n\n```\n\n2. 用debug跟踪程序，可以看到a段段地址：$076C$、b段段地址：$076D$、c段段地址：$076E$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882442409-a3ef513e-eb43-4f18-abf5-ea6f262cc3f6.png#averageHue=%230e0e0e&clientId=u1b2351c9-0f42-4&from=paste&height=333&id=u80ddd30c&name=image.png&originHeight=333&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11543&status=done&style=none&taskId=u0f76c72f-ed96-431c-8d71-352a3ca1f86&title=&width=603)\n\n3. 执行程序，查看c段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882790995-352f2b4b-203d-458a-b5a2-878acfd29335.png#averageHue=%231e1e1e&clientId=u1b2351c9-0f42-4&from=paste&height=59&id=uc023038f&name=image.png&originHeight=59&originWidth=498&originalType=binary&ratio=1&rotation=0&showTitle=true&size=2633&status=done&style=none&taskId=ucae589f2-04bc-4644-899d-6fdbd17e620&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%89%8D%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&width=498 \"执行程序前，C段内容\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882830219-1912f93e-456b-47b1-b06a-32816e308e07.png#averageHue=%23171717&clientId=u1b2351c9-0f42-4&from=paste&height=95&id=ud9a53aa1&name=image.png&originHeight=95&originWidth=479&originalType=binary&ratio=1&rotation=0&showTitle=true&size=3576&status=done&style=none&taskId=udb82a728-cd51-436e-9481-a8a6f072f71&title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&width=479 \"执行程序后，C段内容\")\n<a name=\"azFBM\"></a>\n## assignment 6\n\n1. 编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的\n```\nassume cs:code\na segment\ndw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh\na ends\n\nb segment \ndw 0,0,0,0,0,0,0,0\nb ends\n\ncode segment \nstart:\nmov ax, a\nmov ds, ax\nmov ax, b \nmov ss, ax\nmov sp, 0010H\nmov bx, 0\nmov cx, 8\ns:\npush [bx]\nadd bx, 2\nloop s\n\nmov ax, 4c00H\nint 21H\n\ncode ends\n\nend start\n```\n\n2. 用debug跟踪程序，可以看到a段段地址： $076C$ 、 b段段地址：$076E$、code段段地址：$076F$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885232599-a5e6bf92-ae97-421b-ad5b-904f427aef76.png#averageHue=%230f0f0f&clientId=u1b2351c9-0f42-4&from=paste&height=296&id=ub52c7fd8&name=image.png&originHeight=296&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10267&status=done&style=none&taskId=ub78885e9-2d92-486e-abce-ac5186f563b&title=&width=590)\n\n3. 执行程序，查看b段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885271367-eddf0cc8-98aa-4fe8-a38f-a014ed5f8179.png#averageHue=%231b1b1b&clientId=u1b2351c9-0f42-4&from=paste&height=228&id=ud387c905&name=image.png&originHeight=228&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10970&status=done&style=none&taskId=u9df34674-6438-4f64-8810-2056308e5b5&title=&width=525)\n\n---\n\n<a name=\"O7BgM\"></a>\n# 实验6 实践课程中的程序\n<a name=\"dyxQS\"></a>\n## assignment 1\n\n1. 这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下\n```\nassume cs:codesg, ds:datasg, ss:stacksg\n\ndatasg segment \ndb 'ibm             '\ndb 'dec             '\ndb 'dos             '\ndb 'vax             '\ndatasg ends\n\nstacksg segment\ndw 0,0,0,0,0,0,0,0\nstacksg ends\n\ncodesg segment\nstart:\nmov ax, stacksg\nmov ss, ax\nmov sp, 10H\nmov ax, datasg\nmov ds, ax\nmov bx, 0\nmov cx, 4\ns0:\npush cx\nmov si, 0\nmov cx, 3\ns:\nmov al, [bx+si]\nand al, 11011111B\nmov [bx+si], al\ninc si\nloop s \n\npop cx\nadd bx, 10H\nloop s0\n\nmov ax, 4c00H\nint 21H\n\ncodesg ends\n\nend start\n```\n\n2. 跟踪程序，查看data段内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954476992-988989f0-7ba5-4132-8b53-011e5cfe1ce7.png#averageHue=%23111111&clientId=ue12bca8e-25be-4&from=paste&height=332&id=u6d512701&name=image.png&originHeight=332&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11651&status=done&style=none&taskId=uac27a62a-e7e2-4573-8364-30a015779f0&title=&width=619)\n\n3. 执行程序后，查看data段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954644257-b63d5af0-f266-4057-b1e1-c513e09c9298.png#averageHue=%23151515&clientId=ue12bca8e-25be-4&from=paste&height=114&id=u73878512&name=image.png&originHeight=114&originWidth=574&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4009&status=done&style=none&taskId=u92fc65de-f6f5-42c1-84b2-350c1e4d948&title=&width=574)\n<a name=\"pHbEJ\"></a>\n## assignment 2\n\n1. 编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突\n```\nassume cs:codesg, ds:datasg, ss:stacksg\n\nstacksg segment\ndw 0,0,0,0,0,0,0,0\nstacksg ends\n\ndatasg segment \ndb '1. display      '\ndb '2. brows        '\ndb '3. replace      '\ndb '4. modify       '\ndatasg ends\n\ncodesg segment\nstart:\nmov ax, stacksg\nmov ss, ax\nmov sp, 10H \nmov ax, datasg\nmov ds, ax\nmov bx, 0\nmov cx, 4\ns0:\npush cx\nmov cx, 4\nmov si, 0\ns: \nmov al, [bx+3+si]\nand al, 11011111B\nmov [bx+3+si], al\ninc si\nloop s\n\npop cx\nadd bx, 10H\nloop s0\n\nmov ax, 4c00H\nint 21H\n\ncodesg ends\n\nend start\n\n\n\n```\n\n2. 跟踪程序，查看data段内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955793129-198d15a6-56f1-4375-a4c1-fa6d84e6aa7c.png#averageHue=%23111111&clientId=ue12bca8e-25be-4&from=paste&height=311&id=u5ce4b731&name=image.png&originHeight=311&originWidth=623&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12680&status=done&style=none&taskId=u132e706b-1ed7-4582-becb-0f6cd930428&title=&width=623)\n\n3. 执行程序，查看data段内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955864652-707fd6d7-d65d-4be6-b3f9-bbcbbc27484b.png#averageHue=%23151515&clientId=ue12bca8e-25be-4&from=paste&height=110&id=ubb174b39&name=image.png&originHeight=110&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5260&status=done&style=none&taskId=u786ee51b-5382-4915-8eb1-9feeb54fdba&title=&width=618)\n\n---\n\n<a name=\"MJU1z\"></a>\n# 实验7 寻址方式在结构化数据访问中的应用\n\n1. 编写源程序，用`word ptr / byte ptr`指定内存单元大小主要应用在`div`指令或用于向内存写入立即数\n```\nassume cs:codesg\n\nstack segment\ndw 0,0,0,0,0,0,0,0\nstack ends\n\ndata segment\ndb '1975','1976', '1977', '1978', '1979', '1980', '1981', '1982','1983'\ndb '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992'\ndb '1993', '1994', '1995'\n\ndd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514\ndd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000\n\ndw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226\ndw 11542,14430,15257,17800\ndata ends\n\ntable segment\ndb 21 dup ('year summ ne ?? ')\ntable ends\n\ncodesg segment\nstart:\nmov ax, stack ;0776C\nmov ss, ax\nmov sp, 10H\nmov ax, data ; 076D\nmov es, ax\nmov ax, table ; 077b\nmov ds, ax\nmov bx,0\nmov si,0\nmov cx,21\n\nyear:\npush cx\nmov cx, 4\nmov di, 0\nchar:\nmov al, es:[si]\nmov [bx+di], al\ninc di\ninc si\nloop char\npop cx\nadd bx, 10H\nloop year\n\nmov cx, 21\nmov bx, 0\nincome:\npush cx\nmov cx, 2\nmov di, 0\ndwInt:\nmov ax, es:[si]\nmov [bx].5[di], ax\nadd si, 2\nadd di, 2\nloop dwInt\npop cx\nadd bx, 10H\nloop income\n\nmov cx, 21\nmov bx, 0\nstaff:\nmov ax, es:[si]\nmov [10+bx], ax\nadd si, 2;\nadd bx, 10H\nloop staff\n\nmov cx, 21\nmov bx, 0\naverage:\nmov dx, [bx+7]\nmov ax, [bx+5]\ndiv word ptr [bx+0AH]\nmov [bx+0Dh], ax\nadd bx, 10H\nloop average\n\nmov ax, 4C00H\nint 21H\ncodesg ends\nend start \n```\n\n2. 查看原始table段的内容\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054412418-905eb553-63b9-4352-8fd3-87d9c57ec955.png#averageHue=%231d1d1d&clientId=u59b02d03-003e-4&from=paste&height=312&id=ue1c1140e&name=image.png&originHeight=312&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19887&status=done&style=none&taskId=ue6fc1e9d-9b84-43c0-852e-a69d953b492&title=&width=640)\n\n3. 执行程序后，查看table段的内容，正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054465034-493bafb1-d935-4da9-b3d0-07b0bdd54911.png#averageHue=%231b1b1b&clientId=u59b02d03-003e-4&from=paste&height=378&id=u98d88789&name=image.png&originHeight=378&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21611&status=done&style=none&taskId=u95e0d8ba-0b80-4cd2-9a0a-a3aaec2f835&title=&width=630)\n<a name=\"wI3bu\"></a>\n# 实验8 分析一个奇怪的程序\n\n1. 程序从$start$入口处开始执行，一个`nop`指令占一个字节并表示No operation，此处用了两个`nop`指令的目的是在$s$处预留两个字节的空间，程序执行`mov cs:[di], ax`之后$s$处的两个字节被试图写入`jmp short s1`，接着程序向下执行`jmp short s`使得程序跳转回$s$处开始执行。\n2. `jmp short s1`到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从$s2$跳转到$s1$，即从$s2$处的jmp指令的下一指令`nop`$(076C:0022)$跳转到$s1$处的`mov ax, 0`$(076C:0018)$，因为`jmp short 标号`是依据位移进行转移的指令，而此处位移大小为$0022H-0018H =-10D(F6H)$，所以$s$处的`jmp short s`指令的机器码为`EBF6`（刚好占两个字节，因此可以被正确写入$s$处）\n3. 执行$s$处的跳转指令，使得$IP = IP+(-10)$,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为`mov ax, 4c00H`$(000AH-0010H=0000H)$，程序从此处开始向下执行，最终可以正确退出\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674306714709-54439679-a96b-496d-97b1-de0f2c3abf77.png#averageHue=%230d0d0d&clientId=u6f9c44da-f55a-4&from=paste&height=383&id=u78c30e80&name=image.png&originHeight=383&originWidth=595&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10505&status=done&style=none&taskId=uae9cedf9-248f-4122-b32a-b23020dad5f&title=&width=595)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674308784974-d476fbd5-6642-45a7-8e5a-a3db1e5ed646.png#averageHue=%230a0a0a&clientId=u6f9c44da-f55a-4&from=paste&height=150&id=ua98d7cca&name=image.png&originHeight=150&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3506&status=done&style=none&taskId=ufcfb45ef-5abd-4191-9c60-6ca3d7ac8c6&title=&width=640)\n<a name=\"lZyJr\"></a>\n# 实验9 根据材料编程\n\n1. 编写源程序：最开始我试图用`mov address，data`的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据`welcome to masm!`，利用寄存器$ax$作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据\n```\nassume cs:codesg\n\ndata segment\ndb 'welcome to masm!'\ndata ends\n\ncodesg segment\nstart: \nmov ax, data\nmov ds, ax\nmov ax, 0B800H\nmov es, ax\n\nmov bx, 0\nmov si, 1824\nmov cx, 10H\ns0:\nmov ah, 82H\nmov al, [bx]\nmov es:[si], ax\ninc bx\nadd si, 2\nloop s0\n\nmov bx, 0 \nmov si, 1984\nmov cx, 10H\ns1:\nmov ah, 0A4H\nmov al, [bx]\nmov es:[si], ax\ninc bx\nadd si, 2\nloop s1\n\nmov bx, 0 \nmov si, 2144\nmov cx, 10H\ns2:\nmov ah, 11110001B\nmov al, [bx]\nmov es:[si], ax\ninc bx\nadd si, 2\nloop s2\n\nmov ax, 4c00H\nint 21H\ncodesg ends\n\nend start\n```\n\n2. 最终效果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674447541217-19494cef-6da4-4fd3-b28c-6ad18c755471.png#averageHue=%23080808&clientId=u2be92af7-bf87-4&from=paste&height=400&id=u7d46ece7&name=image.png&originHeight=400&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8808&status=done&style=none&taskId=u5b2b0b44-a96d-458a-878e-8f9b74b9697&title=&width=640)\n\n<a name=\"zPzcC\"></a>\n# 实验10 编写子程序\n<a name=\"Z9mXL\"></a>\n## assignment 1\n\n1. 编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（**注意入栈顺序与出栈顺序相反**）\n```\nassume cs:code\ndata segment\ndb \"welcome to masm!\", 0\ndata ends\n\nstack segment\ndw 16 dup (0)\nstack ends\n\ncode segment\nstart:\nmov dh, 8\nmov dl, 3\nmov cl, 2\nmov ax, data\nmov ds, ax\nmov ax, stack\nmov sp, 20H\nmov si, 0\ncall show_str\n\nmov ax, 4C00H\nint 21H\n\nshow_str:\npush ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复\npush bx\npush cx\npush dx\npush es\npush si\n\nmov ax, 0B800H; 80×25彩色模式显示缓冲区\nmov es, ax\n\nmov al, 160 ; 设置指定打印位置\ninc dh ; 行数从0开始\nmul dh ; 8位乘法，结果存储在ax中\nmov bx, ax\nmov al, 2\nmul dl\nadd bx, ax\nmov ah, cl\n\nprint:\nmov cl, [si] ; 设置cx\nmov ch, 0\njcxz ok ;判断字符串是否结束\n\nmov al, cl ; 设置字符属性和值\nmov es:[bx],ax\ninc si\nadd bx, 2\njmp print\n\nok:\npop si\npop es\npop dx\npop cx\npop bx\npop ax\nret \n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1674959885930-a6c4181a-e6a1-44cb-9ec8-cc5013b1314e.png#averageHue=%23141414&clientId=ue48ee0fc-f4a6-4&from=paste&height=427&id=u8c981b1c&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12224&status=done&style=none&taskId=u3854a69e-62d2-4b34-89c5-98dd0c0fb70&title=&width=642)\n<a name=\"gCr3l\"></a>\n## assignment 2\n\n1. 编写源程序，利用除法溢出公式 \n\n                   $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$<br />该公式的基本思想是将可能发生除法溢出的32位除法$X/n$，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法<br />$(H/n)*65536 + (L/n)$<br />**商（32位）：**<br />高十六位为$int(H/2)*65536$,低十六为$int([rem(H/n)*65536+L]/n)$<br />**余数（16位）：**<br />$rem([rem(H/n)*65536+L]/n)$<br />（注：对这个公式的理解有限）\n```\nassume cs:code\n\nstack segment\ndw 16 dup (0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\nmov ax, 4240H\nmov dx, 000FH\nmov cx, 0AH\ncall divdw\n\nmov ax, 4C00H\nint 21H\n\ndivdw:\npush bx\n\nmov bx, ax ; 暂存L\nmov ax, dx ; H/N\nmov dx, 0\ndiv cx ; int(H/N)在ax中，rem(H/N)在dx中\n\npush ax ; 暂存int(H/N)，除数\n\nmov ax, bx; dx and ax constitute rem(H/N)*65535+L\ndiv cx ; ax store the result\nmov cx, dx\n\npop dx ; int(H/N)\n\npop bx\nret\n\n\n\ncode ends\nend start\n```\n\n2. 运行结果正确\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675050216892-a6c856a5-19e3-42a9-9dae-62052e8d077c.png#averageHue=%23191919&clientId=u68f84982-1dce-4&from=paste&height=427&id=u69ef2d14&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16724&status=done&style=none&taskId=u6de69850-12af-46ff-80ef-d1f8f4817f4&title=&width=642)\n<a name=\"wHNVn\"></a>\n## assignment 3\n\n1. 编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过\n```\nassume cs:code\n\ndata segment\ndb 10 dup(0)\ndata ends\n\nstack segment\ndw 16 dup(0)\nstack ends\n\ncode segment\nstart:\nmov ax, 12666\nmov bx, data\nmov ds, bx\nmov si, 0\nmov bx, stack\nmov ss, bx\nmov sp, 20H\ncall dtoc\n\nmov dh, 8\nmov dl, 3\nmov cl, 2\ncall show_str\n\nmov ax, 4C00H\nint 21H\n\ndtoc:\npush ax\npush bx\npush cx\npush dx\npush si\npush di\n\nmov dx, 0 ; 被除数高16位 置0\nmov bx, 10\nmov di, 0 ; 字符计数\n\ndivide:\nmov cx, ax \njcxz over\ninc di\ndiv bx ; 32位除法，商在ax，余数在dx\nadd dx, 30H\npush dx\nmov dx, 0\njmp divide\n\nover:\nmov cx, di\nmove: \npop bx\nmov [si], bl\ninc si\nloop move\n\npop di\npop si\npop dx\npop cx\npop bx\npop ax\nret\n\nshow_str:\npush ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复\npush bx\npush cx\npush dx\npush es\npush si\n\nmov ax, 0B800H; 80×25彩色模式显示缓冲区\nmov es, ax\n\nmov al, 160 ; 设置指定打印位置\ninc dh ; 行数从0开始\nmul dh ; 8位乘法，结果存储在ax中\nmov bx, ax\nmov dh, 0\nmov al, 2\nmul dl\nadd bx, ax\nmov ah, cl\n\nprint:\nmov cl, [si] ; 设置cx\nmov ch, 0\njcxz ok ;判断字符串是否结束\n\nmov al, cl ; 设置字符属性和值\nmov es:[bx],ax\ninc si\nadd bx, 2\njmp print\n\nok:\npop si\npop es\npop dx\npop cx\npop bx\npop ax\nret \n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070403817-35e5aa0f-3d0c-42ab-803a-9d7dbf5bcb8a.png#averageHue=%231f1f1e&clientId=u9270fba6-a6a8-4&from=paste&height=427&id=uc1ace679&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=16905&status=done&style=none&taskId=uf4805ca7-fbac-43eb-a257-f1c820ade31&title=%E6%AD%A3%E7%A1%AE%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%AE%B5&width=642 \"正确写入数据段\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070685747-6e72ffff-b062-418d-9d09-67596698a4ca.png#averageHue=%23141313&clientId=u9270fba6-a6a8-4&from=paste&height=427&id=ub539738e&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=12534&status=done&style=none&taskId=u448c5569-17ad-4eec-8879-9d56a9e0d67&title=%E6%AD%A3%E7%A1%AE%E6%89%93%E5%8D%B0&width=642 \"正确打印\")\n<a name=\"ww3wC\"></a>\n# 实验11 编写子程序\n\n1. 编写源程序：主要用到了`cmp`指令和条件转移指令组合形成的if逻辑\n```\nassume cs:codesg\ndatasg segment\ndb \"Beginner's All-purpose Symbolic Instruction Code.\",0\ndatasg ends\n\ncodesg segment\nbegin:\nmov ax, datasg\nmov ds, ax\nmov si, 0\ncall letterc\n\nmov ax, 4C00H\nint 21H\n\nletterc:\npush ax\npush cx\n\nCapital:\nmov al, [si]\nmov cl, al\nmov ch, 0\njcxz OK\ncmp al, 97\njb NO\ncmp al, 122\nja NO\nand al, 11011111B\nmov [si], al\t\n\nNO:\ninc si\njmp short Capital\n\nOK:\npop cx\npop ax\nret\n\ncodesg ends\nend begin\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142887049-1e6b7958-8779-4745-81f5-c6a536a232ca.png#averageHue=%231d1d1d&clientId=u14a9d0ea-1971-4&from=paste&height=427&id=u9451414e&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=18343&status=done&style=none&taskId=u733f3e2b-82d2-436e-a8de-95b8faa1f07&title=%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81&width=642 \"初始状态\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142878774-286c5ae3-e961-424a-96db-dae987c9a153.png#averageHue=%23212121&clientId=u14a9d0ea-1971-4&from=paste&height=427&id=ub5c49ec4&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=19861&status=done&style=none&taskId=u7a2a2568-c507-4078-a32b-b75eef2ec62&title=%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99&width=642 \"全部大写\")\n<a name=\"bk4z5\"></a>\n# 实验12 编写0号中断的处理程序\n\n1. 编写源程序\n\n总体来说就3个任务：\n\n- 编写中断处理程序 \n- 复制中断处理程序至内存空闲区域($0000:0200H\\to0000:02FFH$)  \n- 修改中断向量表（中断处理程序地址入口表）\n\n注意在用`jcxz`条件转移指令时，要`jmp short`回程序开头\n```\nassume cs:code\n\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset do0 ; 076C:0028\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset do0end- offset do0; 0034H\ncld\nrep movsb ; 复制程序到0:200\n\nmov word ptr es:[0], 0200H\nmov word ptr es:[0+2], 0 ; 修改中断向量表\n\nmov ax, 4C00H\nint 21H\n\ndo0:\njmp short do0start\ndb \"divide error\",0 \n\ndo0start:\nmov ax, 0B800H\nmov es, ax\nmov di, 160*12+34*2\n\nmov ax, cs\nmov ds, ax\nmov si, 202H\n\nprint:\nmov cL, [si]\nmov ch, 0\njcxz ok\nmov ah, 04h ;red\nmov al, cl\nmov es:[di], ax\ninc si\nadd di, 2 \njmp short print\n\nok:\nmov ax, 4C00H\nint 21H\n\ndo0end: ;005C\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675159533550-89caf027-f6da-4345-aa8c-e03159df600e.png#averageHue=%23141414&clientId=u2ec176e2-9874-4&from=paste&height=427&id=u6679d84b&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12440&status=done&style=none&taskId=u7d87f433-7092-4f23-a3d6-b1339bf6fe9&title=&width=642)\n<a name=\"YSdgF\"></a>\n# 实验13 编写、应用中断例程\n<a name=\"HHw6N\"></a>\n## assignment 1\n\n1. 编写源程序：与lab10-1的show_str基本一致，只需将`call-ret`更改为 `int 7cH - iret`\n```\nassume cs:code\n\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset print\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset printed - offset print\ncld\nrep  movsb\n\nmov word ptr es:[7cH*4], 0200H\nmov word ptr es:[7cH*4+2], 0 \n\nmov ax, 4C00H\nint 21H\n\nprint:\npush bx\npush cx\npush es\npush si\npush ax\npush dx\n\nmov ax, 0B800H\nmov es, ax\n\nmov al, 160\ninc dh\nmul dh ; 160*(10+1) in ax\nmov bx, ax\nmov al, 2\nmul dl ; 10*2 in ax\nadd bx, ax\nmov ah, cl\n\nstPrint:\nmov ch, 0\nmov cl, [si]\njcxz ok\n\nmov al, cl\nmov es:[bx], ax\nadd bx, 2\ninc si\njmp short stPrint\n\nok:\npop dx\npop ax\npop si\npop es\npop cx\npop bx\niret\n\nprinted:\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675224733068-a783d5cd-5d35-46b5-8032-3c8938e8347a.png#averageHue=%23131313&clientId=u8a54de4a-c425-4&from=paste&height=427&id=u9672685d&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12092&status=done&style=none&taskId=u4599fb35-92fc-4ea1-b9cb-e60668d8629&title=&width=642)\n<a name=\"LKaNX\"></a>\n## assignment 2\n\n1. 编写源程序\n\n用中断例程实现loop指令，主要需要解决三个问题\n\n- 怎么取得标号$S$的段地址和偏移地址？\n\n有一对段地址$CS$和偏移地址$IP$在中断过程时被压入栈，标号的段地址就是该CS，标号\t       的偏移地址可由该IP加上转移地址(`offset s - offset se`)得到\n\n- 得到$S$的段地址和偏移地址后，如何设置$CS:IP$\n\n用`iret`指令：`pop IP , pop CS ,  popf`\n```\nassume cs:code\n\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset lp\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset lped - offset lp\ncld\nrep  movsb\n\nmov word ptr es:[7cH*4], 0200H\nmov word ptr es:[7cH*4+2], 0 \n\nmov ax, 4C00H\nint 21H\n\nlp:\ndec cx\njcxz lpret\npush bp\nmov bp, sp\nadd [bp+2], bx\nlpret:\npop bp\niret\n\nlped:\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675237825483-f1ed3d6d-00cc-453b-91b3-757823355468.png#averageHue=%23171515&clientId=ub529a018-e1a0-4&from=paste&height=427&id=u272d8fd4&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12787&status=done&style=none&taskId=u38f1e876-6c89-499b-b704-a23609bf566&title=&width=642)\n<a name=\"TCCAl\"></a>\n## assignment 3\n```\nassume cs:code\ncode segment\ns1: db 'Good,better,best,','$'\ns2: db 'Never let it rest,','$' \ns3: db 'Till good is better,','$'\ns4: db 'And better,best.', '$'\ns: dw offset s1, offset s2, offset s3, offset s4 \nrow: db 2,4,6,8\n\nstart:\nmov ax, cs \nmov ds, ax\nmov bx, offset s\nmov si, offset row\nmov cx, 4\nok:\nmov bh, 0 \nmov dh, [si]\nmov dl, 0\nmov ah, 2 ; BIOS中断例程--设置光标\nint 10h \n\nmov dx, [bx]                                           \nmov ah, 9 ; DOS中断例程--打印字符串\nint 21h\ninc si\nadd bx, 2\nloop ok\n\nmov ax, 4C00H; DOS中断例程--程序返回，返回值在al\nint 21H\ncode ends\nend start\n```\n<a name=\"zGspx\"></a>\n# 实验14 访问 CMOS RAM\n\n1. 编写源程序\n```\nassume cs:code\n\nstack segment\ndw 16 dup (0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\nmov ax, 0B800H\nmov ds, ax\n\nmov al, 9\nmov bx, 160*12+36*2\ncall GetAscill\nmov byte ptr [bx+4], '/'\n\nmov al, 8\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], '/'\n\nmov al, 7\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], ' '\n\nmov al, 4\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], ':'\n\nmov al, 2\nadd bx, 6\ncall GetAscill\nmov byte ptr [bx+4], ':'\n\nmov al, 0\nadd bx, 6\ncall GetAscill\n\nmov ax, 4C00H\nint 21H\n\nGetAscill:\npush ax\npush bx\npush cx\npush dx\n\nout 70H, al\nin al, 71H\n\nmov ah, al\nmov cl, 4\nshr ah, cl\nand al, 00001111B\n\nadd ah, 30H\nadd al, 30H\n\nmov dx, 0B800H\nmov es, dx\nmov es:[bx], ah \nmov byte ptr es:[bx+1], 02H ; green\nmov es:[bx+2], al\nmov byte ptr es:[bx+3], 02H\n\npop dx\npop cx\npop bx\npop ax\nret\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675253920788-8fc4fee5-abeb-4e49-93bf-97e3873b6599.png#averageHue=%23141413&clientId=uf0bf1a62-8c66-4&from=paste&height=388&id=u067d841f&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11685&status=done&style=none&taskId=u21f4afac-9bb2-4466-b21a-1a578f58efb&title=&width=583.6363509863864)\n<a name=\"yTwL0\"></a>\n# 实验15 安装新的int 9 中断例程\n<a name=\"TIrMX\"></a>\n## 前置练习1\n在屏幕中间依次显示$a\\to z$,按Esc键后改变与颜色\n\n1. 编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把`call dword ptr ds:[0]`写成了`call word ptr ds:[0]`，导致整个系统没有正确的int 9中断例程，因此出现了错误。\n```\nassume cs:code\n\nstack segment\ndb 64 dup(0)\nstack ends\n\ndata segment\ndw 0,0\ndata ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 40H\nmov ax, data\nmov ds, ax\n\nmov ax, 0\nmov es, ax\n\npush es:[9*4]\npop ds:[0]\npush es:[9*4+2]\npop ds:[2] ; 保存原int 9中断例程的入口地址\n\ncli\nmov word ptr es:[9*4], offset int9\nmov es:[9*4+2], cs;设置新的入口地址\nsti\n\n\nmov ax, 0B800H\nmov es,ax\nmov dh, 'a'\ns:\nmov es:[160*12+40*2], dh\ncall delay\ninc dh\ncmp dh, 'z'\njna s ; 依次打印a~z\n\n\nmov ax, 0 \nmov es, ax\n\ncli\npush ds:[0]\npop es:[9*4]\npush ds:[2]\npop es:[9*4+2] ;恢复原int 9中断例程的入口地址\nsti\n\n\nmov ax, 4C00h\nint 21H\n\ndelay:\npush ax\npush dx\nmov ax, 0\nmov dx, 10H\nse:\nsub ax, 1 ; 不能用dec\nsbb dx, 0\ncmp ax, 0\njne se\ncmp dx, 0\njne se\n\npop dx\npop ax\nret ; 延时\n\nint9:\npush ax\npush es\nin al, 60H\n\npushf\ncall dword ptr ds:[0]\n\ncmp al, 01H\njne int9ret\nmov ax, 0B800H\nmov es, ax\ninc byte ptr es:[160*12+40*2+1] ; 修改字符属性\n\nint9ret:\npop es\npop ax\niret\n\ncode ends\nend start\n\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319548168-77f7b5a6-54bb-4526-b234-adb0e561004e.png#averageHue=%237ab44c&clientId=u17647ab4-03d9-4&from=paste&height=388&id=u49a1ed0a&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13571&status=done&style=none&taskId=u61859af5-760b-45d0-8b8d-c62aa3a3245&title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B21&width=583.6363509863864 \"按Esc改变颜色1\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319563355-013b242f-ab37-4a8f-a956-6222d6e1847c.png#averageHue=%238dd756&clientId=u17647ab4-03d9-4&from=paste&height=388&id=u9a049927&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13830&status=done&style=none&taskId=u52c59e7d-a185-4177-8537-a05965e054e&title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B22&width=583.6363509863864 \"按Esc改变颜色2\")\n<a name=\"vlBjq\"></a>\n## 前置练习2\n在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理\n\n1. 编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在$0:0200 \\to 0:0203$,可在新int 9中断例程中通过`cs:[200H]`访问\n```\nassume cs:code, ss:stack\n\nstack segment\ndb 32 dup(0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\n\nmov ax, 0\nmov es, ax\nmov di, 0204H\nmov ax, cs\nmov ds, ax\nmov si, offset int9\n\nmov cx, offset int9ed - offset int9\ncld\nrep movsb; 安装\n\npush es:[9*4]\npop es:[200H]\npush es:[9*4+2]\npop es:[202H] ; 保存原int 9入口地址\n\ncli\nmov word ptr es:[9*4], 204H\nmov word ptr es:[9*4+2], 0 ; 修改中断向量表\nsti\n\nmov ax, 4C00H\nint 21H\n\nint9:\npush ax\npush cx\npush es\npush di\n\nin al, 60H\n\npushf\ncall dword ptr cs:[200H] ; 调用原int 9\n\ncmp al, 3BH\njne int9ret\n\nmov ax, 0B800H\nmov es, ax\nmov di, 1\nmov cx, 2000\ns:\ninc byte ptr es:[di]\nadd di, 2\nloop s\n\nint9ret:\npop di\npop es\npop cx\npop ax\niret\n\n\nint9ed:\nnop\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322759364-2785ad21-17c7-4499-b1a3-fe6726975b02.png#averageHue=%230d0d0d&clientId=ud2f6d655-0b50-4&from=paste&height=388&id=u4340ef70&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=12813&status=done&style=none&taskId=uc1c9e4ff-ae09-465d-a787-aba159b8b98&title=%E6%8C%89%E4%B8%8BF1%201&width=583.6363509863864 \"按下F1 1\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322817620-9b94c323-5bcb-4465-ba63-7a2721ba4d46.png#averageHue=%23aeaeae&clientId=ud2f6d655-0b50-4&from=paste&height=388&id=u019e66f9&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8862&status=done&style=none&taskId=ue0c4ae51-d75f-4e13-8d7c-a26ee51e20f&title=%E6%8C%89%E4%B8%8BF1%202&width=583.6363509863864 \"按下F1 2\")\n<a name=\"XyIu0\"></a>\n## assignment 1\n\n1. 编写源程序\n\n与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码`cmp aL, 1EH+80H`\n```\nassume cs:code, ss:stack\n\nstack segment\ndb 32 dup(0)\nstack ends\n\ncode segment\nstart:\nmov ax, stack\nmov ss, ax\nmov sp, 20H\n\nmov ax, 0\nmov es, ax\nmov di, 0204H\nmov ax, cs\nmov ds, ax\nmov si, offset int9\n\nmov cx, offset int9ed - offset int9\ncld\nrep movsb; 安装\n\npush es:[9*4]\npop es:[200H]\npush es:[9*4+2]\npop es:[202H] ; 保存原int 9入口地址\n\ncli\nmov word ptr es:[9*4], 204H\nmov word ptr es:[9*4+2], 0 ; 修改中断向量表\nsti\n\nmov ax, 4C00H\nint 21H\n\nint9:\npush ax\npush cx\npush es\npush di\n\nin aL,60h\n\npushf\ncall dword ptr cs:[200H]\n\ncmp aL, 1EH+80H\njne int9ret\n\nmov cx, 2000\nmov ax, 0B800H\nmov es, ax\nmov di, 0\ns:\nmov byte ptr es:[di], 'A'\nmov byte ptr es:[di+1], 02H\nadd di, 2\nloop s\n\nint9ret:\npop di\npop es\npop cx\npop ax\niret\n\nint9ed:\nnop\n\ncode ends\nend start\n\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675329053483-60588212-d9b5-4cef-acf7-06c70f65db5f.png#averageHue=%23141313&clientId=ud2f6d655-0b50-4&from=paste&height=388&id=u7a90e8bd&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=7755&status=done&style=none&taskId=u3c74959a-2b05-4756-8089-500ac2f8893&title=%E6%8C%89%E4%B8%8BA%E5%90%8E%E6%9D%BE%E5%BC%80&width=583.6363509863864 \"按下A后松开\")\n<a name=\"YodIM\"></a>\n# 实验16 编写包含多个功能子程序的中断例程\n\n1. 编写源程序\n\n注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H\n```\nassume cs:code\ncode segment\nstart:\nmov ax, cs\nmov ds, ax\nmov si, offset int7ch\nmov ax, 0\nmov es, ax\nmov di, 0200H\n\nmov cx, offset int7ched - offset int7ch\ncld\nrep  movsb\n\nmov word ptr es:[7cH*4], 0200H\nmov word ptr es:[7cH*4+2], 0 \n\nmov ax, 4C00H\nint 21H\n\nint7ch:\njmp short int7chStart\ntable dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200H\n\nint7chStart:\npush ax\npush bx\ncmp ah, 3\nja int7chRet\nmov bl, ah\nmov bh, 0\nadd bx, bx\ncall word ptr cs:(table-int7ch+200H)[bx]\n\nint7chRet:\npop bx\npop ax\niret\n\nSub1:\npush ax\npush bx\npush cx\npush ds\nmov ax, 0B800H\nmov ds, ax\nmov cx, 2000\nmov bx, 0\ns1:\nmov byte ptr [bx], ' '\nadd bx, 2\nloop s1\npop ds\npop cx\npop bx\npop ax\nret\n\nSub2:\npush ax\npush bx\npush cx\npush ds\nmov bx, 0B800H\nmov ds, bx\nmov cx, 2000\nmov bx, 1\ns2:\nand byte ptr [bx], 11111000B ; 只设置最后3位\nor byte ptr [bx], al\nadd bx, 2\nloop s2\npop ds\npop cx\npop bx\npop ax\nret\n\nSub3:\npush ax\npush bx\npush cx\npush ds\nmov bx, 0B800H\nmov ds, bx\nmov cl, 4\nshl al, cl\nmov cx, 2000\nmov bx, 1\ns3:\nand byte ptr [bx], 10001111B\nor [bx], al\nadd bx, 2\nloop s3\npop ds\npop cx\npop bx\npop ax\nret\n\nSub4:\npush ax\npush bx\npush cx\npush ds\npush es\npush si\npush di\nmov bx, 08B00H\nmov es, bx\nmov ds, bx\nmov si, 160\nmov di, 0\ncld\nmov cx, 24\n\ns4:\npush cx\nmov cx, 160\nrep movsb\npop cx\nloop s4\n\nmov cx, 80\nmov si, 0\ns41:\nmov byte ptr [160*24+si], ' '\nadd si ,2\nloop s41\npop di\npop si\npop es\npop ds\npop cx\npop bx\npop ax\nret\n\nint7ched:\nnop\n\ncode ends\nend start\n```\n```\nassume cs:code\n\ncode segment\nstart:\nmov ah,1 ; 0 2 3\nmov al,2\nint 7CH\n\nmov ax, 4C00H\nint 21H\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411618416-c6c100a2-f4d1-4bc9-b3e6-22f83fcdcaee.png#averageHue=%230d0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u97049213&name=image.png&originHeight=427&originWidth=620&originalType=binary&ratio=1&rotation=0&showTitle=true&size=5698&status=done&style=none&taskId=udfd4d7d0-2546-4521-8884-82d74fe5421&title=%E5%8A%9F%E8%83%BD1%EF%BC%9A%E6%B8%85%E5%B1%8F&width=620 \"功能1：清屏\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411466691-92faf4b3-fbd7-4859-b68b-e403f87d23e1.png#averageHue=%230e0e0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u0af61a75&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=11776&status=done&style=none&taskId=ud7c332b2-9214-4185-917e-392d79cda17&title=%E5%8A%9F%E8%83%BD2%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%89%8D%E6%99%AF%E8%89%B2&width=642 \"功能2：设置前景色\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411696534-79bed444-6b2a-4a77-ad72-027fb2081a4b.png#averageHue=%2300a900&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ue6689a35&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=11354&status=done&style=none&taskId=u07994587-f0a4-4e4c-b31e-52a54f59cd3&title=%E5%8A%9F%E8%83%BD3%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E8%89%B2&width=642 \"功能3：设置背景色\")\n<a name=\"IRx7s\"></a>\n# 实验17 编写包含多个功能子程序的中断例程\n第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了\n<a name=\"upigZ\"></a>\n## 练习17-1\n接受用户的键盘输入，输入\"r\"，\"g\",“b”分别将屏幕上的字符设置为红色，绿色，蓝色\n\n1. 编写源程序\n\n用功能号为0的int 16H中断例程读取键盘输入即可\n```\nassume cs:code\n\ncode segment\nstart:\n\nshow:\npush ax\npush es\npush di\n\nmov ah, 0\nint 16H\n\nmov bl, 1\ncmp al,'b'\nje showst\nshl bl, 1\ncmp al, 'g'\nje showst\nshl bl, 1\ncmp al, 'r'\nje showst\njmp short FRet\n\nshowst:\nmov ax, 0B800H\nmov es, ax\nmov di, 1\nmov cx, 2000\ns:\nand byte ptr es:[di], 11111000B\nor es:[di], bl\nadd di, 2\nloop s\n\nFRet:\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n\n2. 运行结果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431818731-db0edf92-bc54-4bfc-a35f-613c796dddda.png#averageHue=%230f0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u2f889938&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8416&status=done&style=none&taskId=u3c7affc7-f57c-470f-9cab-1a94bcb3c74&title=r-red&width=642 \"r-red\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431840911-15621108-ffb6-42ce-94ab-603c36fe9540.png#averageHue=%230d0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u1bb9ce94&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8174&status=done&style=none&taskId=u26c95d33-ee9d-414a-9861-7aa91427bc6&title=g-green&width=642 \"g-green\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431855013-727c9bbb-b9bf-43a5-9ca6-ea80957dfa92.png#averageHue=%230d0d0d&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ucb1b0f24&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8133&status=done&style=none&taskId=ub45cc602-bef7-4fba-9ec7-3d4b52f4485&title=b-blue&width=642 \"b-blue\")\n<a name=\"Wyllk\"></a>\n# Other\n<a name=\"QMCD1\"></a>\n## 1. 理解assume伪指令的作用\n```\nassume cs:code, ds:data\ndata segment\na db 1,2,3,4,5,6,7,8\nb dw 0\ndata ends\n\ncode segment\nstart:\nmov ax, data\nmov ds, ax\n\nmov si, 0\nmov cx, 8\n\ns:\nmov ah, 0\nmov al, a[si]\nadd b, ax\ninc si\nloop s\n\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n\n1. `assume ds:data ss:stack`\n- assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器$DS、SS$中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:`mov ax, data ``mov ds, ax`\n- assume是伪指令，用于指示编译器将$DS、SS$分别与data段和stack段关联。①关联是什么意思呢？就是**在编译时默认data段中的数据标号a、b的段地址在**$DS$**中**，因此如果要正确访问到a、b的内容，必须用指令将data填入$DS$中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此`mov ax, data`在编译器看来是`mov ax, data段段地址`，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax\n\n如果在程序中省略`assume ds:data`，则会出现_不能用段寄存器寻址_的错误<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675343108877-68cf68d3-97ef-4ecb-8b4f-6da330149c94.png#averageHue=%23161616&clientId=u3f46bb08-d532-4&from=paste&height=388&id=uffd0ec43&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13264&status=done&style=none&taskId=ud9fb02f3-e117-4559-bfe1-1659d6727ee&title=&width=583.6363509863864)\n\n2. `assume cs:codesg`\n\n将$CS$与代码段关联，在程序加载时将代码段(codesg)的段地址放入$CS$中. 如果去掉该语句，则程序编译不通过，因为$CS$的值不确定<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675341791119-4c9029f0-b9e3-4e2f-b1b9-aa5d02685f8f.png#averageHue=%230d0d0d&clientId=u3f46bb08-d532-4&from=paste&height=276&id=u952199f2&name=image.png&originHeight=304&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9905&status=done&style=none&taskId=ud6cc6c48-9ce9-4df5-a654-02e53729a4d&title=&width=581.8181692076126)\n<a name=\"wwfwW\"></a>\n## 2. 理解数据标号\n\n1. 数据标号与地址标号的不同\n\n地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）\n```\nassume cs:code, es:data\ndata segment\na db 1,2,3,4,5,6,7,8\nb dw 0\ndata ends\n\ncode segment\nstart:\nmov ax, data\nmov es, ax\n\nmov si, 0\nmov cx, 8\n\ns:\nmov ah, 0\nmov al, a[si]\nadd b, ax\ninc si\nloop s\n\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n这里的a和b分别指代了\n\n- **地址为**`**seg data:0**`**, 长度为byte的字节单元**\n- **地址为**`**seg data:8**`**, 长度为word的字单元**\n2. 如何用数据标号以简洁形式访问内存中的数据\n\n在上一个程序中，我们用`mov al, a[si]` `add b, ax`访问了data段的内容，在编译器看来，这两条语句是这样的: `mov al, es:0[si]``add es:[8], ax`<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409971871-70ff728a-fa74-48ac-a742-be8ec319d677.png#averageHue=%23191919&clientId=uaa2840e8-10be-4&from=paste&height=427&id=u6e4d3ff6&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14859&status=done&style=none&taskId=ua1726f99-29ec-46f7-ac48-ad448e15a63&title=&width=642)<br />我们现在用更熟悉的`mov al, [si+a]` `add b[0], ax`形式，从编译器角度来看，这两种形式没有区别<br />这说明了在指令中**a等价于**`**byte ptr [0]**`**，b等价于**`**word ptr [8]**`（仅含偏移地址信息，默认段地址在es中，因为`assume es:data`）<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675410379440-d032239f-bb7d-480f-a45d-f96f7d064cd3.png#averageHue=%231a1919&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ubbac8493&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15290&status=done&style=none&taskId=uce443a00-0b21-4ac2-89ac-bb7e70f3432&title=&width=642)\n\n3. 将标号当作数据定义\n```\nassume cs:code, ds:data\ndata segment\na db 1,2,3,4,5,6,7,8\nb dw 0\nc dw a, b\ndata ends\n\ncode segment\nstart:\nmov ax, data\nmov ds, ax\n\nmov dx, 2\nmov dx, c\nmov ax, c[1]\n\nmov ax, 4C00H\nint 21H\n\ncode ends\nend start\n```\n`c dw a, b`将数据标号当作数据定义，c指代地址为`seg data:000A`的字单元，**该字单元的内容是a的偏移地址**$0000$，下面是验证<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409382345-20e1a2f2-8973-4150-992a-2a8acb141fa9.png#averageHue=%23191919&clientId=uaa2840e8-10be-4&from=paste&height=427&id=ud990b41d&name=image.png&originHeight=427&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15496&status=done&style=none&taskId=u9d64f540-f9d7-4f4d-a179-67094b0601b&title=&width=642)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409496753-347acc0d-300d-4502-b228-e202ee4504a4.png#averageHue=%23101010&clientId=uaa2840e8-10be-4&from=paste&height=400&id=u97a8ca97&name=image.png&originHeight=400&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12100&status=done&style=none&taskId=u65363c06-9a66-4677-9782-717ab71b1b6&title=&width=640)\n\n","slug":"assembly","published":1,"updated":"2023-03-13T03:56:39.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfmf6v9n00031gva2cr781jt","content":"<p><meta name=\"referrer\" content=\"no-referrer\"><br><a name=\"MTE7s\"></a></p>\n<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><p>前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的attack lab完成了</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><span id=\"more\"></span></h2><p><a name=\"PhqOH\"></a></p>\n<h1 id=\"实验1-查看CPU和内存，用机器指令和汇编指令编程\"><a href=\"#实验1-查看CPU和内存，用机器指令和汇编指令编程\" class=\"headerlink\" title=\"实验1 查看CPU和内存，用机器指令和汇编指令编程\"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h1><p><a name=\"xymUo\"></a></p>\n<h2 id=\"debug环境搭建：参考此文\"><a href=\"#debug环境搭建：参考此文\" class=\"headerlink\" title=\"debug环境搭建：参考此文\"></a>debug环境搭建：<a href=\"https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506\">参考此文</a></h2><p><a name=\"UrdzB\"></a></p>\n<h2 id=\"assignment-1\"><a href=\"#assignment-1\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>用A命令向内存中写入汇编指令，用U命令查看</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249473372-3a80b2ab-d9e2-483c-ac41-140d30fdd765.png#averageHue=%23161616&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=248&amp;id=ub963f2d1&amp;name=image.png&amp;originHeight=245&amp;originWidth=374&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6659&amp;status=done&amp;style=none&amp;taskId=u0fa9efb8-dccf-4ce1-b3ea-8d79929c540&amp;title=&amp;width=378\" alt=\"image.png\"></p>\n<ol>\n<li>用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249669344-d36231e5-8310-46ba-a3c6-155e2601ff58.png#averageHue=%230e0e0e&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=309&amp;id=udc060390&amp;name=image.png&amp;originHeight=309&amp;originWidth=608&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7838&amp;status=done&amp;style=none&amp;taskId=udc51570f-ded8-4f72-a2f5-ee442502176&amp;title=&amp;width=608\" alt=\"image.png\"><br><a name=\"rTW1r\"></a></p>\n<h2 id=\"assignment-2\"><a href=\"#assignment-2\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li>写入并查看指令</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250172971-61fbb876-feda-4ca9-b81d-e558cc0e5a6a.png#averageHue=%23151515&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=174&amp;id=u55f6e2fe&amp;name=image.png&amp;originHeight=174&amp;originWidth=376&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4324&amp;status=done&amp;style=none&amp;taskId=u9c9ba619-9a5c-4e5c-9e9d-45d5a6ea724&amp;title=&amp;width=376\" alt=\"image.png\"></p>\n<ol>\n<li>修改_CS:IP_指向</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250237721-ec3e62f5-f6bc-4890-8f25-b62f6d89e60e.png#averageHue=%230c0c0c&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=228&amp;id=u87c23aee&amp;name=image.png&amp;originHeight=228&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7409&amp;status=done&amp;style=none&amp;taskId=u0c70f1dc-bfd2-4472-a4d5-84a3fe97214&amp;title=&amp;width=642\" alt=\"image.png\"></p>\n<ol>\n<li>执行指令，计算$2^8$，结果为 $AX = 0100H$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250558182-3582fd8d-9783-421c-9731-0d83ae5c81a8.png#averageHue=%23121212&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=72&amp;id=u92a48cc6&amp;name=image.png&amp;originHeight=72&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2934&amp;status=done&amp;style=none&amp;taskId=ud124b271-ce25-43f5-aabf-1f9dd478c19&amp;title=&amp;width=583\" alt=\"image.png\"><br><a name=\"QAZ3Z\"></a></p>\n<h2 id=\"assignment-3\"><a href=\"#assignment-3\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li>用D命令查找，最终在$FFFF5H \\to FFFFCH（FFFF:0005 \\to FFFF:000C）$发现$dd/mm/yy$字样的生产日期</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251622812-ca79ef23-5a2a-46b2-ba9f-326aa9d3bc54.png#averageHue=%23161616&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=68&amp;id=ud8481a70&amp;name=image.png&amp;originHeight=68&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3411&amp;status=done&amp;style=none&amp;taskId=u26b9075a-3732-4bca-831f-f7252d9a335&amp;title=&amp;width=630\" alt=\"image.png\"></p>\n<ol>\n<li>尝试用E命令修改，该操作失效，因为这是ROM</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251941938-25cdf39e-5c26-49a3-81da-f108dff28da7.png#averageHue=%230f0f0f&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=120&amp;id=u23687460&amp;name=image.png&amp;originHeight=120&amp;originWidth=632&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4133&amp;status=done&amp;style=none&amp;taskId=uca81322b-a794-4e03-b596-0d7a694a021&amp;title=&amp;width=632\" alt=\"image.png\"><br><a name=\"CHS7t\"></a></p>\n<h2 id=\"assignment-4\"><a href=\"#assignment-4\" class=\"headerlink\" title=\"assignment 4\"></a>assignment 4</h2><p>1.$A0000H \\to BFFFFH$对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253290191-823908a7-61e0-4e4d-ac20-66184b8a4509.png#averageHue=%23141414&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=24&amp;id=udb4b1014&amp;name=image.png&amp;originHeight=24&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=646&amp;status=done&amp;style=none&amp;taskId=uc1f68660-8c22-4e6b-81ab-8168f9d217e&amp;title=&amp;width=316\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253301915-ead25a09-d4a2-48f2-ba25-7bb4b7279d64.png#averageHue=%230000aa&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=46&amp;id=u1f906edf&amp;name=image.png&amp;originHeight=46&amp;originWidth=489&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1808&amp;status=done&amp;style=none&amp;taskId=u8980a613-e82f-4ceb-a518-1e33c095648&amp;title=&amp;width=489\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"hcb7h\"></a></p>\n<h1 id=\"实验2-用机器指令和汇编指令编程\"><a href=\"#实验2-用机器指令和汇编指令编程\" class=\"headerlink\" title=\"实验2 用机器指令和汇编指令编程\"></a>实验2 用机器指令和汇编指令编程</h1><p><a name=\"vDc8z\"></a></p>\n<h2 id=\"assignment-1-1\"><a href=\"#assignment-1-1\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>用A指令向内存中写入汇编指令，用U指令查看</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596808599-b129a717-4d20-42a3-8823-64dc726440e3.png#averageHue=%23151515&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=236&amp;id=uc9b341b4&amp;name=image.png&amp;originHeight=236&amp;originWidth=374&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6210&amp;status=done&amp;style=none&amp;taskId=uf45debe0-8185-465e-b3c1-03874bac6c7&amp;title=&amp;width=374\" alt=\"image.png\"></p>\n<ol>\n<li>修改CS:IP使其指向代码段</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596896692-f6335ebe-e9b7-44cf-9a38-d686dde7d140.png#averageHue=%230a0a0a&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=162&amp;id=u325eac60&amp;name=image.png&amp;originHeight=162&amp;originWidth=577&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4064&amp;status=done&amp;style=none&amp;taskId=uaa5719c7-c665-4f9e-baa5-b5de2b24fc8&amp;title=&amp;width=577\" alt=\"image.png\">、</p>\n<ol>\n<li>t命令逐步执行指令后查看AX、BX、SP寄存器内容</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673597028389-791ccf84-0268-4f23-976f-53e6ecd97b36.png#averageHue=%23121212&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=374&amp;id=ueb563e3c&amp;name=image.png&amp;originHeight=374&amp;originWidth=635&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15302&amp;status=done&amp;style=none&amp;taskId=u24406e7c-e085-4926-bf36-d7ff7eeb06a&amp;title=&amp;width=635\" alt=\"image.png\"><br><a name=\"NB9fg\"></a></p>\n<h2 id=\"assignment-2-1\"><a href=\"#assignment-2-1\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><p>在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）</p>\n<hr>\n<p><a name=\"jpe3I\"></a></p>\n<h1 id=\"实验3-编程、编译、链接、跟踪\"><a href=\"#实验3-编程、编译、链接、跟踪\" class=\"headerlink\" title=\"实验3 编程、编译、链接、跟踪\"></a>实验3 编程、编译、链接、跟踪</h1><p><a name=\"QMUAH\"></a></p>\n<h2 id=\"assignment-1-2\"><a href=\"#assignment-1-2\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>编译链接生成可执行文件</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673681789903-cb9f13be-b044-4c3f-be1d-8fa401195306.png#averageHue=%230b0b0b&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=328&amp;id=ufc540080&amp;name=image.png&amp;originHeight=328&amp;originWidth=524&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8289&amp;status=done&amp;style=none&amp;taskId=uaf6acc9d-3a30-400a-b361-0bea1d87366&amp;title=&amp;width=524\" alt=\"image.png\"><br><a name=\"bm7kI\"></a></p>\n<h2 id=\"assignment-2-2\"><a href=\"#assignment-2-2\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li>debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为$DS=075C$，则PSP的地址为$075C:0$，程序的地址为$076C:0\\;(075C+10:0)$,$CS:IP = 076C:0000$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682350829-98451696-0d75-4414-87c5-b527b5c96169.png#averageHue=%23111111&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=90&amp;id=u24027707&amp;name=image.png&amp;originHeight=90&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3436&amp;status=done&amp;style=none&amp;taskId=u88d9a7fb-f08c-4035-82ab-48a67509d8f&amp;title=&amp;width=583\" alt=\"image.png\"></p>\n<ol>\n<li>跟踪程序执行过程</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682565168-917f19d2-8e0c-44ab-84e5-453c301bcda0.png#averageHue=%23111111&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=378&amp;id=u739eac5d&amp;name=image.png&amp;originHeight=378&amp;originWidth=593&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13977&amp;status=done&amp;style=none&amp;taskId=u7a4cf037-0141-418c-a6bc-3a455f22fa1&amp;title=&amp;width=593\" alt=\"image.png\"><br>用P命令执行<code>INT 21</code><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682678668-4d6f6ba6-a61b-408a-8aa9-f84fdd1abc8a.png#averageHue=%230d0d0d&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=386&amp;id=ue3d6f0ce&amp;name=image.png&amp;originHeight=386&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12637&amp;status=done&amp;style=none&amp;taskId=ud602a7a4-6c24-495c-b269-66ce57ddba3&amp;title=&amp;width=620\" alt=\"image.png\"><br><a name=\"fqp3r\"></a></p>\n<h2 id=\"assignment-3-1\"><a href=\"#assignment-3-1\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li>查看PSP的内容</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682886059-386e1af8-2b73-480f-92b1-d2ea01cce40a.png#averageHue=%23161616&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=175&amp;id=ueb72f5b4&amp;name=image.png&amp;originHeight=175&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6346&amp;status=done&amp;style=none&amp;taskId=ufec3ae9d-8d07-4ba6-ae47-78454c6ed61&amp;title=&amp;width=625\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"eTiIA\"></a></p>\n<h1 id=\"实验4-bx-和loop的使用\"><a href=\"#实验4-bx-和loop的使用\" class=\"headerlink\" title=\"实验4 [bx]和loop的使用\"></a>实验4 [bx]和loop的使用</h1><p><a name=\"Ypsn2\"></a></p>\n<h2 id=\"assignment-1-3\"><a href=\"#assignment-1-3\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>编写源程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0020H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov dx, 0</span><br><span class=\"line\">mov cx, 64</span><br><span class=\"line\"></span><br><span class=\"line\">s: </span><br><span class=\"line\">mov [bx],dx</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">inc dx</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00h </span><br><span class=\"line\">int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译，链接生成可执行文件</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673769654198-dcf5a11b-b298-4d67-ac52-e6412baa7953.png#averageHue=%230a0a0a&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=308&amp;id=ucb1b0e3f&amp;name=image.png&amp;originHeight=308&amp;originWidth=563&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9162&amp;status=done&amp;style=none&amp;taskId=ud2798294-b700-4d36-9278-b89b6f31b7e&amp;title=&amp;width=563\" alt=\"image.png\"></p>\n<ol>\n<li>查看载入内存的程序，可以看见标签s已被替换为地址$076C:000E$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770040980-f6175097-5e41-41f0-a0d4-ed6dcc9e2d26.png#averageHue=%230f0f0f&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=257&amp;id=ub7d89c02&amp;name=image.png&amp;originHeight=257&amp;originWidth=601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9471&amp;status=done&amp;style=none&amp;taskId=u76baa400-787b-4ed1-b282-488abb7c243&amp;title=&amp;width=601\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，验证结果，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770269260-0b535c86-7318-4bea-9b9b-151df8786503.png#averageHue=%23151515&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=144&amp;id=u9760e10a&amp;name=image.png&amp;originHeight=144&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4621&amp;status=done&amp;style=none&amp;taskId=u407ff41a-3998-40b9-80e2-b904a9486e8&amp;title=&amp;width=480\" alt=\"image.png\"><br><a name=\"q95Oy\"></a></p>\n<h2 id=\"assignment-2-3\"><a href=\"#assignment-2-3\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li><p>编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0020H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 64</span><br><span class=\"line\"></span><br><span class=\"line\">s: </span><br><span class=\"line\">mov [bx],bx</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00h </span><br><span class=\"line\">int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其它步骤与assigment 1一致，验证结果，正确</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673771416582-e853218d-46c6-4bf8-98d6-cacae4200dbb.png#averageHue=%231a1a1a&amp;clientId=u7cc11769-d150-4&amp;from=paste&amp;height=359&amp;id=u85d074a9&amp;name=image.png&amp;originHeight=373&amp;originWidth=490&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9679&amp;status=done&amp;style=none&amp;taskId=uca7996c4-5515-4485-9bd2-5bed6cf48b4&amp;title=&amp;width=472\" alt=\"image.png\"><br><a name=\"b3BKL\"></a></p>\n<h2 id=\"assignment-3-2\"><a href=\"#assignment-3-2\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li>复制的是什么：复制程序的第一条指令<code>mov ax,cs</code>到 <code>loop s</code> 指令至内存地址$0020:0000$处</li>\n<li>如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在<code>mov cx,_____</code> 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：$076C:0000 \\to 076C:0015$，共$16H\\,(23D)$个字节,因此第二个空应该填入$16H$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673774640766-de55642e-4594-4add-9f75-ac17f9cf3628.png#averageHue=%230d0d0d&amp;clientId=u7cc11769-d150-4&amp;from=paste&amp;height=282&amp;id=u704b4ac0&amp;name=image.png&amp;originHeight=282&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9580&amp;status=done&amp;style=none&amp;taskId=u46b6c23e-98fc-45b4-ad17-7f7d7bef327&amp;title=&amp;width=616\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"l6DRo\"></a></p>\n<h1 id=\"实验5-编写、调试具有多个段的程序\"><a href=\"#实验5-编写、调试具有多个段的程序\" class=\"headerlink\" title=\"实验5 编写、调试具有多个段的程序\"></a>实验5 编写、调试具有多个段的程序</h1><p><a name=\"y07m5\"></a></p>\n<h2 id=\"assignment-1-4\"><a href=\"#assignment-1-4\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>将程序载入内存后查看，可知data段段地址为$076C$, stack段段地址为$076D$，code段段地址为$076E$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877104816-d24fcee5-293b-4965-a116-55b74e84812c.png#averageHue=%23101010&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=266&amp;id=u68a1fe4a&amp;name=image.png&amp;originHeight=266&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10189&amp;status=done&amp;style=none&amp;taskId=u25c1d019-e4f1-4cb3-9fef-a5363cacec8&amp;title=&amp;width=619\" alt=\"image.png\"></p>\n<ol>\n<li>Q1：<code>G 001D</code>执行程序至程序返回前，用U命令查看data段内容: $0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H$，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877337524-5a528fcf-a7ec-47a7-ba04-6014616d76ff.png#averageHue=%231a1a1a&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=51&amp;id=u84a23991&amp;name=image.png&amp;originHeight=51&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1917&amp;status=done&amp;style=none&amp;taskId=u5609cee2-98bd-479e-9a89-84510ea0a9d&amp;title=&amp;width=480\" alt=\"image.png\"></p>\n<ol>\n<li>Q2：R命令查看各个段寄存器的值  $\\to \\;CS:076E$、 $DS:076C$、$SS:076D$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877858110-72e7472f-1574-4c88-ae28-a064f40894e4.png#averageHue=%23131313&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=73&amp;id=u1f2d1ce2&amp;name=image.png&amp;originHeight=73&amp;originWidth=592&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3486&amp;status=done&amp;style=none&amp;taskId=ub88918a8-2d91-4abe-b21e-299699ae7ce&amp;title=&amp;width=592\" alt=\"image.png\"></p>\n<ol>\n<li><p>Q3：data段和stack段分别占16个字节，因此设code段段地址为$X$，那么stack段段地址为$X-1H$，data段段地址为$X-2H$（做了assignment2后可以发现这里说法并不准确）<br><a name=\"qSFne\"></a></p>\n<h2 id=\"assignment-2-4\"><a href=\"#assignment-2-4\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2></li>\n<li><p>步骤与assigment1 完全一致</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878358257-7f67627a-48a8-45cf-bc4a-1f51e9552faa.png#averageHue=%230f0f0f&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=265&amp;id=u246ed639&amp;name=image.png&amp;originHeight=265&amp;originWidth=615&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=9903&amp;status=done&amp;style=none&amp;taskId=ud7500b3a-6b24-43c1-8498-3e220eabeef&amp;title=%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E5%90%8E%E7%94%A8U%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%90%84%E4%B8%AA%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&amp;width=615\" alt=\"image.png\" title=\"源程序载入内存后用U命令查看，发现各个段的地址与assignment1完全一致\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878450151-f2a27665-630b-4784-9a07-7c364c930469.png#averageHue=%23111111&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=84&amp;id=u67d44730&amp;name=image.png&amp;originHeight=84&amp;originWidth=582&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3313&amp;status=done&amp;style=none&amp;taskId=u45570d21-23d5-4112-8fa2-e8d2f41ad8a&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D&amp;width=582\" alt=\"image.png\" title=\"执行程序至程序返回前\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878510541-e58f6906-dc84-4df0-a6a2-59cfdf0b4a07.png#averageHue=%231a1a1a&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=54&amp;id=u68b4b398&amp;name=image.png&amp;originHeight=54&amp;originWidth=504&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=2010&amp;status=done&amp;style=none&amp;taskId=u823673f9-a9eb-4ebf-a4ee-ae34390d952&amp;title=%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%80%E8%87%B4%EF%BC%8C%E6%9C%AA%E6%94%B9%E5%8F%98&amp;width=504\" alt=\"image.png\" title=\"查看data段数据，与源程序一致，未改变\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878562565-32d00b48-a53b-4868-916e-9e7ddb4a279d.png#averageHue=%23131313&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=72&amp;id=udc9f18e6&amp;name=image.png&amp;originHeight=72&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3334&amp;status=done&amp;style=none&amp;taskId=uf3897f64-0600-409f-903a-e0c60d2a195&amp;title=%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%EF%BC%8C%E5%90%84%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&amp;width=598\" alt=\"image.png\" title=\"查看寄存器内容，各段寄存器内容与assignment1完全一致\"></p>\n<ol>\n<li><p>得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍<br><a name=\"AiceH\"></a></p>\n<h2 id=\"assignment-3-3\"><a href=\"#assignment-3-3\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2></li>\n<li><p>步骤与assignment1完全一致</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879121558-74eaedb2-acd9-4a9c-a318-e028bba49db2.png#averageHue=%23101010&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=264&amp;id=u5b46f0b2&amp;name=image.png&amp;originHeight=264&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=9249&amp;status=done&amp;style=none&amp;taskId=uab9b0f8d-e010-40c9-ba7f-3de6b6e1d63&amp;title=%E8%B5%B7%E5%A7%8B%E6%AE%B5%E4%B8%BAcode%E6%AE%B5%20%28076C%29%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9D%80data%E6%AE%B5%28076F%29%E5%92%8Cstack%E6%AE%B5%280770%29&amp;width=583\" alt=\"image.png\" title=\"起始段为code段 (076C)，后面跟着data段(076F)和stack段(0770)\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879373761-d05b59a9-6591-4c25-8033-e83698bff61e.png#averageHue=%23171717&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=294&amp;id=u7e2149b7&amp;name=image.png&amp;originHeight=294&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=10607&amp;status=done&amp;style=none&amp;taskId=u25c23b4d-250b-45e7-aa47-be84b0e1458&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D%EF%BC%8C%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E5%86%85%E5%AE%B9%E5%92%8C%E5%90%84%E4%B8%AA%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC&amp;width=625\" alt=\"image.png\" title=\"执行程序至程序返回前，查看data段内容和各个段寄存器的值\"><br>2， 设code段段地址为$X$，那么data段段地址为$X+3H$，stack段段地址为$X+4H$<br><a name=\"NxsNH\"></a></p>\n<h2 id=\"assignment-4-1\"><a href=\"#assignment-4-1\" class=\"headerlink\" title=\"assignment 4\"></a>assignment 4</h2><p>如果去掉通知编译器程序的入口的<code>end start</code>语句，那么唯一可正确运行的是起始段为code段的程序3<br><a name=\"oVwXx\"></a></p>\n<h2 id=\"assignment-5\"><a href=\"#assignment-5\" class=\"headerlink\" title=\"assignment 5\"></a>assignment 5</h2><ol>\n<li><p>编写源程序，注意在将段地址写入$DS$时，要借助一个寄存器充当介质，因为立即数无法直接写入$DS$</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">a segment </span><br><span class=\"line\">db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">a ends</span><br><span class=\"line\"></span><br><span class=\"line\">b segment</span><br><span class=\"line\">db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b ends</span><br><span class=\"line\"></span><br><span class=\"line\">c segment </span><br><span class=\"line\">db 0,0,0,0,0,0,0,0</span><br><span class=\"line\">c ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov dx, a</span><br><span class=\"line\">mov ds,dx</span><br><span class=\"line\">mov ax, [bx]</span><br><span class=\"line\">mov dx, b</span><br><span class=\"line\">mov ds,dx</span><br><span class=\"line\">add ax, [bx]</span><br><span class=\"line\">mov dx, c</span><br><span class=\"line\">mov ds,dx</span><br><span class=\"line\">mov [bx], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax,4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用debug跟踪程序，可以看到a段段地址：$076C$、b段段地址：$076D$、c段段地址：$076E$</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882442409-a3ef513e-eb43-4f18-abf5-ea6f262cc3f6.png#averageHue=%230e0e0e&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=333&amp;id=u80ddd30c&amp;name=image.png&amp;originHeight=333&amp;originWidth=603&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11543&amp;status=done&amp;style=none&amp;taskId=u0f76c72f-ed96-431c-8d71-352a3ca1f86&amp;title=&amp;width=603\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，查看c段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882790995-352f2b4b-203d-458a-b5a2-878acfd29335.png#averageHue=%231e1e1e&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=59&amp;id=uc023038f&amp;name=image.png&amp;originHeight=59&amp;originWidth=498&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=2633&amp;status=done&amp;style=none&amp;taskId=ucae589f2-04bc-4644-899d-6fdbd17e620&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%89%8D%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&amp;width=498\" alt=\"image.png\" title=\"执行程序前，C段内容\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882830219-1912f93e-456b-47b1-b06a-32816e308e07.png#averageHue=%23171717&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=95&amp;id=ud9a53aa1&amp;name=image.png&amp;originHeight=95&amp;originWidth=479&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3576&amp;status=done&amp;style=none&amp;taskId=udb82a728-cd51-436e-9481-a8a6f072f71&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&amp;width=479\" alt=\"image.png\" title=\"执行程序后，C段内容\"><br><a name=\"azFBM\"></a></p>\n<h2 id=\"assignment-6\"><a href=\"#assignment-6\" class=\"headerlink\" title=\"assignment 6\"></a>assignment 6</h2><ol>\n<li><p>编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">a segment</span><br><span class=\"line\">dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span><br><span class=\"line\">a ends</span><br><span class=\"line\"></span><br><span class=\"line\">b segment </span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">b ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment </span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, a</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, b </span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 0010H</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\">s:</span><br><span class=\"line\">push [bx]</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用debug跟踪程序，可以看到a段段地址： $076C$ 、 b段段地址：$076E$、code段段地址：$076F$</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885232599-a5e6bf92-ae97-421b-ad5b-904f427aef76.png#averageHue=%230f0f0f&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=296&amp;id=ub52c7fd8&amp;name=image.png&amp;originHeight=296&amp;originWidth=590&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10267&amp;status=done&amp;style=none&amp;taskId=ub78885e9-2d92-486e-abce-ac5186f563b&amp;title=&amp;width=590\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，查看b段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885271367-eddf0cc8-98aa-4fe8-a38f-a014ed5f8179.png#averageHue=%231b1b1b&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=228&amp;id=ud387c905&amp;name=image.png&amp;originHeight=228&amp;originWidth=525&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10970&amp;status=done&amp;style=none&amp;taskId=u9df34674-6438-4f64-8810-2056308e5b5&amp;title=&amp;width=525\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"O7BgM\"></a></p>\n<h1 id=\"实验6-实践课程中的程序\"><a href=\"#实验6-实践课程中的程序\" class=\"headerlink\" title=\"实验6 实践课程中的程序\"></a>实验6 实践课程中的程序</h1><p><a name=\"dyxQS\"></a></p>\n<h2 id=\"assignment-1-5\"><a href=\"#assignment-1-5\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment </span><br><span class=\"line\">db &#x27;ibm             &#x27;</span><br><span class=\"line\">db &#x27;dec             &#x27;</span><br><span class=\"line\">db &#x27;dos             &#x27;</span><br><span class=\"line\">db &#x27;vax             &#x27;</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">stacksg segment</span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stacksg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stacksg</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 10H</span><br><span class=\"line\">mov ax, datasg</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">s0:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov cx, 3</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov al, [bx+si]</span><br><span class=\"line\">and al, 11011111B</span><br><span class=\"line\">mov [bx+si], al</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s </span><br><span class=\"line\"></span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>跟踪程序，查看data段内容</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954476992-988989f0-7ba5-4132-8b53-011e5cfe1ce7.png#averageHue=%23111111&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=332&amp;id=u6d512701&amp;name=image.png&amp;originHeight=332&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11651&amp;status=done&amp;style=none&amp;taskId=uac27a62a-e7e2-4573-8364-30a015779f0&amp;title=&amp;width=619\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序后，查看data段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954644257-b63d5af0-f266-4057-b1e1-c513e09c9298.png#averageHue=%23151515&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=114&amp;id=u73878512&amp;name=image.png&amp;originHeight=114&amp;originWidth=574&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4009&amp;status=done&amp;style=none&amp;taskId=u92fc65de-f6f5-42c1-84b2-350c1e4d948&amp;title=&amp;width=574\" alt=\"image.png\"><br><a name=\"pHbEJ\"></a></p>\n<h2 id=\"assignment-2-5\"><a href=\"#assignment-2-5\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li><p>编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class=\"line\"></span><br><span class=\"line\">stacksg segment</span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stacksg ends</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment </span><br><span class=\"line\">db &#x27;1. display      &#x27;</span><br><span class=\"line\">db &#x27;2. brows        &#x27;</span><br><span class=\"line\">db &#x27;3. replace      &#x27;</span><br><span class=\"line\">db &#x27;4. modify       &#x27;</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stacksg</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 10H </span><br><span class=\"line\">mov ax, datasg</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">s0:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">s: </span><br><span class=\"line\">mov al, [bx+3+si]</span><br><span class=\"line\">and al, 11011111B</span><br><span class=\"line\">mov [bx+3+si], al</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>跟踪程序，查看data段内容</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955793129-198d15a6-56f1-4375-a4c1-fa6d84e6aa7c.png#averageHue=%23111111&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=311&amp;id=u5ce4b731&amp;name=image.png&amp;originHeight=311&amp;originWidth=623&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12680&amp;status=done&amp;style=none&amp;taskId=u132e706b-1ed7-4582-becb-0f6cd930428&amp;title=&amp;width=623\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，查看data段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955864652-707fd6d7-d65d-4be6-b3f9-bbcbbc27484b.png#averageHue=%23151515&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=110&amp;id=ubb174b39&amp;name=image.png&amp;originHeight=110&amp;originWidth=618&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5260&amp;status=done&amp;style=none&amp;taskId=u786ee51b-5382-4915-8eb1-9feeb54fdba&amp;title=&amp;width=618\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"MJU1z\"></a></p>\n<h1 id=\"实验7-寻址方式在结构化数据访问中的应用\"><a href=\"#实验7-寻址方式在结构化数据访问中的应用\" class=\"headerlink\" title=\"实验7 寻址方式在结构化数据访问中的应用\"></a>实验7 寻址方式在结构化数据访问中的应用</h1><ol>\n<li><p>编写源程序，用<code>word ptr / byte ptr</code>指定内存单元大小主要应用在<code>div</code>指令或用于向内存写入立即数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">db &#x27;1975&#x27;,&#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class=\"line\">db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;</span><br><span class=\"line\">db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">dd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514</span><br><span class=\"line\">dd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000</span><br><span class=\"line\"></span><br><span class=\"line\">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226</span><br><span class=\"line\">dw 11542,14430,15257,17800</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">table segment</span><br><span class=\"line\">db 21 dup (&#x27;year summ ne ?? &#x27;)</span><br><span class=\"line\">table ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack ;0776C</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 10H</span><br><span class=\"line\">mov ax, data ; 076D</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov ax, table ; 077b</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx,0</span><br><span class=\"line\">mov si,0</span><br><span class=\"line\">mov cx,21</span><br><span class=\"line\"></span><br><span class=\"line\">year:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">char:</span><br><span class=\"line\">mov al, es:[si]</span><br><span class=\"line\">mov [bx+di], al</span><br><span class=\"line\">inc di</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop char</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop year</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 21</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">income:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 2</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">dwInt:</span><br><span class=\"line\">mov ax, es:[si]</span><br><span class=\"line\">mov [bx].5[di], ax</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop dwInt</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop income</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 21</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">staff:</span><br><span class=\"line\">mov ax, es:[si]</span><br><span class=\"line\">mov [10+bx], ax</span><br><span class=\"line\">add si, 2;</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop staff</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 21</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">average:</span><br><span class=\"line\">mov dx, [bx+7]</span><br><span class=\"line\">mov ax, [bx+5]</span><br><span class=\"line\">div word ptr [bx+0AH]</span><br><span class=\"line\">mov [bx+0Dh], ax</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop average</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看原始table段的内容</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054412418-905eb553-63b9-4352-8fd3-87d9c57ec955.png#averageHue=%231d1d1d&amp;clientId=u59b02d03-003e-4&amp;from=paste&amp;height=312&amp;id=ue1c1140e&amp;name=image.png&amp;originHeight=312&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19887&amp;status=done&amp;style=none&amp;taskId=ue6fc1e9d-9b84-43c0-852e-a69d953b492&amp;title=&amp;width=640\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序后，查看table段的内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054465034-493bafb1-d935-4da9-b3d0-07b0bdd54911.png#averageHue=%231b1b1b&amp;clientId=u59b02d03-003e-4&amp;from=paste&amp;height=378&amp;id=u98d88789&amp;name=image.png&amp;originHeight=378&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=21611&amp;status=done&amp;style=none&amp;taskId=u95e0d8ba-0b80-4cd2-9a0a-a3aaec2f835&amp;title=&amp;width=630\" alt=\"image.png\"><br><a name=\"wI3bu\"></a></p>\n<h1 id=\"实验8-分析一个奇怪的程序\"><a href=\"#实验8-分析一个奇怪的程序\" class=\"headerlink\" title=\"实验8 分析一个奇怪的程序\"></a>实验8 分析一个奇怪的程序</h1><ol>\n<li>程序从$start$入口处开始执行，一个<code>nop</code>指令占一个字节并表示No operation，此处用了两个<code>nop</code>指令的目的是在$s$处预留两个字节的空间，程序执行<code>mov cs:[di], ax</code>之后$s$处的两个字节被试图写入<code>jmp short s1</code>，接着程序向下执行<code>jmp short s</code>使得程序跳转回$s$处开始执行。</li>\n<li><code>jmp short s1</code>到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从$s2$跳转到$s1$，即从$s2$处的jmp指令的下一指令<code>nop</code>$(076C:0022)$跳转到$s1$处的<code>mov ax, 0</code>$(076C:0018)$，因为<code>jmp short 标号</code>是依据位移进行转移的指令，而此处位移大小为$0022H-0018H =-10D(F6H)$，所以$s$处的<code>jmp short s</code>指令的机器码为<code>EBF6</code>（刚好占两个字节，因此可以被正确写入$s$处）</li>\n<li>执行$s$处的跳转指令，使得$IP = IP+(-10)$,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为<code>mov ax, 4c00H</code>$(000AH-0010H=0000H)$，程序从此处开始向下执行，最终可以正确退出</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674306714709-54439679-a96b-496d-97b1-de0f2c3abf77.png#averageHue=%230d0d0d&amp;clientId=u6f9c44da-f55a-4&amp;from=paste&amp;height=383&amp;id=u78c30e80&amp;name=image.png&amp;originHeight=383&amp;originWidth=595&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10505&amp;status=done&amp;style=none&amp;taskId=uae9cedf9-248f-4122-b32a-b23020dad5f&amp;title=&amp;width=595\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674308784974-d476fbd5-6642-45a7-8e5a-a3db1e5ed646.png#averageHue=%230a0a0a&amp;clientId=u6f9c44da-f55a-4&amp;from=paste&amp;height=150&amp;id=ua98d7cca&amp;name=image.png&amp;originHeight=150&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3506&amp;status=done&amp;style=none&amp;taskId=ufcfb45ef-5abd-4191-9c60-6ca3d7ac8c6&amp;title=&amp;width=640\" alt=\"image.png\"><br><a name=\"lZyJr\"></a></p>\n<h1 id=\"实验9-根据材料编程\"><a href=\"#实验9-根据材料编程\" class=\"headerlink\" title=\"实验9 根据材料编程\"></a>实验9 根据材料编程</h1><ol>\n<li><p>编写源程序：最开始我试图用<code>mov address，data</code>的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据<code>welcome to masm!</code>，利用寄存器$ax$作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">db &#x27;welcome to masm!&#x27;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start: </span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov si, 1824</span><br><span class=\"line\">mov cx, 10H</span><br><span class=\"line\">s0:</span><br><span class=\"line\">mov ah, 82H</span><br><span class=\"line\">mov al, [bx]</span><br><span class=\"line\">mov es:[si], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, 0 </span><br><span class=\"line\">mov si, 1984</span><br><span class=\"line\">mov cx, 10H</span><br><span class=\"line\">s1:</span><br><span class=\"line\">mov ah, 0A4H</span><br><span class=\"line\">mov al, [bx]</span><br><span class=\"line\">mov es:[si], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, 0 </span><br><span class=\"line\">mov si, 2144</span><br><span class=\"line\">mov cx, 10H</span><br><span class=\"line\">s2:</span><br><span class=\"line\">mov ah, 11110001B</span><br><span class=\"line\">mov al, [bx]</span><br><span class=\"line\">mov es:[si], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">loop s2</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最终效果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674447541217-19494cef-6da4-4fd3-b28c-6ad18c755471.png#averageHue=%23080808&amp;clientId=u2be92af7-bf87-4&amp;from=paste&amp;height=400&amp;id=u7d46ece7&amp;name=image.png&amp;originHeight=400&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8808&amp;status=done&amp;style=none&amp;taskId=u5b2b0b44-a96d-458a-878e-8f9b74b9697&amp;title=&amp;width=640\" alt=\"image.png\"></p>\n<p><a name=\"zPzcC\"></a></p>\n<h1 id=\"实验10-编写子程序\"><a href=\"#实验10-编写子程序\" class=\"headerlink\" title=\"实验10 编写子程序\"></a>实验10 编写子程序</h1><p><a name=\"Z9mXL\"></a></p>\n<h2 id=\"assignment-1-6\"><a href=\"#assignment-1-6\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（<strong>注意入栈顺序与出栈顺序相反</strong>）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">data segment</span><br><span class=\"line\">db &quot;welcome to masm!&quot;, 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov dh, 8</span><br><span class=\"line\">mov dl, 3</span><br><span class=\"line\">mov cl, 2</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">call show_str</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">show_str:</span><br><span class=\"line\">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 160 ; 设置指定打印位置</span><br><span class=\"line\">inc dh ; 行数从0开始</span><br><span class=\"line\">mul dh ; 8位乘法，结果存储在ax中</span><br><span class=\"line\">mov bx, ax</span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">mul dl</span><br><span class=\"line\">add bx, ax</span><br><span class=\"line\">mov ah, cl</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">mov cl, [si] ; 设置cx</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz ok ;判断字符串是否结束</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, cl ; 设置字符属性和值</span><br><span class=\"line\">mov es:[bx],ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">jmp print</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret </span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674959885930-a6c4181a-e6a1-44cb-9ec8-cc5013b1314e.png#averageHue=%23141414&amp;clientId=ue48ee0fc-f4a6-4&amp;from=paste&amp;height=427&amp;id=u8c981b1c&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12224&amp;status=done&amp;style=none&amp;taskId=u3854a69e-62d2-4b34-89c5-98dd0c0fb70&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"gCr3l\"></a></p>\n<h2 id=\"assignment-2-6\"><a href=\"#assignment-2-6\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li><p>编写源程序，利用除法溢出公式 </p>\n<pre><code>            $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$&lt;br /&gt;该公式的基本思想是将可能发生除法溢出的32位除法$X/n$，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法&lt;br /&gt;$(H/n)*65536 + (L/n)$&lt;br /&gt;**商（32位）：**&lt;br /&gt;高十六位为$int(H/2)*65536$,低十六为$int([rem(H/n)*65536+L]/n)$&lt;br /&gt;**余数（16位）：**&lt;br /&gt;$rem([rem(H/n)*65536+L]/n)$&lt;br /&gt;（注：对这个公式的理解有限）\n</code></pre><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">mov ax, 4240H</span><br><span class=\"line\">mov dx, 000FH</span><br><span class=\"line\">mov cx, 0AH</span><br><span class=\"line\">call divdw</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">divdw:</span><br><span class=\"line\">push bx</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, ax ; 暂存L</span><br><span class=\"line\">mov ax, dx ; H/N</span><br><span class=\"line\">mov dx, 0</span><br><span class=\"line\">div cx ; int(H/N)在ax中，rem(H/N)在dx中</span><br><span class=\"line\"></span><br><span class=\"line\">push ax ; 暂存int(H/N)，除数</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, bx; dx and ax constitute rem(H/N)*65535+L</span><br><span class=\"line\">div cx ; ax store the result</span><br><span class=\"line\">mov cx, dx</span><br><span class=\"line\"></span><br><span class=\"line\">pop dx ; int(H/N)</span><br><span class=\"line\"></span><br><span class=\"line\">pop bx</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果正确</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675050216892-a6c856a5-19e3-42a9-9dae-62052e8d077c.png#averageHue=%23191919&amp;clientId=u68f84982-1dce-4&amp;from=paste&amp;height=427&amp;id=u69ef2d14&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=16724&amp;status=done&amp;style=none&amp;taskId=u6de69850-12af-46ff-80ef-d1f8f4817f4&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"wHNVn\"></a></p>\n<h2 id=\"assignment-3-4\"><a href=\"#assignment-3-4\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li><p>编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">db 10 dup(0)</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, 12666</span><br><span class=\"line\">mov bx, data</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov bx, stack</span><br><span class=\"line\">mov ss, bx</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">call dtoc</span><br><span class=\"line\"></span><br><span class=\"line\">mov dh, 8</span><br><span class=\"line\">mov dl, 3</span><br><span class=\"line\">mov cl, 2</span><br><span class=\"line\">call show_str</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">dtoc:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\">push si</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, 0 ; 被除数高16位 置0</span><br><span class=\"line\">mov bx, 10</span><br><span class=\"line\">mov di, 0 ; 字符计数</span><br><span class=\"line\"></span><br><span class=\"line\">divide:</span><br><span class=\"line\">mov cx, ax </span><br><span class=\"line\">jcxz over</span><br><span class=\"line\">inc di</span><br><span class=\"line\">div bx ; 32位除法，商在ax，余数在dx</span><br><span class=\"line\">add dx, 30H</span><br><span class=\"line\">push dx</span><br><span class=\"line\">mov dx, 0</span><br><span class=\"line\">jmp divide</span><br><span class=\"line\"></span><br><span class=\"line\">over:</span><br><span class=\"line\">mov cx, di</span><br><span class=\"line\">move: </span><br><span class=\"line\">pop bx</span><br><span class=\"line\">mov [si], bl</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop move</span><br><span class=\"line\"></span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">show_str:</span><br><span class=\"line\">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 160 ; 设置指定打印位置</span><br><span class=\"line\">inc dh ; 行数从0开始</span><br><span class=\"line\">mul dh ; 8位乘法，结果存储在ax中</span><br><span class=\"line\">mov bx, ax</span><br><span class=\"line\">mov dh, 0</span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">mul dl</span><br><span class=\"line\">add bx, ax</span><br><span class=\"line\">mov ah, cl</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">mov cl, [si] ; 设置cx</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz ok ;判断字符串是否结束</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, cl ; 设置字符属性和值</span><br><span class=\"line\">mov es:[bx],ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">jmp print</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret </span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070403817-35e5aa0f-3d0c-42ab-803a-9d7dbf5bcb8a.png#averageHue=%231f1f1e&amp;clientId=u9270fba6-a6a8-4&amp;from=paste&amp;height=427&amp;id=uc1ace679&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=16905&amp;status=done&amp;style=none&amp;taskId=uf4805ca7-fbac-43eb-a257-f1c820ade31&amp;title=%E6%AD%A3%E7%A1%AE%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%AE%B5&amp;width=642\" alt=\"image.png\" title=\"正确写入数据段\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070685747-6e72ffff-b062-418d-9d09-67596698a4ca.png#averageHue=%23141313&amp;clientId=u9270fba6-a6a8-4&amp;from=paste&amp;height=427&amp;id=ub539738e&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=12534&amp;status=done&amp;style=none&amp;taskId=u448c5569-17ad-4eec-8879-9d56a9e0d67&amp;title=%E6%AD%A3%E7%A1%AE%E6%89%93%E5%8D%B0&amp;width=642\" alt=\"image.png\" title=\"正确打印\"><br><a name=\"ww3wC\"></a></p>\n<h1 id=\"实验11-编写子程序\"><a href=\"#实验11-编写子程序\" class=\"headerlink\" title=\"实验11 编写子程序\"></a>实验11 编写子程序</h1><ol>\n<li><p>编写源程序：主要用到了<code>cmp</code>指令和条件转移指令组合形成的if逻辑</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\">datasg segment</span><br><span class=\"line\">db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">begin:</span><br><span class=\"line\">mov ax, datasg</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">call letterc</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">letterc:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push cx</span><br><span class=\"line\"></span><br><span class=\"line\">Capital:</span><br><span class=\"line\">mov al, [si]</span><br><span class=\"line\">mov cl, al</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz OK</span><br><span class=\"line\">cmp al, 97</span><br><span class=\"line\">jb NO</span><br><span class=\"line\">cmp al, 122</span><br><span class=\"line\">ja NO</span><br><span class=\"line\">and al, 11011111B</span><br><span class=\"line\">mov [si], al\t</span><br><span class=\"line\"></span><br><span class=\"line\">NO:</span><br><span class=\"line\">inc si</span><br><span class=\"line\">jmp short Capital</span><br><span class=\"line\"></span><br><span class=\"line\">OK:</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end begin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142887049-1e6b7958-8779-4745-81f5-c6a536a232ca.png#averageHue=%231d1d1d&amp;clientId=u14a9d0ea-1971-4&amp;from=paste&amp;height=427&amp;id=u9451414e&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=18343&amp;status=done&amp;style=none&amp;taskId=u733f3e2b-82d2-436e-a8de-95b8faa1f07&amp;title=%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81&amp;width=642\" alt=\"image.png\" title=\"初始状态\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142878774-286c5ae3-e961-424a-96db-dae987c9a153.png#averageHue=%23212121&amp;clientId=u14a9d0ea-1971-4&amp;from=paste&amp;height=427&amp;id=ub5c49ec4&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=19861&amp;status=done&amp;style=none&amp;taskId=u7a2a2568-c507-4078-a32b-b75eef2ec62&amp;title=%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99&amp;width=642\" alt=\"image.png\" title=\"全部大写\"><br><a name=\"bk4z5\"></a></p>\n<h1 id=\"实验12-编写0号中断的处理程序\"><a href=\"#实验12-编写0号中断的处理程序\" class=\"headerlink\" title=\"实验12 编写0号中断的处理程序\"></a>实验12 编写0号中断的处理程序</h1><ol>\n<li>编写源程序</li>\n</ol>\n<p>总体来说就3个任务：</p>\n<ul>\n<li>编写中断处理程序 </li>\n<li>复制中断处理程序至内存空闲区域($0000:0200H\\to0000:02FFH$)  </li>\n<li>修改中断向量表（中断处理程序地址入口表）</li>\n</ul>\n<p>注意在用<code>jcxz</code>条件转移指令时，要<code>jmp short</code>回程序开头<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset do0 ; 076C:0028</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset do0end- offset do0; 0034H</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep movsb ; 复制程序到0:200</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[0], 0200H</span><br><span class=\"line\">mov word ptr es:[0+2], 0 ; 修改中断向量表</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">do0:</span><br><span class=\"line\">jmp short do0start</span><br><span class=\"line\">db &quot;divide error&quot;,0 </span><br><span class=\"line\"></span><br><span class=\"line\">do0start:</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 160*12+34*2</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, 202H</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">mov cL, [si]</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz ok</span><br><span class=\"line\">mov ah, 04h ;red</span><br><span class=\"line\">mov al, cl</span><br><span class=\"line\">mov es:[di], ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add di, 2 </span><br><span class=\"line\">jmp short print</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">do0end: ;005C</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675159533550-89caf027-f6da-4345-aa8c-e03159df600e.png#averageHue=%23141414&amp;clientId=u2ec176e2-9874-4&amp;from=paste&amp;height=427&amp;id=u6679d84b&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12440&amp;status=done&amp;style=none&amp;taskId=u7d87f433-7092-4f23-a3d6-b1339bf6fe9&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"YSdgF\"></a></p>\n<h1 id=\"实验13-编写、应用中断例程\"><a href=\"#实验13-编写、应用中断例程\" class=\"headerlink\" title=\"实验13 编写、应用中断例程\"></a>实验13 编写、应用中断例程</h1><p><a name=\"HHw6N\"></a></p>\n<h2 id=\"assignment-1-7\"><a href=\"#assignment-1-7\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>编写源程序：与lab10-1的show_str基本一致，只需将<code>call-ret</code>更改为 <code>int 7cH - iret</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset print</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset printed - offset print</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep  movsb</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[7cH*4], 0200H</span><br><span class=\"line\">mov word ptr es:[7cH*4+2], 0 </span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push dx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 160</span><br><span class=\"line\">inc dh</span><br><span class=\"line\">mul dh ; 160*(10+1) in ax</span><br><span class=\"line\">mov bx, ax</span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">mul dl ; 10*2 in ax</span><br><span class=\"line\">add bx, ax</span><br><span class=\"line\">mov ah, cl</span><br><span class=\"line\"></span><br><span class=\"line\">stPrint:</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">mov cl, [si]</span><br><span class=\"line\">jcxz ok</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, cl</span><br><span class=\"line\">mov es:[bx], ax</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">inc si</span><br><span class=\"line\">jmp short stPrint</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">printed:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675224733068-a783d5cd-5d35-46b5-8032-3c8938e8347a.png#averageHue=%23131313&amp;clientId=u8a54de4a-c425-4&amp;from=paste&amp;height=427&amp;id=u9672685d&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12092&amp;status=done&amp;style=none&amp;taskId=u4599fb35-92fc-4ea1-b9cb-e60668d8629&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"LKaNX\"></a></p>\n<h2 id=\"assignment-2-7\"><a href=\"#assignment-2-7\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li>编写源程序</li>\n</ol>\n<p>用中断例程实现loop指令，主要需要解决三个问题</p>\n<ul>\n<li>怎么取得标号$S$的段地址和偏移地址？</li>\n</ul>\n<p>有一对段地址$CS$和偏移地址$IP$在中断过程时被压入栈，标号的段地址就是该CS，标号           的偏移地址可由该IP加上转移地址(<code>offset s - offset se</code>)得到</p>\n<ul>\n<li>得到$S$的段地址和偏移地址后，如何设置$CS:IP$</li>\n</ul>\n<p>用<code>iret</code>指令：<code>pop IP , pop CS ,  popf</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset lp</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset lped - offset lp</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep  movsb</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[7cH*4], 0200H</span><br><span class=\"line\">mov word ptr es:[7cH*4+2], 0 </span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">lp:</span><br><span class=\"line\">dec cx</span><br><span class=\"line\">jcxz lpret</span><br><span class=\"line\">push bp</span><br><span class=\"line\">mov bp, sp</span><br><span class=\"line\">add [bp+2], bx</span><br><span class=\"line\">lpret:</span><br><span class=\"line\">pop bp</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">lped:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675237825483-f1ed3d6d-00cc-453b-91b3-757823355468.png#averageHue=%23171515&amp;clientId=ub529a018-e1a0-4&amp;from=paste&amp;height=427&amp;id=u272d8fd4&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12787&amp;status=done&amp;style=none&amp;taskId=u38f1e876-6c89-499b-b704-a23609bf566&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"TCCAl\"></a></p>\n<h2 id=\"assignment-3-5\"><a href=\"#assignment-3-5\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">s1: db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class=\"line\">s2: db &#x27;Never let it rest,&#x27;,&#x27;$&#x27; </span><br><span class=\"line\">s3: db &#x27;Till good is better,&#x27;,&#x27;$&#x27;</span><br><span class=\"line\">s4: db &#x27;And better,best.&#x27;, &#x27;$&#x27;</span><br><span class=\"line\">s: dw offset s1, offset s2, offset s3, offset s4 </span><br><span class=\"line\">row: db 2,4,6,8</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs </span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, offset s</span><br><span class=\"line\">mov si, offset row</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">ok:</span><br><span class=\"line\">mov bh, 0 </span><br><span class=\"line\">mov dh, [si]</span><br><span class=\"line\">mov dl, 0</span><br><span class=\"line\">mov ah, 2 ; BIOS中断例程--设置光标</span><br><span class=\"line\">int 10h </span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, [bx]                                           </span><br><span class=\"line\">mov ah, 9 ; DOS中断例程--打印字符串</span><br><span class=\"line\">int 21h</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop ok</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H; DOS中断例程--程序返回，返回值在al</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p><a name=\"zGspx\"></a></p>\n<h1 id=\"实验14-访问-CMOS-RAM\"><a href=\"#实验14-访问-CMOS-RAM\" class=\"headerlink\" title=\"实验14 访问 CMOS RAM\"></a>实验14 访问 CMOS RAM</h1><ol>\n<li><p>编写源程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 9</span><br><span class=\"line\">mov bx, 160*12+36*2</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 8</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 7</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27; &#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 4</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 0</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">GetAscill:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\"></span><br><span class=\"line\">out 70H, al</span><br><span class=\"line\">in al, 71H</span><br><span class=\"line\"></span><br><span class=\"line\">mov ah, al</span><br><span class=\"line\">mov cl, 4</span><br><span class=\"line\">shr ah, cl</span><br><span class=\"line\">and al, 00001111B</span><br><span class=\"line\"></span><br><span class=\"line\">add ah, 30H</span><br><span class=\"line\">add al, 30H</span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, 0B800H</span><br><span class=\"line\">mov es, dx</span><br><span class=\"line\">mov es:[bx], ah </span><br><span class=\"line\">mov byte ptr es:[bx+1], 02H ; green</span><br><span class=\"line\">mov es:[bx+2], al</span><br><span class=\"line\">mov byte ptr es:[bx+3], 02H</span><br><span class=\"line\"></span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675253920788-8fc4fee5-abeb-4e49-93bf-97e3873b6599.png#averageHue=%23141413&amp;clientId=uf0bf1a62-8c66-4&amp;from=paste&amp;height=388&amp;id=u067d841f&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11685&amp;status=done&amp;style=none&amp;taskId=u21f4afac-9bb2-4466-b21a-1a578f58efb&amp;title=&amp;width=583.6363509863864\" alt=\"image.png\"><br><a name=\"yTwL0\"></a></p>\n<h1 id=\"实验15-安装新的int-9-中断例程\"><a href=\"#实验15-安装新的int-9-中断例程\" class=\"headerlink\" title=\"实验15 安装新的int 9 中断例程\"></a>实验15 安装新的int 9 中断例程</h1><p><a name=\"TIrMX\"></a></p>\n<h2 id=\"前置练习1\"><a href=\"#前置练习1\" class=\"headerlink\" title=\"前置练习1\"></a>前置练习1</h2><p>在屏幕中间依次显示$a\\to z$,按Esc键后改变与颜色</p>\n<ol>\n<li><p>编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把<code>call dword ptr ds:[0]</code>写成了<code>call word ptr ds:[0]</code>，导致整个系统没有正确的int 9中断例程，因此出现了错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">db 64 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">dw 0,0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 40H</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">push es:[9*4]</span><br><span class=\"line\">pop ds:[0]</span><br><span class=\"line\">push es:[9*4+2]</span><br><span class=\"line\">pop ds:[2] ; 保存原int 9中断例程的入口地址</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">mov word ptr es:[9*4], offset int9</span><br><span class=\"line\">mov es:[9*4+2], cs;设置新的入口地址</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es,ax</span><br><span class=\"line\">mov dh, &#x27;a&#x27;</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov es:[160*12+40*2], dh</span><br><span class=\"line\">call delay</span><br><span class=\"line\">inc dh</span><br><span class=\"line\">cmp dh, &#x27;z&#x27;</span><br><span class=\"line\">jna s ; 依次打印a~z</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0 </span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">push ds:[0]</span><br><span class=\"line\">pop es:[9*4]</span><br><span class=\"line\">push ds:[2]</span><br><span class=\"line\">pop es:[9*4+2] ;恢复原int 9中断例程的入口地址</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00h</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">delay:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push dx</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov dx, 10H</span><br><span class=\"line\">se:</span><br><span class=\"line\">sub ax, 1 ; 不能用dec</span><br><span class=\"line\">sbb dx, 0</span><br><span class=\"line\">cmp ax, 0</span><br><span class=\"line\">jne se</span><br><span class=\"line\">cmp dx, 0</span><br><span class=\"line\">jne se</span><br><span class=\"line\"></span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret ; 延时</span><br><span class=\"line\"></span><br><span class=\"line\">int9:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push es</span><br><span class=\"line\">in al, 60H</span><br><span class=\"line\"></span><br><span class=\"line\">pushf</span><br><span class=\"line\">call dword ptr ds:[0]</span><br><span class=\"line\"></span><br><span class=\"line\">cmp al, 01H</span><br><span class=\"line\">jne int9ret</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">inc byte ptr es:[160*12+40*2+1] ; 修改字符属性</span><br><span class=\"line\"></span><br><span class=\"line\">int9ret:</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319548168-77f7b5a6-54bb-4526-b234-adb0e561004e.png#averageHue=%237ab44c&amp;clientId=u17647ab4-03d9-4&amp;from=paste&amp;height=388&amp;id=u49a1ed0a&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=13571&amp;status=done&amp;style=none&amp;taskId=u61859af5-760b-45d0-8b8d-c62aa3a3245&amp;title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B21&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按Esc改变颜色1\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319563355-013b242f-ab37-4a8f-a956-6222d6e1847c.png#averageHue=%238dd756&amp;clientId=u17647ab4-03d9-4&amp;from=paste&amp;height=388&amp;id=u9a049927&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=13830&amp;status=done&amp;style=none&amp;taskId=u52c59e7d-a185-4177-8537-a05965e054e&amp;title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B22&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按Esc改变颜色2\"><br><a name=\"vlBjq\"></a></p>\n<h2 id=\"前置练习2\"><a href=\"#前置练习2\" class=\"headerlink\" title=\"前置练习2\"></a>前置练习2</h2><p>在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理</p>\n<ol>\n<li><p>编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在$0:0200 \\to 0:0203$,可在新int 9中断例程中通过<code>cs:[200H]</code>访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">db 32 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0204H</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset int9</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset int9ed - offset int9</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep movsb; 安装</span><br><span class=\"line\"></span><br><span class=\"line\">push es:[9*4]</span><br><span class=\"line\">pop es:[200H]</span><br><span class=\"line\">push es:[9*4+2]</span><br><span class=\"line\">pop es:[202H] ; 保存原int 9入口地址</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">mov word ptr es:[9*4], 204H</span><br><span class=\"line\">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">int9:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">in al, 60H</span><br><span class=\"line\"></span><br><span class=\"line\">pushf</span><br><span class=\"line\">call dword ptr cs:[200H] ; 调用原int 9</span><br><span class=\"line\"></span><br><span class=\"line\">cmp al, 3BH</span><br><span class=\"line\">jne int9ret</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 1</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">s:</span><br><span class=\"line\">inc byte ptr es:[di]</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">int9ret:</span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int9ed:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322759364-2785ad21-17c7-4499-b1a3-fe6726975b02.png#averageHue=%230d0d0d&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u4340ef70&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=12813&amp;status=done&amp;style=none&amp;taskId=uc1c9e4ff-ae09-465d-a787-aba159b8b98&amp;title=%E6%8C%89%E4%B8%8BF1%201&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按下F1 1\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322817620-9b94c323-5bcb-4465-ba63-7a2721ba4d46.png#averageHue=%23aeaeae&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u019e66f9&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8862&amp;status=done&amp;style=none&amp;taskId=ue0c4ae51-d75f-4e13-8d7c-a26ee51e20f&amp;title=%E6%8C%89%E4%B8%8BF1%202&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按下F1 2\"><br><a name=\"XyIu0\"></a></p>\n<h2 id=\"assignment-1-8\"><a href=\"#assignment-1-8\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>编写源程序</li>\n</ol>\n<p>与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码<code>cmp aL, 1EH+80H</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">db 32 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0204H</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset int9</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset int9ed - offset int9</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep movsb; 安装</span><br><span class=\"line\"></span><br><span class=\"line\">push es:[9*4]</span><br><span class=\"line\">pop es:[200H]</span><br><span class=\"line\">push es:[9*4+2]</span><br><span class=\"line\">pop es:[202H] ; 保存原int 9入口地址</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">mov word ptr es:[9*4], 204H</span><br><span class=\"line\">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">int9:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">in aL,60h</span><br><span class=\"line\"></span><br><span class=\"line\">pushf</span><br><span class=\"line\">call dword ptr cs:[200H]</span><br><span class=\"line\"></span><br><span class=\"line\">cmp aL, 1EH+80H</span><br><span class=\"line\">jne int9ret</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov byte ptr es:[di], &#x27;A&#x27;</span><br><span class=\"line\">mov byte ptr es:[di+1], 02H</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">int9ret:</span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">int9ed:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675329053483-60588212-d9b5-4cef-acf7-06c70f65db5f.png#averageHue=%23141313&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u7a90e8bd&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=7755&amp;status=done&amp;style=none&amp;taskId=u3c74959a-2b05-4756-8089-500ac2f8893&amp;title=%E6%8C%89%E4%B8%8BA%E5%90%8E%E6%9D%BE%E5%BC%80&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按下A后松开\"><br><a name=\"YodIM\"></a></p>\n<h1 id=\"实验16-编写包含多个功能子程序的中断例程\"><a href=\"#实验16-编写包含多个功能子程序的中断例程\" class=\"headerlink\" title=\"实验16 编写包含多个功能子程序的中断例程\"></a>实验16 编写包含多个功能子程序的中断例程</h1><ol>\n<li>编写源程序</li>\n</ol>\n<p>注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset int7ch</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset int7ched - offset int7ch</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep  movsb</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[7cH*4], 0200H</span><br><span class=\"line\">mov word ptr es:[7cH*4+2], 0 </span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">int7ch:</span><br><span class=\"line\">jmp short int7chStart</span><br><span class=\"line\">table dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200H</span><br><span class=\"line\"></span><br><span class=\"line\">int7chStart:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">cmp ah, 3</span><br><span class=\"line\">ja int7chRet</span><br><span class=\"line\">mov bl, ah</span><br><span class=\"line\">mov bh, 0</span><br><span class=\"line\">add bx, bx</span><br><span class=\"line\">call word ptr cs:(table-int7ch+200H)[bx]</span><br><span class=\"line\"></span><br><span class=\"line\">int7chRet:</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub1:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">s1:</span><br><span class=\"line\">mov byte ptr [bx], &#x27; &#x27;</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s1</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub2:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">mov bx, 0B800H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov bx, 1</span><br><span class=\"line\">s2:</span><br><span class=\"line\">and byte ptr [bx], 11111000B ; 只设置最后3位</span><br><span class=\"line\">or byte ptr [bx], al</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s2</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub3:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">mov bx, 0B800H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov cl, 4</span><br><span class=\"line\">shl al, cl</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov bx, 1</span><br><span class=\"line\">s3:</span><br><span class=\"line\">and byte ptr [bx], 10001111B</span><br><span class=\"line\">or [bx], al</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s3</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub4:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\">push di</span><br><span class=\"line\">mov bx, 08B00H</span><br><span class=\"line\">mov es, bx</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov si, 160</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">cld</span><br><span class=\"line\">mov cx, 24</span><br><span class=\"line\"></span><br><span class=\"line\">s4:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 160</span><br><span class=\"line\">rep movsb</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">loop s4</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 80</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">s41:</span><br><span class=\"line\">mov byte ptr [160*24+si], &#x27; &#x27;</span><br><span class=\"line\">add si ,2</span><br><span class=\"line\">loop s41</span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">int7ched:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ah,1 ; 0 2 3</span><br><span class=\"line\">mov al,2</span><br><span class=\"line\">int 7CH</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411618416-c6c100a2-f4d1-4bc9-b3e6-22f83fcdcaee.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u97049213&amp;name=image.png&amp;originHeight=427&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=5698&amp;status=done&amp;style=none&amp;taskId=udfd4d7d0-2546-4521-8884-82d74fe5421&amp;title=%E5%8A%9F%E8%83%BD1%EF%BC%9A%E6%B8%85%E5%B1%8F&amp;width=620\" alt=\"image.png\" title=\"功能1：清屏\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411466691-92faf4b3-fbd7-4859-b68b-e403f87d23e1.png#averageHue=%230e0e0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u0af61a75&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=11776&amp;status=done&amp;style=none&amp;taskId=ud7c332b2-9214-4185-917e-392d79cda17&amp;title=%E5%8A%9F%E8%83%BD2%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%89%8D%E6%99%AF%E8%89%B2&amp;width=642\" alt=\"image.png\" title=\"功能2：设置前景色\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411696534-79bed444-6b2a-4a77-ad72-027fb2081a4b.png#averageHue=%2300a900&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ue6689a35&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=11354&amp;status=done&amp;style=none&amp;taskId=u07994587-f0a4-4e4c-b31e-52a54f59cd3&amp;title=%E5%8A%9F%E8%83%BD3%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E8%89%B2&amp;width=642\" alt=\"image.png\" title=\"功能3：设置背景色\"><br><a name=\"IRx7s\"></a></p>\n<h1 id=\"实验17-编写包含多个功能子程序的中断例程\"><a href=\"#实验17-编写包含多个功能子程序的中断例程\" class=\"headerlink\" title=\"实验17 编写包含多个功能子程序的中断例程\"></a>实验17 编写包含多个功能子程序的中断例程</h1><p>第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了<br><a name=\"upigZ\"></a></p>\n<h2 id=\"练习17-1\"><a href=\"#练习17-1\" class=\"headerlink\" title=\"练习17-1\"></a>练习17-1</h2><p>接受用户的键盘输入，输入”r”，”g”,“b”分别将屏幕上的字符设置为红色，绿色，蓝色</p>\n<ol>\n<li>编写源程序</li>\n</ol>\n<p>用功能号为0的int 16H中断例程读取键盘输入即可<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\"></span><br><span class=\"line\">show:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push es</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">mov ah, 0</span><br><span class=\"line\">int 16H</span><br><span class=\"line\"></span><br><span class=\"line\">mov bl, 1</span><br><span class=\"line\">cmp al,&#x27;b&#x27;</span><br><span class=\"line\">je showst</span><br><span class=\"line\">shl bl, 1</span><br><span class=\"line\">cmp al, &#x27;g&#x27;</span><br><span class=\"line\">je showst</span><br><span class=\"line\">shl bl, 1</span><br><span class=\"line\">cmp al, &#x27;r&#x27;</span><br><span class=\"line\">je showst</span><br><span class=\"line\">jmp short FRet</span><br><span class=\"line\"></span><br><span class=\"line\">showst:</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 1</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">s:</span><br><span class=\"line\">and byte ptr es:[di], 11111000B</span><br><span class=\"line\">or es:[di], bl</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">FRet:</span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431818731-db0edf92-bc54-4bfc-a35f-613c796dddda.png#averageHue=%230f0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u2f889938&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8416&amp;status=done&amp;style=none&amp;taskId=u3c7affc7-f57c-470f-9cab-1a94bcb3c74&amp;title=r-red&amp;width=642\" alt=\"image.png\" title=\"r-red\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431840911-15621108-ffb6-42ce-94ab-603c36fe9540.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u1bb9ce94&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8174&amp;status=done&amp;style=none&amp;taskId=u26c95d33-ee9d-414a-9861-7aa91427bc6&amp;title=g-green&amp;width=642\" alt=\"image.png\" title=\"g-green\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431855013-727c9bbb-b9bf-43a5-9ca6-ea80957dfa92.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ucb1b0f24&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8133&amp;status=done&amp;style=none&amp;taskId=ub45cc602-bef7-4fba-9ec7-3d4b52f4485&amp;title=b-blue&amp;width=642\" alt=\"image.png\" title=\"b-blue\"><br><a name=\"Wyllk\"></a></p>\n<h1 id=\"Other\"><a href=\"#Other\" class=\"headerlink\" title=\"Other\"></a>Other</h1><p><a name=\"QMCD1\"></a></p>\n<h2 id=\"1-理解assume伪指令的作用\"><a href=\"#1-理解assume伪指令的作用\" class=\"headerlink\" title=\"1. 理解assume伪指令的作用\"></a>1. 理解assume伪指令的作用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">a db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b dw 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">mov ah, 0</span><br><span class=\"line\">mov al, a[si]</span><br><span class=\"line\">add b, ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>assume ds:data ss:stack</code></li>\n</ol>\n<ul>\n<li>assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器$DS、SS$中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:<code>mov ax, data ``mov ds, ax</code></li>\n<li>assume是伪指令，用于指示编译器将$DS、SS$分别与data段和stack段关联。①关联是什么意思呢？就是<strong>在编译时默认data段中的数据标号a、b的段地址在</strong>$DS$<strong>中</strong>，因此如果要正确访问到a、b的内容，必须用指令将data填入$DS$中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此<code>mov ax, data</code>在编译器看来是<code>mov ax, data段段地址</code>，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax</li>\n</ul>\n<p>如果在程序中省略<code>assume ds:data</code>，则会出现_不能用段寄存器寻址_的错误<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675343108877-68cf68d3-97ef-4ecb-8b4f-6da330149c94.png#averageHue=%23161616&amp;clientId=u3f46bb08-d532-4&amp;from=paste&amp;height=388&amp;id=uffd0ec43&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13264&amp;status=done&amp;style=none&amp;taskId=ud9fb02f3-e117-4559-bfe1-1659d6727ee&amp;title=&amp;width=583.6363509863864\" alt=\"image.png\"></p>\n<ol>\n<li><code>assume cs:codesg</code></li>\n</ol>\n<p>将$CS$与代码段关联，在程序加载时将代码段(codesg)的段地址放入$CS$中. 如果去掉该语句，则程序编译不通过，因为$CS$的值不确定<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675341791119-4c9029f0-b9e3-4e2f-b1b9-aa5d02685f8f.png#averageHue=%230d0d0d&amp;clientId=u3f46bb08-d532-4&amp;from=paste&amp;height=276&amp;id=u952199f2&amp;name=image.png&amp;originHeight=304&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9905&amp;status=done&amp;style=none&amp;taskId=ud6cc6c48-9ce9-4df5-a654-02e53729a4d&amp;title=&amp;width=581.8181692076126\" alt=\"image.png\"><br><a name=\"wwfwW\"></a></p>\n<h2 id=\"2-理解数据标号\"><a href=\"#2-理解数据标号\" class=\"headerlink\" title=\"2. 理解数据标号\"></a>2. 理解数据标号</h2><ol>\n<li>数据标号与地址标号的不同</li>\n</ol>\n<p>地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, es:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">a db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b dw 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">mov ah, 0</span><br><span class=\"line\">mov al, a[si]</span><br><span class=\"line\">add b, ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure><br>这里的a和b分别指代了</p>\n<ul>\n<li><strong>地址为</strong><code>**seg data:0**</code><strong>, 长度为byte的字节单元</strong></li>\n<li><strong>地址为</strong><code>**seg data:8**</code><strong>, 长度为word的字单元</strong></li>\n</ul>\n<ol>\n<li>如何用数据标号以简洁形式访问内存中的数据</li>\n</ol>\n<p>在上一个程序中，我们用<code>mov al, a[si]</code> <code>add b, ax</code>访问了data段的内容，在编译器看来，这两条语句是这样的: <code>mov al, es:0[si]``add es:[8], ax</code><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409971871-70ff728a-fa74-48ac-a742-be8ec319d677.png#averageHue=%23191919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u6e4d3ff6&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14859&amp;status=done&amp;style=none&amp;taskId=ua1726f99-29ec-46f7-ac48-ad448e15a63&amp;title=&amp;width=642\" alt=\"image.png\"><br>我们现在用更熟悉的<code>mov al, [si+a]</code> <code>add b[0], ax</code>形式，从编译器角度来看，这两种形式没有区别<br>这说明了在指令中<strong>a等价于</strong><code>**byte ptr [0]**</code><strong>，b等价于</strong><code>**word ptr [8]**</code>（仅含偏移地址信息，默认段地址在es中，因为<code>assume es:data</code>）<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675410379440-d032239f-bb7d-480f-a45d-f96f7d064cd3.png#averageHue=%231a1919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ubbac8493&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15290&amp;status=done&amp;style=none&amp;taskId=uce443a00-0b21-4ac2-89ac-bb7e70f3432&amp;title=&amp;width=642\" alt=\"image.png\"></p>\n<ol>\n<li>将标号当作数据定义<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">a db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b dw 0</span><br><span class=\"line\">c dw a, b</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, 2</span><br><span class=\"line\">mov dx, c</span><br><span class=\"line\">mov ax, c[1]</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<code>c dw a, b</code>将数据标号当作数据定义，c指代地址为<code>seg data:000A</code>的字单元，<strong>该字单元的内容是a的偏移地址</strong>$0000$，下面是验证<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409382345-20e1a2f2-8973-4150-992a-2a8acb141fa9.png#averageHue=%23191919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ud990b41d&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15496&amp;status=done&amp;style=none&amp;taskId=u9d64f540-f9d7-4f4d-a179-67094b0601b&amp;title=&amp;width=642\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409496753-347acc0d-300d-4502-b228-e202ee4504a4.png#averageHue=%23101010&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=400&amp;id=u97a8ca97&amp;name=image.png&amp;originHeight=400&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12100&amp;status=done&amp;style=none&amp;taskId=u65363c06-9a66-4677-9782-717ab71b1b6&amp;title=&amp;width=640\" alt=\"image.png\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><meta name=\"referrer\" content=\"no-referrer\"><br><a name=\"MTE7s\"></a></p>\n<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><p>前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的attack lab完成了</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a></h2>","more":"<p><a name=\"PhqOH\"></a></p>\n<h1 id=\"实验1-查看CPU和内存，用机器指令和汇编指令编程\"><a href=\"#实验1-查看CPU和内存，用机器指令和汇编指令编程\" class=\"headerlink\" title=\"实验1 查看CPU和内存，用机器指令和汇编指令编程\"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h1><p><a name=\"xymUo\"></a></p>\n<h2 id=\"debug环境搭建：参考此文\"><a href=\"#debug环境搭建：参考此文\" class=\"headerlink\" title=\"debug环境搭建：参考此文\"></a>debug环境搭建：<a href=\"https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506\">参考此文</a></h2><p><a name=\"UrdzB\"></a></p>\n<h2 id=\"assignment-1\"><a href=\"#assignment-1\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>用A命令向内存中写入汇编指令，用U命令查看</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249473372-3a80b2ab-d9e2-483c-ac41-140d30fdd765.png#averageHue=%23161616&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=248&amp;id=ub963f2d1&amp;name=image.png&amp;originHeight=245&amp;originWidth=374&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6659&amp;status=done&amp;style=none&amp;taskId=u0fa9efb8-dccf-4ce1-b3ea-8d79929c540&amp;title=&amp;width=378\" alt=\"image.png\"></p>\n<ol>\n<li>用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249669344-d36231e5-8310-46ba-a3c6-155e2601ff58.png#averageHue=%230e0e0e&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=309&amp;id=udc060390&amp;name=image.png&amp;originHeight=309&amp;originWidth=608&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7838&amp;status=done&amp;style=none&amp;taskId=udc51570f-ded8-4f72-a2f5-ee442502176&amp;title=&amp;width=608\" alt=\"image.png\"><br><a name=\"rTW1r\"></a></p>\n<h2 id=\"assignment-2\"><a href=\"#assignment-2\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li>写入并查看指令</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250172971-61fbb876-feda-4ca9-b81d-e558cc0e5a6a.png#averageHue=%23151515&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=174&amp;id=u55f6e2fe&amp;name=image.png&amp;originHeight=174&amp;originWidth=376&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4324&amp;status=done&amp;style=none&amp;taskId=u9c9ba619-9a5c-4e5c-9e9d-45d5a6ea724&amp;title=&amp;width=376\" alt=\"image.png\"></p>\n<ol>\n<li>修改_CS:IP_指向</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250237721-ec3e62f5-f6bc-4890-8f25-b62f6d89e60e.png#averageHue=%230c0c0c&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=228&amp;id=u87c23aee&amp;name=image.png&amp;originHeight=228&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7409&amp;status=done&amp;style=none&amp;taskId=u0c70f1dc-bfd2-4472-a4d5-84a3fe97214&amp;title=&amp;width=642\" alt=\"image.png\"></p>\n<ol>\n<li>执行指令，计算$2^8$，结果为 $AX = 0100H$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250558182-3582fd8d-9783-421c-9731-0d83ae5c81a8.png#averageHue=%23121212&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=72&amp;id=u92a48cc6&amp;name=image.png&amp;originHeight=72&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2934&amp;status=done&amp;style=none&amp;taskId=ud124b271-ce25-43f5-aabf-1f9dd478c19&amp;title=&amp;width=583\" alt=\"image.png\"><br><a name=\"QAZ3Z\"></a></p>\n<h2 id=\"assignment-3\"><a href=\"#assignment-3\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li>用D命令查找，最终在$FFFF5H \\to FFFFCH（FFFF:0005 \\to FFFF:000C）$发现$dd/mm/yy$字样的生产日期</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251622812-ca79ef23-5a2a-46b2-ba9f-326aa9d3bc54.png#averageHue=%23161616&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=68&amp;id=ud8481a70&amp;name=image.png&amp;originHeight=68&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3411&amp;status=done&amp;style=none&amp;taskId=u26b9075a-3732-4bca-831f-f7252d9a335&amp;title=&amp;width=630\" alt=\"image.png\"></p>\n<ol>\n<li>尝试用E命令修改，该操作失效，因为这是ROM</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251941938-25cdf39e-5c26-49a3-81da-f108dff28da7.png#averageHue=%230f0f0f&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=120&amp;id=u23687460&amp;name=image.png&amp;originHeight=120&amp;originWidth=632&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4133&amp;status=done&amp;style=none&amp;taskId=uca81322b-a794-4e03-b596-0d7a694a021&amp;title=&amp;width=632\" alt=\"image.png\"><br><a name=\"CHS7t\"></a></p>\n<h2 id=\"assignment-4\"><a href=\"#assignment-4\" class=\"headerlink\" title=\"assignment 4\"></a>assignment 4</h2><p>1.$A0000H \\to BFFFFH$对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253290191-823908a7-61e0-4e4d-ac20-66184b8a4509.png#averageHue=%23141414&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=24&amp;id=udb4b1014&amp;name=image.png&amp;originHeight=24&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=646&amp;status=done&amp;style=none&amp;taskId=uc1f68660-8c22-4e6b-81ab-8168f9d217e&amp;title=&amp;width=316\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253301915-ead25a09-d4a2-48f2-ba25-7bb4b7279d64.png#averageHue=%230000aa&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=46&amp;id=u1f906edf&amp;name=image.png&amp;originHeight=46&amp;originWidth=489&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1808&amp;status=done&amp;style=none&amp;taskId=u8980a613-e82f-4ceb-a518-1e33c095648&amp;title=&amp;width=489\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"hcb7h\"></a></p>\n<h1 id=\"实验2-用机器指令和汇编指令编程\"><a href=\"#实验2-用机器指令和汇编指令编程\" class=\"headerlink\" title=\"实验2 用机器指令和汇编指令编程\"></a>实验2 用机器指令和汇编指令编程</h1><p><a name=\"vDc8z\"></a></p>\n<h2 id=\"assignment-1-1\"><a href=\"#assignment-1-1\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>用A指令向内存中写入汇编指令，用U指令查看</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596808599-b129a717-4d20-42a3-8823-64dc726440e3.png#averageHue=%23151515&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=236&amp;id=uc9b341b4&amp;name=image.png&amp;originHeight=236&amp;originWidth=374&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6210&amp;status=done&amp;style=none&amp;taskId=uf45debe0-8185-465e-b3c1-03874bac6c7&amp;title=&amp;width=374\" alt=\"image.png\"></p>\n<ol>\n<li>修改CS:IP使其指向代码段</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596896692-f6335ebe-e9b7-44cf-9a38-d686dde7d140.png#averageHue=%230a0a0a&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=162&amp;id=u325eac60&amp;name=image.png&amp;originHeight=162&amp;originWidth=577&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4064&amp;status=done&amp;style=none&amp;taskId=uaa5719c7-c665-4f9e-baa5-b5de2b24fc8&amp;title=&amp;width=577\" alt=\"image.png\">、</p>\n<ol>\n<li>t命令逐步执行指令后查看AX、BX、SP寄存器内容</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673597028389-791ccf84-0268-4f23-976f-53e6ecd97b36.png#averageHue=%23121212&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=374&amp;id=ueb563e3c&amp;name=image.png&amp;originHeight=374&amp;originWidth=635&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15302&amp;status=done&amp;style=none&amp;taskId=u24406e7c-e085-4926-bf36-d7ff7eeb06a&amp;title=&amp;width=635\" alt=\"image.png\"><br><a name=\"NB9fg\"></a></p>\n<h2 id=\"assignment-2-1\"><a href=\"#assignment-2-1\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><p>在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）</p>\n<hr>\n<p><a name=\"jpe3I\"></a></p>\n<h1 id=\"实验3-编程、编译、链接、跟踪\"><a href=\"#实验3-编程、编译、链接、跟踪\" class=\"headerlink\" title=\"实验3 编程、编译、链接、跟踪\"></a>实验3 编程、编译、链接、跟踪</h1><p><a name=\"QMUAH\"></a></p>\n<h2 id=\"assignment-1-2\"><a href=\"#assignment-1-2\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>编译链接生成可执行文件</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673681789903-cb9f13be-b044-4c3f-be1d-8fa401195306.png#averageHue=%230b0b0b&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=328&amp;id=ufc540080&amp;name=image.png&amp;originHeight=328&amp;originWidth=524&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8289&amp;status=done&amp;style=none&amp;taskId=uaf6acc9d-3a30-400a-b361-0bea1d87366&amp;title=&amp;width=524\" alt=\"image.png\"><br><a name=\"bm7kI\"></a></p>\n<h2 id=\"assignment-2-2\"><a href=\"#assignment-2-2\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li>debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为$DS=075C$，则PSP的地址为$075C:0$，程序的地址为$076C:0\\;(075C+10:0)$,$CS:IP = 076C:0000$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682350829-98451696-0d75-4414-87c5-b527b5c96169.png#averageHue=%23111111&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=90&amp;id=u24027707&amp;name=image.png&amp;originHeight=90&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3436&amp;status=done&amp;style=none&amp;taskId=u88d9a7fb-f08c-4035-82ab-48a67509d8f&amp;title=&amp;width=583\" alt=\"image.png\"></p>\n<ol>\n<li>跟踪程序执行过程</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682565168-917f19d2-8e0c-44ab-84e5-453c301bcda0.png#averageHue=%23111111&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=378&amp;id=u739eac5d&amp;name=image.png&amp;originHeight=378&amp;originWidth=593&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13977&amp;status=done&amp;style=none&amp;taskId=u7a4cf037-0141-418c-a6bc-3a455f22fa1&amp;title=&amp;width=593\" alt=\"image.png\"><br>用P命令执行<code>INT 21</code><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682678668-4d6f6ba6-a61b-408a-8aa9-f84fdd1abc8a.png#averageHue=%230d0d0d&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=386&amp;id=ue3d6f0ce&amp;name=image.png&amp;originHeight=386&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12637&amp;status=done&amp;style=none&amp;taskId=ud602a7a4-6c24-495c-b269-66ce57ddba3&amp;title=&amp;width=620\" alt=\"image.png\"><br><a name=\"fqp3r\"></a></p>\n<h2 id=\"assignment-3-1\"><a href=\"#assignment-3-1\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li>查看PSP的内容</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682886059-386e1af8-2b73-480f-92b1-d2ea01cce40a.png#averageHue=%23161616&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=175&amp;id=ueb72f5b4&amp;name=image.png&amp;originHeight=175&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6346&amp;status=done&amp;style=none&amp;taskId=ufec3ae9d-8d07-4ba6-ae47-78454c6ed61&amp;title=&amp;width=625\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"eTiIA\"></a></p>\n<h1 id=\"实验4-bx-和loop的使用\"><a href=\"#实验4-bx-和loop的使用\" class=\"headerlink\" title=\"实验4 [bx]和loop的使用\"></a>实验4 [bx]和loop的使用</h1><p><a name=\"Ypsn2\"></a></p>\n<h2 id=\"assignment-1-3\"><a href=\"#assignment-1-3\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>编写源程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0020H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov dx, 0</span><br><span class=\"line\">mov cx, 64</span><br><span class=\"line\"></span><br><span class=\"line\">s: </span><br><span class=\"line\">mov [bx],dx</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">inc dx</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00h </span><br><span class=\"line\">int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译，链接生成可执行文件</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673769654198-dcf5a11b-b298-4d67-ac52-e6412baa7953.png#averageHue=%230a0a0a&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=308&amp;id=ucb1b0e3f&amp;name=image.png&amp;originHeight=308&amp;originWidth=563&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9162&amp;status=done&amp;style=none&amp;taskId=ud2798294-b700-4d36-9278-b89b6f31b7e&amp;title=&amp;width=563\" alt=\"image.png\"></p>\n<ol>\n<li>查看载入内存的程序，可以看见标签s已被替换为地址$076C:000E$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770040980-f6175097-5e41-41f0-a0d4-ed6dcc9e2d26.png#averageHue=%230f0f0f&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=257&amp;id=ub7d89c02&amp;name=image.png&amp;originHeight=257&amp;originWidth=601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9471&amp;status=done&amp;style=none&amp;taskId=u76baa400-787b-4ed1-b282-488abb7c243&amp;title=&amp;width=601\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，验证结果，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770269260-0b535c86-7318-4bea-9b9b-151df8786503.png#averageHue=%23151515&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=144&amp;id=u9760e10a&amp;name=image.png&amp;originHeight=144&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4621&amp;status=done&amp;style=none&amp;taskId=u407ff41a-3998-40b9-80e2-b904a9486e8&amp;title=&amp;width=480\" alt=\"image.png\"><br><a name=\"q95Oy\"></a></p>\n<h2 id=\"assignment-2-3\"><a href=\"#assignment-2-3\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li><p>编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0020H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 64</span><br><span class=\"line\"></span><br><span class=\"line\">s: </span><br><span class=\"line\">mov [bx],bx</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00h </span><br><span class=\"line\">int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其它步骤与assigment 1一致，验证结果，正确</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673771416582-e853218d-46c6-4bf8-98d6-cacae4200dbb.png#averageHue=%231a1a1a&amp;clientId=u7cc11769-d150-4&amp;from=paste&amp;height=359&amp;id=u85d074a9&amp;name=image.png&amp;originHeight=373&amp;originWidth=490&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9679&amp;status=done&amp;style=none&amp;taskId=uca7996c4-5515-4485-9bd2-5bed6cf48b4&amp;title=&amp;width=472\" alt=\"image.png\"><br><a name=\"b3BKL\"></a></p>\n<h2 id=\"assignment-3-2\"><a href=\"#assignment-3-2\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li>复制的是什么：复制程序的第一条指令<code>mov ax,cs</code>到 <code>loop s</code> 指令至内存地址$0020:0000$处</li>\n<li>如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在<code>mov cx,_____</code> 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：$076C:0000 \\to 076C:0015$，共$16H\\,(23D)$个字节,因此第二个空应该填入$16H$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673774640766-de55642e-4594-4add-9f75-ac17f9cf3628.png#averageHue=%230d0d0d&amp;clientId=u7cc11769-d150-4&amp;from=paste&amp;height=282&amp;id=u704b4ac0&amp;name=image.png&amp;originHeight=282&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9580&amp;status=done&amp;style=none&amp;taskId=u46b6c23e-98fc-45b4-ad17-7f7d7bef327&amp;title=&amp;width=616\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"l6DRo\"></a></p>\n<h1 id=\"实验5-编写、调试具有多个段的程序\"><a href=\"#实验5-编写、调试具有多个段的程序\" class=\"headerlink\" title=\"实验5 编写、调试具有多个段的程序\"></a>实验5 编写、调试具有多个段的程序</h1><p><a name=\"y07m5\"></a></p>\n<h2 id=\"assignment-1-4\"><a href=\"#assignment-1-4\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>将程序载入内存后查看，可知data段段地址为$076C$, stack段段地址为$076D$，code段段地址为$076E$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877104816-d24fcee5-293b-4965-a116-55b74e84812c.png#averageHue=%23101010&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=266&amp;id=u68a1fe4a&amp;name=image.png&amp;originHeight=266&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10189&amp;status=done&amp;style=none&amp;taskId=u25c1d019-e4f1-4cb3-9fef-a5363cacec8&amp;title=&amp;width=619\" alt=\"image.png\"></p>\n<ol>\n<li>Q1：<code>G 001D</code>执行程序至程序返回前，用U命令查看data段内容: $0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H$，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877337524-5a528fcf-a7ec-47a7-ba04-6014616d76ff.png#averageHue=%231a1a1a&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=51&amp;id=u84a23991&amp;name=image.png&amp;originHeight=51&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1917&amp;status=done&amp;style=none&amp;taskId=u5609cee2-98bd-479e-9a89-84510ea0a9d&amp;title=&amp;width=480\" alt=\"image.png\"></p>\n<ol>\n<li>Q2：R命令查看各个段寄存器的值  $\\to \\;CS:076E$、 $DS:076C$、$SS:076D$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877858110-72e7472f-1574-4c88-ae28-a064f40894e4.png#averageHue=%23131313&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=73&amp;id=u1f2d1ce2&amp;name=image.png&amp;originHeight=73&amp;originWidth=592&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3486&amp;status=done&amp;style=none&amp;taskId=ub88918a8-2d91-4abe-b21e-299699ae7ce&amp;title=&amp;width=592\" alt=\"image.png\"></p>\n<ol>\n<li><p>Q3：data段和stack段分别占16个字节，因此设code段段地址为$X$，那么stack段段地址为$X-1H$，data段段地址为$X-2H$（做了assignment2后可以发现这里说法并不准确）<br><a name=\"qSFne\"></a></p>\n<h2 id=\"assignment-2-4\"><a href=\"#assignment-2-4\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2></li>\n<li><p>步骤与assigment1 完全一致</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878358257-7f67627a-48a8-45cf-bc4a-1f51e9552faa.png#averageHue=%230f0f0f&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=265&amp;id=u246ed639&amp;name=image.png&amp;originHeight=265&amp;originWidth=615&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=9903&amp;status=done&amp;style=none&amp;taskId=ud7500b3a-6b24-43c1-8498-3e220eabeef&amp;title=%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E5%90%8E%E7%94%A8U%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%90%84%E4%B8%AA%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&amp;width=615\" alt=\"image.png\" title=\"源程序载入内存后用U命令查看，发现各个段的地址与assignment1完全一致\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878450151-f2a27665-630b-4784-9a07-7c364c930469.png#averageHue=%23111111&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=84&amp;id=u67d44730&amp;name=image.png&amp;originHeight=84&amp;originWidth=582&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3313&amp;status=done&amp;style=none&amp;taskId=u45570d21-23d5-4112-8fa2-e8d2f41ad8a&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D&amp;width=582\" alt=\"image.png\" title=\"执行程序至程序返回前\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878510541-e58f6906-dc84-4df0-a6a2-59cfdf0b4a07.png#averageHue=%231a1a1a&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=54&amp;id=u68b4b398&amp;name=image.png&amp;originHeight=54&amp;originWidth=504&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=2010&amp;status=done&amp;style=none&amp;taskId=u823673f9-a9eb-4ebf-a4ee-ae34390d952&amp;title=%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%80%E8%87%B4%EF%BC%8C%E6%9C%AA%E6%94%B9%E5%8F%98&amp;width=504\" alt=\"image.png\" title=\"查看data段数据，与源程序一致，未改变\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878562565-32d00b48-a53b-4868-916e-9e7ddb4a279d.png#averageHue=%23131313&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=72&amp;id=udc9f18e6&amp;name=image.png&amp;originHeight=72&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3334&amp;status=done&amp;style=none&amp;taskId=uf3897f64-0600-409f-903a-e0c60d2a195&amp;title=%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%EF%BC%8C%E5%90%84%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&amp;width=598\" alt=\"image.png\" title=\"查看寄存器内容，各段寄存器内容与assignment1完全一致\"></p>\n<ol>\n<li><p>得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍<br><a name=\"AiceH\"></a></p>\n<h2 id=\"assignment-3-3\"><a href=\"#assignment-3-3\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2></li>\n<li><p>步骤与assignment1完全一致</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879121558-74eaedb2-acd9-4a9c-a318-e028bba49db2.png#averageHue=%23101010&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=264&amp;id=u5b46f0b2&amp;name=image.png&amp;originHeight=264&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=9249&amp;status=done&amp;style=none&amp;taskId=uab9b0f8d-e010-40c9-ba7f-3de6b6e1d63&amp;title=%E8%B5%B7%E5%A7%8B%E6%AE%B5%E4%B8%BAcode%E6%AE%B5%20%28076C%29%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9D%80data%E6%AE%B5%28076F%29%E5%92%8Cstack%E6%AE%B5%280770%29&amp;width=583\" alt=\"image.png\" title=\"起始段为code段 (076C)，后面跟着data段(076F)和stack段(0770)\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879373761-d05b59a9-6591-4c25-8033-e83698bff61e.png#averageHue=%23171717&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=294&amp;id=u7e2149b7&amp;name=image.png&amp;originHeight=294&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=10607&amp;status=done&amp;style=none&amp;taskId=u25c23b4d-250b-45e7-aa47-be84b0e1458&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D%EF%BC%8C%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E5%86%85%E5%AE%B9%E5%92%8C%E5%90%84%E4%B8%AA%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC&amp;width=625\" alt=\"image.png\" title=\"执行程序至程序返回前，查看data段内容和各个段寄存器的值\"><br>2， 设code段段地址为$X$，那么data段段地址为$X+3H$，stack段段地址为$X+4H$<br><a name=\"NxsNH\"></a></p>\n<h2 id=\"assignment-4-1\"><a href=\"#assignment-4-1\" class=\"headerlink\" title=\"assignment 4\"></a>assignment 4</h2><p>如果去掉通知编译器程序的入口的<code>end start</code>语句，那么唯一可正确运行的是起始段为code段的程序3<br><a name=\"oVwXx\"></a></p>\n<h2 id=\"assignment-5\"><a href=\"#assignment-5\" class=\"headerlink\" title=\"assignment 5\"></a>assignment 5</h2><ol>\n<li><p>编写源程序，注意在将段地址写入$DS$时，要借助一个寄存器充当介质，因为立即数无法直接写入$DS$</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">a segment </span><br><span class=\"line\">db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">a ends</span><br><span class=\"line\"></span><br><span class=\"line\">b segment</span><br><span class=\"line\">db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b ends</span><br><span class=\"line\"></span><br><span class=\"line\">c segment </span><br><span class=\"line\">db 0,0,0,0,0,0,0,0</span><br><span class=\"line\">c ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov dx, a</span><br><span class=\"line\">mov ds,dx</span><br><span class=\"line\">mov ax, [bx]</span><br><span class=\"line\">mov dx, b</span><br><span class=\"line\">mov ds,dx</span><br><span class=\"line\">add ax, [bx]</span><br><span class=\"line\">mov dx, c</span><br><span class=\"line\">mov ds,dx</span><br><span class=\"line\">mov [bx], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax,4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用debug跟踪程序，可以看到a段段地址：$076C$、b段段地址：$076D$、c段段地址：$076E$</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882442409-a3ef513e-eb43-4f18-abf5-ea6f262cc3f6.png#averageHue=%230e0e0e&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=333&amp;id=u80ddd30c&amp;name=image.png&amp;originHeight=333&amp;originWidth=603&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11543&amp;status=done&amp;style=none&amp;taskId=u0f76c72f-ed96-431c-8d71-352a3ca1f86&amp;title=&amp;width=603\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，查看c段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882790995-352f2b4b-203d-458a-b5a2-878acfd29335.png#averageHue=%231e1e1e&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=59&amp;id=uc023038f&amp;name=image.png&amp;originHeight=59&amp;originWidth=498&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=2633&amp;status=done&amp;style=none&amp;taskId=ucae589f2-04bc-4644-899d-6fdbd17e620&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%89%8D%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&amp;width=498\" alt=\"image.png\" title=\"执行程序前，C段内容\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882830219-1912f93e-456b-47b1-b06a-32816e308e07.png#averageHue=%23171717&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=95&amp;id=ud9a53aa1&amp;name=image.png&amp;originHeight=95&amp;originWidth=479&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3576&amp;status=done&amp;style=none&amp;taskId=udb82a728-cd51-436e-9481-a8a6f072f71&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&amp;width=479\" alt=\"image.png\" title=\"执行程序后，C段内容\"><br><a name=\"azFBM\"></a></p>\n<h2 id=\"assignment-6\"><a href=\"#assignment-6\" class=\"headerlink\" title=\"assignment 6\"></a>assignment 6</h2><ol>\n<li><p>编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">a segment</span><br><span class=\"line\">dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span><br><span class=\"line\">a ends</span><br><span class=\"line\"></span><br><span class=\"line\">b segment </span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">b ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment </span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, a</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, b </span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 0010H</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\">s:</span><br><span class=\"line\">push [bx]</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用debug跟踪程序，可以看到a段段地址： $076C$ 、 b段段地址：$076E$、code段段地址：$076F$</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885232599-a5e6bf92-ae97-421b-ad5b-904f427aef76.png#averageHue=%230f0f0f&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=296&amp;id=ub52c7fd8&amp;name=image.png&amp;originHeight=296&amp;originWidth=590&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10267&amp;status=done&amp;style=none&amp;taskId=ub78885e9-2d92-486e-abce-ac5186f563b&amp;title=&amp;width=590\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，查看b段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885271367-eddf0cc8-98aa-4fe8-a38f-a014ed5f8179.png#averageHue=%231b1b1b&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=228&amp;id=ud387c905&amp;name=image.png&amp;originHeight=228&amp;originWidth=525&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10970&amp;status=done&amp;style=none&amp;taskId=u9df34674-6438-4f64-8810-2056308e5b5&amp;title=&amp;width=525\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"O7BgM\"></a></p>\n<h1 id=\"实验6-实践课程中的程序\"><a href=\"#实验6-实践课程中的程序\" class=\"headerlink\" title=\"实验6 实践课程中的程序\"></a>实验6 实践课程中的程序</h1><p><a name=\"dyxQS\"></a></p>\n<h2 id=\"assignment-1-5\"><a href=\"#assignment-1-5\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment </span><br><span class=\"line\">db &#x27;ibm             &#x27;</span><br><span class=\"line\">db &#x27;dec             &#x27;</span><br><span class=\"line\">db &#x27;dos             &#x27;</span><br><span class=\"line\">db &#x27;vax             &#x27;</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">stacksg segment</span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stacksg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stacksg</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 10H</span><br><span class=\"line\">mov ax, datasg</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">s0:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov cx, 3</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov al, [bx+si]</span><br><span class=\"line\">and al, 11011111B</span><br><span class=\"line\">mov [bx+si], al</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s </span><br><span class=\"line\"></span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>跟踪程序，查看data段内容</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954476992-988989f0-7ba5-4132-8b53-011e5cfe1ce7.png#averageHue=%23111111&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=332&amp;id=u6d512701&amp;name=image.png&amp;originHeight=332&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11651&amp;status=done&amp;style=none&amp;taskId=uac27a62a-e7e2-4573-8364-30a015779f0&amp;title=&amp;width=619\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序后，查看data段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954644257-b63d5af0-f266-4057-b1e1-c513e09c9298.png#averageHue=%23151515&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=114&amp;id=u73878512&amp;name=image.png&amp;originHeight=114&amp;originWidth=574&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4009&amp;status=done&amp;style=none&amp;taskId=u92fc65de-f6f5-42c1-84b2-350c1e4d948&amp;title=&amp;width=574\" alt=\"image.png\"><br><a name=\"pHbEJ\"></a></p>\n<h2 id=\"assignment-2-5\"><a href=\"#assignment-2-5\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li><p>编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class=\"line\"></span><br><span class=\"line\">stacksg segment</span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stacksg ends</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment </span><br><span class=\"line\">db &#x27;1. display      &#x27;</span><br><span class=\"line\">db &#x27;2. brows        &#x27;</span><br><span class=\"line\">db &#x27;3. replace      &#x27;</span><br><span class=\"line\">db &#x27;4. modify       &#x27;</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stacksg</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 10H </span><br><span class=\"line\">mov ax, datasg</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">s0:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">s: </span><br><span class=\"line\">mov al, [bx+3+si]</span><br><span class=\"line\">and al, 11011111B</span><br><span class=\"line\">mov [bx+3+si], al</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>跟踪程序，查看data段内容</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955793129-198d15a6-56f1-4375-a4c1-fa6d84e6aa7c.png#averageHue=%23111111&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=311&amp;id=u5ce4b731&amp;name=image.png&amp;originHeight=311&amp;originWidth=623&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12680&amp;status=done&amp;style=none&amp;taskId=u132e706b-1ed7-4582-becb-0f6cd930428&amp;title=&amp;width=623\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序，查看data段内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955864652-707fd6d7-d65d-4be6-b3f9-bbcbbc27484b.png#averageHue=%23151515&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=110&amp;id=ubb174b39&amp;name=image.png&amp;originHeight=110&amp;originWidth=618&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5260&amp;status=done&amp;style=none&amp;taskId=u786ee51b-5382-4915-8eb1-9feeb54fdba&amp;title=&amp;width=618\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"MJU1z\"></a></p>\n<h1 id=\"实验7-寻址方式在结构化数据访问中的应用\"><a href=\"#实验7-寻址方式在结构化数据访问中的应用\" class=\"headerlink\" title=\"实验7 寻址方式在结构化数据访问中的应用\"></a>实验7 寻址方式在结构化数据访问中的应用</h1><ol>\n<li><p>编写源程序，用<code>word ptr / byte ptr</code>指定内存单元大小主要应用在<code>div</code>指令或用于向内存写入立即数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">db &#x27;1975&#x27;,&#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class=\"line\">db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;</span><br><span class=\"line\">db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">dd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514</span><br><span class=\"line\">dd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000</span><br><span class=\"line\"></span><br><span class=\"line\">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226</span><br><span class=\"line\">dw 11542,14430,15257,17800</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">table segment</span><br><span class=\"line\">db 21 dup (&#x27;year summ ne ?? &#x27;)</span><br><span class=\"line\">table ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack ;0776C</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 10H</span><br><span class=\"line\">mov ax, data ; 076D</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov ax, table ; 077b</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx,0</span><br><span class=\"line\">mov si,0</span><br><span class=\"line\">mov cx,21</span><br><span class=\"line\"></span><br><span class=\"line\">year:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">char:</span><br><span class=\"line\">mov al, es:[si]</span><br><span class=\"line\">mov [bx+di], al</span><br><span class=\"line\">inc di</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop char</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop year</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 21</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">income:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 2</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">dwInt:</span><br><span class=\"line\">mov ax, es:[si]</span><br><span class=\"line\">mov [bx].5[di], ax</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop dwInt</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop income</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 21</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">staff:</span><br><span class=\"line\">mov ax, es:[si]</span><br><span class=\"line\">mov [10+bx], ax</span><br><span class=\"line\">add si, 2;</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop staff</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 21</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">average:</span><br><span class=\"line\">mov dx, [bx+7]</span><br><span class=\"line\">mov ax, [bx+5]</span><br><span class=\"line\">div word ptr [bx+0AH]</span><br><span class=\"line\">mov [bx+0Dh], ax</span><br><span class=\"line\">add bx, 10H</span><br><span class=\"line\">loop average</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看原始table段的内容</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054412418-905eb553-63b9-4352-8fd3-87d9c57ec955.png#averageHue=%231d1d1d&amp;clientId=u59b02d03-003e-4&amp;from=paste&amp;height=312&amp;id=ue1c1140e&amp;name=image.png&amp;originHeight=312&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19887&amp;status=done&amp;style=none&amp;taskId=ue6fc1e9d-9b84-43c0-852e-a69d953b492&amp;title=&amp;width=640\" alt=\"image.png\"></p>\n<ol>\n<li>执行程序后，查看table段的内容，正确</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054465034-493bafb1-d935-4da9-b3d0-07b0bdd54911.png#averageHue=%231b1b1b&amp;clientId=u59b02d03-003e-4&amp;from=paste&amp;height=378&amp;id=u98d88789&amp;name=image.png&amp;originHeight=378&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=21611&amp;status=done&amp;style=none&amp;taskId=u95e0d8ba-0b80-4cd2-9a0a-a3aaec2f835&amp;title=&amp;width=630\" alt=\"image.png\"><br><a name=\"wI3bu\"></a></p>\n<h1 id=\"实验8-分析一个奇怪的程序\"><a href=\"#实验8-分析一个奇怪的程序\" class=\"headerlink\" title=\"实验8 分析一个奇怪的程序\"></a>实验8 分析一个奇怪的程序</h1><ol>\n<li>程序从$start$入口处开始执行，一个<code>nop</code>指令占一个字节并表示No operation，此处用了两个<code>nop</code>指令的目的是在$s$处预留两个字节的空间，程序执行<code>mov cs:[di], ax</code>之后$s$处的两个字节被试图写入<code>jmp short s1</code>，接着程序向下执行<code>jmp short s</code>使得程序跳转回$s$处开始执行。</li>\n<li><code>jmp short s1</code>到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从$s2$跳转到$s1$，即从$s2$处的jmp指令的下一指令<code>nop</code>$(076C:0022)$跳转到$s1$处的<code>mov ax, 0</code>$(076C:0018)$，因为<code>jmp short 标号</code>是依据位移进行转移的指令，而此处位移大小为$0022H-0018H =-10D(F6H)$，所以$s$处的<code>jmp short s</code>指令的机器码为<code>EBF6</code>（刚好占两个字节，因此可以被正确写入$s$处）</li>\n<li>执行$s$处的跳转指令，使得$IP = IP+(-10)$,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为<code>mov ax, 4c00H</code>$(000AH-0010H=0000H)$，程序从此处开始向下执行，最终可以正确退出</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674306714709-54439679-a96b-496d-97b1-de0f2c3abf77.png#averageHue=%230d0d0d&amp;clientId=u6f9c44da-f55a-4&amp;from=paste&amp;height=383&amp;id=u78c30e80&amp;name=image.png&amp;originHeight=383&amp;originWidth=595&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10505&amp;status=done&amp;style=none&amp;taskId=uae9cedf9-248f-4122-b32a-b23020dad5f&amp;title=&amp;width=595\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674308784974-d476fbd5-6642-45a7-8e5a-a3db1e5ed646.png#averageHue=%230a0a0a&amp;clientId=u6f9c44da-f55a-4&amp;from=paste&amp;height=150&amp;id=ua98d7cca&amp;name=image.png&amp;originHeight=150&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3506&amp;status=done&amp;style=none&amp;taskId=ufcfb45ef-5abd-4191-9c60-6ca3d7ac8c6&amp;title=&amp;width=640\" alt=\"image.png\"><br><a name=\"lZyJr\"></a></p>\n<h1 id=\"实验9-根据材料编程\"><a href=\"#实验9-根据材料编程\" class=\"headerlink\" title=\"实验9 根据材料编程\"></a>实验9 根据材料编程</h1><ol>\n<li><p>编写源程序：最开始我试图用<code>mov address，data</code>的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据<code>welcome to masm!</code>，利用寄存器$ax$作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">db &#x27;welcome to masm!&#x27;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start: </span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">mov si, 1824</span><br><span class=\"line\">mov cx, 10H</span><br><span class=\"line\">s0:</span><br><span class=\"line\">mov ah, 82H</span><br><span class=\"line\">mov al, [bx]</span><br><span class=\"line\">mov es:[si], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, 0 </span><br><span class=\"line\">mov si, 1984</span><br><span class=\"line\">mov cx, 10H</span><br><span class=\"line\">s1:</span><br><span class=\"line\">mov ah, 0A4H</span><br><span class=\"line\">mov al, [bx]</span><br><span class=\"line\">mov es:[si], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, 0 </span><br><span class=\"line\">mov si, 2144</span><br><span class=\"line\">mov cx, 10H</span><br><span class=\"line\">s2:</span><br><span class=\"line\">mov ah, 11110001B</span><br><span class=\"line\">mov al, [bx]</span><br><span class=\"line\">mov es:[si], ax</span><br><span class=\"line\">inc bx</span><br><span class=\"line\">add si, 2</span><br><span class=\"line\">loop s2</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4c00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最终效果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674447541217-19494cef-6da4-4fd3-b28c-6ad18c755471.png#averageHue=%23080808&amp;clientId=u2be92af7-bf87-4&amp;from=paste&amp;height=400&amp;id=u7d46ece7&amp;name=image.png&amp;originHeight=400&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8808&amp;status=done&amp;style=none&amp;taskId=u5b2b0b44-a96d-458a-878e-8f9b74b9697&amp;title=&amp;width=640\" alt=\"image.png\"></p>\n<p><a name=\"zPzcC\"></a></p>\n<h1 id=\"实验10-编写子程序\"><a href=\"#实验10-编写子程序\" class=\"headerlink\" title=\"实验10 编写子程序\"></a>实验10 编写子程序</h1><p><a name=\"Z9mXL\"></a></p>\n<h2 id=\"assignment-1-6\"><a href=\"#assignment-1-6\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（<strong>注意入栈顺序与出栈顺序相反</strong>）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">data segment</span><br><span class=\"line\">db &quot;welcome to masm!&quot;, 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov dh, 8</span><br><span class=\"line\">mov dl, 3</span><br><span class=\"line\">mov cl, 2</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">call show_str</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">show_str:</span><br><span class=\"line\">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 160 ; 设置指定打印位置</span><br><span class=\"line\">inc dh ; 行数从0开始</span><br><span class=\"line\">mul dh ; 8位乘法，结果存储在ax中</span><br><span class=\"line\">mov bx, ax</span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">mul dl</span><br><span class=\"line\">add bx, ax</span><br><span class=\"line\">mov ah, cl</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">mov cl, [si] ; 设置cx</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz ok ;判断字符串是否结束</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, cl ; 设置字符属性和值</span><br><span class=\"line\">mov es:[bx],ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">jmp print</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret </span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1674959885930-a6c4181a-e6a1-44cb-9ec8-cc5013b1314e.png#averageHue=%23141414&amp;clientId=ue48ee0fc-f4a6-4&amp;from=paste&amp;height=427&amp;id=u8c981b1c&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12224&amp;status=done&amp;style=none&amp;taskId=u3854a69e-62d2-4b34-89c5-98dd0c0fb70&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"gCr3l\"></a></p>\n<h2 id=\"assignment-2-6\"><a href=\"#assignment-2-6\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li><p>编写源程序，利用除法溢出公式 </p>\n<pre><code>            $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$&lt;br /&gt;该公式的基本思想是将可能发生除法溢出的32位除法$X/n$，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法&lt;br /&gt;$(H/n)*65536 + (L/n)$&lt;br /&gt;**商（32位）：**&lt;br /&gt;高十六位为$int(H/2)*65536$,低十六为$int([rem(H/n)*65536+L]/n)$&lt;br /&gt;**余数（16位）：**&lt;br /&gt;$rem([rem(H/n)*65536+L]/n)$&lt;br /&gt;（注：对这个公式的理解有限）\n</code></pre><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">mov ax, 4240H</span><br><span class=\"line\">mov dx, 000FH</span><br><span class=\"line\">mov cx, 0AH</span><br><span class=\"line\">call divdw</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">divdw:</span><br><span class=\"line\">push bx</span><br><span class=\"line\"></span><br><span class=\"line\">mov bx, ax ; 暂存L</span><br><span class=\"line\">mov ax, dx ; H/N</span><br><span class=\"line\">mov dx, 0</span><br><span class=\"line\">div cx ; int(H/N)在ax中，rem(H/N)在dx中</span><br><span class=\"line\"></span><br><span class=\"line\">push ax ; 暂存int(H/N)，除数</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, bx; dx and ax constitute rem(H/N)*65535+L</span><br><span class=\"line\">div cx ; ax store the result</span><br><span class=\"line\">mov cx, dx</span><br><span class=\"line\"></span><br><span class=\"line\">pop dx ; int(H/N)</span><br><span class=\"line\"></span><br><span class=\"line\">pop bx</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果正确</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675050216892-a6c856a5-19e3-42a9-9dae-62052e8d077c.png#averageHue=%23191919&amp;clientId=u68f84982-1dce-4&amp;from=paste&amp;height=427&amp;id=u69ef2d14&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=16724&amp;status=done&amp;style=none&amp;taskId=u6de69850-12af-46ff-80ef-d1f8f4817f4&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"wHNVn\"></a></p>\n<h2 id=\"assignment-3-4\"><a href=\"#assignment-3-4\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><ol>\n<li><p>编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">db 10 dup(0)</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, 12666</span><br><span class=\"line\">mov bx, data</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov bx, stack</span><br><span class=\"line\">mov ss, bx</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">call dtoc</span><br><span class=\"line\"></span><br><span class=\"line\">mov dh, 8</span><br><span class=\"line\">mov dl, 3</span><br><span class=\"line\">mov cl, 2</span><br><span class=\"line\">call show_str</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">dtoc:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\">push si</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, 0 ; 被除数高16位 置0</span><br><span class=\"line\">mov bx, 10</span><br><span class=\"line\">mov di, 0 ; 字符计数</span><br><span class=\"line\"></span><br><span class=\"line\">divide:</span><br><span class=\"line\">mov cx, ax </span><br><span class=\"line\">jcxz over</span><br><span class=\"line\">inc di</span><br><span class=\"line\">div bx ; 32位除法，商在ax，余数在dx</span><br><span class=\"line\">add dx, 30H</span><br><span class=\"line\">push dx</span><br><span class=\"line\">mov dx, 0</span><br><span class=\"line\">jmp divide</span><br><span class=\"line\"></span><br><span class=\"line\">over:</span><br><span class=\"line\">mov cx, di</span><br><span class=\"line\">move: </span><br><span class=\"line\">pop bx</span><br><span class=\"line\">mov [si], bl</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop move</span><br><span class=\"line\"></span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">show_str:</span><br><span class=\"line\">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 160 ; 设置指定打印位置</span><br><span class=\"line\">inc dh ; 行数从0开始</span><br><span class=\"line\">mul dh ; 8位乘法，结果存储在ax中</span><br><span class=\"line\">mov bx, ax</span><br><span class=\"line\">mov dh, 0</span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">mul dl</span><br><span class=\"line\">add bx, ax</span><br><span class=\"line\">mov ah, cl</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">mov cl, [si] ; 设置cx</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz ok ;判断字符串是否结束</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, cl ; 设置字符属性和值</span><br><span class=\"line\">mov es:[bx],ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">jmp print</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret </span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070403817-35e5aa0f-3d0c-42ab-803a-9d7dbf5bcb8a.png#averageHue=%231f1f1e&amp;clientId=u9270fba6-a6a8-4&amp;from=paste&amp;height=427&amp;id=uc1ace679&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=16905&amp;status=done&amp;style=none&amp;taskId=uf4805ca7-fbac-43eb-a257-f1c820ade31&amp;title=%E6%AD%A3%E7%A1%AE%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%AE%B5&amp;width=642\" alt=\"image.png\" title=\"正确写入数据段\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070685747-6e72ffff-b062-418d-9d09-67596698a4ca.png#averageHue=%23141313&amp;clientId=u9270fba6-a6a8-4&amp;from=paste&amp;height=427&amp;id=ub539738e&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=12534&amp;status=done&amp;style=none&amp;taskId=u448c5569-17ad-4eec-8879-9d56a9e0d67&amp;title=%E6%AD%A3%E7%A1%AE%E6%89%93%E5%8D%B0&amp;width=642\" alt=\"image.png\" title=\"正确打印\"><br><a name=\"ww3wC\"></a></p>\n<h1 id=\"实验11-编写子程序\"><a href=\"#实验11-编写子程序\" class=\"headerlink\" title=\"实验11 编写子程序\"></a>实验11 编写子程序</h1><ol>\n<li><p>编写源程序：主要用到了<code>cmp</code>指令和条件转移指令组合形成的if逻辑</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\">datasg segment</span><br><span class=\"line\">db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">begin:</span><br><span class=\"line\">mov ax, datasg</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">call letterc</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">letterc:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push cx</span><br><span class=\"line\"></span><br><span class=\"line\">Capital:</span><br><span class=\"line\">mov al, [si]</span><br><span class=\"line\">mov cl, al</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz OK</span><br><span class=\"line\">cmp al, 97</span><br><span class=\"line\">jb NO</span><br><span class=\"line\">cmp al, 122</span><br><span class=\"line\">ja NO</span><br><span class=\"line\">and al, 11011111B</span><br><span class=\"line\">mov [si], al\t</span><br><span class=\"line\"></span><br><span class=\"line\">NO:</span><br><span class=\"line\">inc si</span><br><span class=\"line\">jmp short Capital</span><br><span class=\"line\"></span><br><span class=\"line\">OK:</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end begin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142887049-1e6b7958-8779-4745-81f5-c6a536a232ca.png#averageHue=%231d1d1d&amp;clientId=u14a9d0ea-1971-4&amp;from=paste&amp;height=427&amp;id=u9451414e&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=18343&amp;status=done&amp;style=none&amp;taskId=u733f3e2b-82d2-436e-a8de-95b8faa1f07&amp;title=%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81&amp;width=642\" alt=\"image.png\" title=\"初始状态\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142878774-286c5ae3-e961-424a-96db-dae987c9a153.png#averageHue=%23212121&amp;clientId=u14a9d0ea-1971-4&amp;from=paste&amp;height=427&amp;id=ub5c49ec4&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=19861&amp;status=done&amp;style=none&amp;taskId=u7a2a2568-c507-4078-a32b-b75eef2ec62&amp;title=%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99&amp;width=642\" alt=\"image.png\" title=\"全部大写\"><br><a name=\"bk4z5\"></a></p>\n<h1 id=\"实验12-编写0号中断的处理程序\"><a href=\"#实验12-编写0号中断的处理程序\" class=\"headerlink\" title=\"实验12 编写0号中断的处理程序\"></a>实验12 编写0号中断的处理程序</h1><ol>\n<li>编写源程序</li>\n</ol>\n<p>总体来说就3个任务：</p>\n<ul>\n<li>编写中断处理程序 </li>\n<li>复制中断处理程序至内存空闲区域($0000:0200H\\to0000:02FFH$)  </li>\n<li>修改中断向量表（中断处理程序地址入口表）</li>\n</ul>\n<p>注意在用<code>jcxz</code>条件转移指令时，要<code>jmp short</code>回程序开头<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset do0 ; 076C:0028</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset do0end- offset do0; 0034H</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep movsb ; 复制程序到0:200</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[0], 0200H</span><br><span class=\"line\">mov word ptr es:[0+2], 0 ; 修改中断向量表</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">do0:</span><br><span class=\"line\">jmp short do0start</span><br><span class=\"line\">db &quot;divide error&quot;,0 </span><br><span class=\"line\"></span><br><span class=\"line\">do0start:</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 160*12+34*2</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, 202H</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">mov cL, [si]</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">jcxz ok</span><br><span class=\"line\">mov ah, 04h ;red</span><br><span class=\"line\">mov al, cl</span><br><span class=\"line\">mov es:[di], ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add di, 2 </span><br><span class=\"line\">jmp short print</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">do0end: ;005C</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675159533550-89caf027-f6da-4345-aa8c-e03159df600e.png#averageHue=%23141414&amp;clientId=u2ec176e2-9874-4&amp;from=paste&amp;height=427&amp;id=u6679d84b&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12440&amp;status=done&amp;style=none&amp;taskId=u7d87f433-7092-4f23-a3d6-b1339bf6fe9&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"YSdgF\"></a></p>\n<h1 id=\"实验13-编写、应用中断例程\"><a href=\"#实验13-编写、应用中断例程\" class=\"headerlink\" title=\"实验13 编写、应用中断例程\"></a>实验13 编写、应用中断例程</h1><p><a name=\"HHw6N\"></a></p>\n<h2 id=\"assignment-1-7\"><a href=\"#assignment-1-7\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li><p>编写源程序：与lab10-1的show_str基本一致，只需将<code>call-ret</code>更改为 <code>int 7cH - iret</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset print</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset printed - offset print</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep  movsb</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[7cH*4], 0200H</span><br><span class=\"line\">mov word ptr es:[7cH*4+2], 0 </span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">print:</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push dx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 160</span><br><span class=\"line\">inc dh</span><br><span class=\"line\">mul dh ; 160*(10+1) in ax</span><br><span class=\"line\">mov bx, ax</span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">mul dl ; 10*2 in ax</span><br><span class=\"line\">add bx, ax</span><br><span class=\"line\">mov ah, cl</span><br><span class=\"line\"></span><br><span class=\"line\">stPrint:</span><br><span class=\"line\">mov ch, 0</span><br><span class=\"line\">mov cl, [si]</span><br><span class=\"line\">jcxz ok</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, cl</span><br><span class=\"line\">mov es:[bx], ax</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">inc si</span><br><span class=\"line\">jmp short stPrint</span><br><span class=\"line\"></span><br><span class=\"line\">ok:</span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">printed:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675224733068-a783d5cd-5d35-46b5-8032-3c8938e8347a.png#averageHue=%23131313&amp;clientId=u8a54de4a-c425-4&amp;from=paste&amp;height=427&amp;id=u9672685d&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12092&amp;status=done&amp;style=none&amp;taskId=u4599fb35-92fc-4ea1-b9cb-e60668d8629&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"LKaNX\"></a></p>\n<h2 id=\"assignment-2-7\"><a href=\"#assignment-2-7\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h2><ol>\n<li>编写源程序</li>\n</ol>\n<p>用中断例程实现loop指令，主要需要解决三个问题</p>\n<ul>\n<li>怎么取得标号$S$的段地址和偏移地址？</li>\n</ul>\n<p>有一对段地址$CS$和偏移地址$IP$在中断过程时被压入栈，标号的段地址就是该CS，标号           的偏移地址可由该IP加上转移地址(<code>offset s - offset se</code>)得到</p>\n<ul>\n<li>得到$S$的段地址和偏移地址后，如何设置$CS:IP$</li>\n</ul>\n<p>用<code>iret</code>指令：<code>pop IP , pop CS ,  popf</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset lp</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset lped - offset lp</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep  movsb</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[7cH*4], 0200H</span><br><span class=\"line\">mov word ptr es:[7cH*4+2], 0 </span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">lp:</span><br><span class=\"line\">dec cx</span><br><span class=\"line\">jcxz lpret</span><br><span class=\"line\">push bp</span><br><span class=\"line\">mov bp, sp</span><br><span class=\"line\">add [bp+2], bx</span><br><span class=\"line\">lpret:</span><br><span class=\"line\">pop bp</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">lped:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675237825483-f1ed3d6d-00cc-453b-91b3-757823355468.png#averageHue=%23171515&amp;clientId=ub529a018-e1a0-4&amp;from=paste&amp;height=427&amp;id=u272d8fd4&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12787&amp;status=done&amp;style=none&amp;taskId=u38f1e876-6c89-499b-b704-a23609bf566&amp;title=&amp;width=642\" alt=\"image.png\"><br><a name=\"TCCAl\"></a></p>\n<h2 id=\"assignment-3-5\"><a href=\"#assignment-3-5\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">s1: db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class=\"line\">s2: db &#x27;Never let it rest,&#x27;,&#x27;$&#x27; </span><br><span class=\"line\">s3: db &#x27;Till good is better,&#x27;,&#x27;$&#x27;</span><br><span class=\"line\">s4: db &#x27;And better,best.&#x27;, &#x27;$&#x27;</span><br><span class=\"line\">s: dw offset s1, offset s2, offset s3, offset s4 </span><br><span class=\"line\">row: db 2,4,6,8</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs </span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov bx, offset s</span><br><span class=\"line\">mov si, offset row</span><br><span class=\"line\">mov cx, 4</span><br><span class=\"line\">ok:</span><br><span class=\"line\">mov bh, 0 </span><br><span class=\"line\">mov dh, [si]</span><br><span class=\"line\">mov dl, 0</span><br><span class=\"line\">mov ah, 2 ; BIOS中断例程--设置光标</span><br><span class=\"line\">int 10h </span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, [bx]                                           </span><br><span class=\"line\">mov ah, 9 ; DOS中断例程--打印字符串</span><br><span class=\"line\">int 21h</span><br><span class=\"line\">inc si</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop ok</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H; DOS中断例程--程序返回，返回值在al</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p><a name=\"zGspx\"></a></p>\n<h1 id=\"实验14-访问-CMOS-RAM\"><a href=\"#实验14-访问-CMOS-RAM\" class=\"headerlink\" title=\"实验14 访问 CMOS RAM\"></a>实验14 访问 CMOS RAM</h1><ol>\n<li><p>编写源程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">dw 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 9</span><br><span class=\"line\">mov bx, 160*12+36*2</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 8</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 7</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27; &#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 4</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 2</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">mov al, 0</span><br><span class=\"line\">add bx, 6</span><br><span class=\"line\">call GetAscill</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">GetAscill:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push dx</span><br><span class=\"line\"></span><br><span class=\"line\">out 70H, al</span><br><span class=\"line\">in al, 71H</span><br><span class=\"line\"></span><br><span class=\"line\">mov ah, al</span><br><span class=\"line\">mov cl, 4</span><br><span class=\"line\">shr ah, cl</span><br><span class=\"line\">and al, 00001111B</span><br><span class=\"line\"></span><br><span class=\"line\">add ah, 30H</span><br><span class=\"line\">add al, 30H</span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, 0B800H</span><br><span class=\"line\">mov es, dx</span><br><span class=\"line\">mov es:[bx], ah </span><br><span class=\"line\">mov byte ptr es:[bx+1], 02H ; green</span><br><span class=\"line\">mov es:[bx+2], al</span><br><span class=\"line\">mov byte ptr es:[bx+3], 02H</span><br><span class=\"line\"></span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675253920788-8fc4fee5-abeb-4e49-93bf-97e3873b6599.png#averageHue=%23141413&amp;clientId=uf0bf1a62-8c66-4&amp;from=paste&amp;height=388&amp;id=u067d841f&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11685&amp;status=done&amp;style=none&amp;taskId=u21f4afac-9bb2-4466-b21a-1a578f58efb&amp;title=&amp;width=583.6363509863864\" alt=\"image.png\"><br><a name=\"yTwL0\"></a></p>\n<h1 id=\"实验15-安装新的int-9-中断例程\"><a href=\"#实验15-安装新的int-9-中断例程\" class=\"headerlink\" title=\"实验15 安装新的int 9 中断例程\"></a>实验15 安装新的int 9 中断例程</h1><p><a name=\"TIrMX\"></a></p>\n<h2 id=\"前置练习1\"><a href=\"#前置练习1\" class=\"headerlink\" title=\"前置练习1\"></a>前置练习1</h2><p>在屏幕中间依次显示$a\\to z$,按Esc键后改变与颜色</p>\n<ol>\n<li><p>编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把<code>call dword ptr ds:[0]</code>写成了<code>call word ptr ds:[0]</code>，导致整个系统没有正确的int 9中断例程，因此出现了错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">db 64 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">dw 0,0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 40H</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">push es:[9*4]</span><br><span class=\"line\">pop ds:[0]</span><br><span class=\"line\">push es:[9*4+2]</span><br><span class=\"line\">pop ds:[2] ; 保存原int 9中断例程的入口地址</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">mov word ptr es:[9*4], offset int9</span><br><span class=\"line\">mov es:[9*4+2], cs;设置新的入口地址</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es,ax</span><br><span class=\"line\">mov dh, &#x27;a&#x27;</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov es:[160*12+40*2], dh</span><br><span class=\"line\">call delay</span><br><span class=\"line\">inc dh</span><br><span class=\"line\">cmp dh, &#x27;z&#x27;</span><br><span class=\"line\">jna s ; 依次打印a~z</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0 </span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">push ds:[0]</span><br><span class=\"line\">pop es:[9*4]</span><br><span class=\"line\">push ds:[2]</span><br><span class=\"line\">pop es:[9*4+2] ;恢复原int 9中断例程的入口地址</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00h</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">delay:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push dx</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov dx, 10H</span><br><span class=\"line\">se:</span><br><span class=\"line\">sub ax, 1 ; 不能用dec</span><br><span class=\"line\">sbb dx, 0</span><br><span class=\"line\">cmp ax, 0</span><br><span class=\"line\">jne se</span><br><span class=\"line\">cmp dx, 0</span><br><span class=\"line\">jne se</span><br><span class=\"line\"></span><br><span class=\"line\">pop dx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret ; 延时</span><br><span class=\"line\"></span><br><span class=\"line\">int9:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push es</span><br><span class=\"line\">in al, 60H</span><br><span class=\"line\"></span><br><span class=\"line\">pushf</span><br><span class=\"line\">call dword ptr ds:[0]</span><br><span class=\"line\"></span><br><span class=\"line\">cmp al, 01H</span><br><span class=\"line\">jne int9ret</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">inc byte ptr es:[160*12+40*2+1] ; 修改字符属性</span><br><span class=\"line\"></span><br><span class=\"line\">int9ret:</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319548168-77f7b5a6-54bb-4526-b234-adb0e561004e.png#averageHue=%237ab44c&amp;clientId=u17647ab4-03d9-4&amp;from=paste&amp;height=388&amp;id=u49a1ed0a&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=13571&amp;status=done&amp;style=none&amp;taskId=u61859af5-760b-45d0-8b8d-c62aa3a3245&amp;title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B21&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按Esc改变颜色1\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319563355-013b242f-ab37-4a8f-a956-6222d6e1847c.png#averageHue=%238dd756&amp;clientId=u17647ab4-03d9-4&amp;from=paste&amp;height=388&amp;id=u9a049927&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=13830&amp;status=done&amp;style=none&amp;taskId=u52c59e7d-a185-4177-8537-a05965e054e&amp;title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B22&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按Esc改变颜色2\"><br><a name=\"vlBjq\"></a></p>\n<h2 id=\"前置练习2\"><a href=\"#前置练习2\" class=\"headerlink\" title=\"前置练习2\"></a>前置练习2</h2><p>在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理</p>\n<ol>\n<li><p>编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在$0:0200 \\to 0:0203$,可在新int 9中断例程中通过<code>cs:[200H]</code>访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">db 32 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0204H</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset int9</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset int9ed - offset int9</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep movsb; 安装</span><br><span class=\"line\"></span><br><span class=\"line\">push es:[9*4]</span><br><span class=\"line\">pop es:[200H]</span><br><span class=\"line\">push es:[9*4+2]</span><br><span class=\"line\">pop es:[202H] ; 保存原int 9入口地址</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">mov word ptr es:[9*4], 204H</span><br><span class=\"line\">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">int9:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">in al, 60H</span><br><span class=\"line\"></span><br><span class=\"line\">pushf</span><br><span class=\"line\">call dword ptr cs:[200H] ; 调用原int 9</span><br><span class=\"line\"></span><br><span class=\"line\">cmp al, 3BH</span><br><span class=\"line\">jne int9ret</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 1</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">s:</span><br><span class=\"line\">inc byte ptr es:[di]</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">int9ret:</span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int9ed:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322759364-2785ad21-17c7-4499-b1a3-fe6726975b02.png#averageHue=%230d0d0d&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u4340ef70&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=12813&amp;status=done&amp;style=none&amp;taskId=uc1c9e4ff-ae09-465d-a787-aba159b8b98&amp;title=%E6%8C%89%E4%B8%8BF1%201&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按下F1 1\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322817620-9b94c323-5bcb-4465-ba63-7a2721ba4d46.png#averageHue=%23aeaeae&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u019e66f9&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8862&amp;status=done&amp;style=none&amp;taskId=ue0c4ae51-d75f-4e13-8d7c-a26ee51e20f&amp;title=%E6%8C%89%E4%B8%8BF1%202&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按下F1 2\"><br><a name=\"XyIu0\"></a></p>\n<h2 id=\"assignment-1-8\"><a href=\"#assignment-1-8\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h2><ol>\n<li>编写源程序</li>\n</ol>\n<p>与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码<code>cmp aL, 1EH+80H</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">db 32 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, stack</span><br><span class=\"line\">mov ss, ax</span><br><span class=\"line\">mov sp, 20H</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0204H</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset int9</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset int9ed - offset int9</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep movsb; 安装</span><br><span class=\"line\"></span><br><span class=\"line\">push es:[9*4]</span><br><span class=\"line\">pop es:[200H]</span><br><span class=\"line\">push es:[9*4+2]</span><br><span class=\"line\">pop es:[202H] ; 保存原int 9入口地址</span><br><span class=\"line\"></span><br><span class=\"line\">cli</span><br><span class=\"line\">mov word ptr es:[9*4], 204H</span><br><span class=\"line\">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class=\"line\">sti</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">int9:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push es</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">in aL,60h</span><br><span class=\"line\"></span><br><span class=\"line\">pushf</span><br><span class=\"line\">call dword ptr cs:[200H]</span><br><span class=\"line\"></span><br><span class=\"line\">cmp aL, 1EH+80H</span><br><span class=\"line\">jne int9ret</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">s:</span><br><span class=\"line\">mov byte ptr es:[di], &#x27;A&#x27;</span><br><span class=\"line\">mov byte ptr es:[di+1], 02H</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">int9ret:</span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">int9ed:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675329053483-60588212-d9b5-4cef-acf7-06c70f65db5f.png#averageHue=%23141313&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u7a90e8bd&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=7755&amp;status=done&amp;style=none&amp;taskId=u3c74959a-2b05-4756-8089-500ac2f8893&amp;title=%E6%8C%89%E4%B8%8BA%E5%90%8E%E6%9D%BE%E5%BC%80&amp;width=583.6363509863864\" alt=\"image.png\" title=\"按下A后松开\"><br><a name=\"YodIM\"></a></p>\n<h1 id=\"实验16-编写包含多个功能子程序的中断例程\"><a href=\"#实验16-编写包含多个功能子程序的中断例程\" class=\"headerlink\" title=\"实验16 编写包含多个功能子程序的中断例程\"></a>实验16 编写包含多个功能子程序的中断例程</h1><ol>\n<li>编写源程序</li>\n</ol>\n<p>注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, cs</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov si, offset int7ch</span><br><span class=\"line\">mov ax, 0</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 0200H</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, offset int7ched - offset int7ch</span><br><span class=\"line\">cld</span><br><span class=\"line\">rep  movsb</span><br><span class=\"line\"></span><br><span class=\"line\">mov word ptr es:[7cH*4], 0200H</span><br><span class=\"line\">mov word ptr es:[7cH*4+2], 0 </span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">int7ch:</span><br><span class=\"line\">jmp short int7chStart</span><br><span class=\"line\">table dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200H</span><br><span class=\"line\"></span><br><span class=\"line\">int7chStart:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">cmp ah, 3</span><br><span class=\"line\">ja int7chRet</span><br><span class=\"line\">mov bl, ah</span><br><span class=\"line\">mov bh, 0</span><br><span class=\"line\">add bx, bx</span><br><span class=\"line\">call word ptr cs:(table-int7ch+200H)[bx]</span><br><span class=\"line\"></span><br><span class=\"line\">int7chRet:</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">iret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub1:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov bx, 0</span><br><span class=\"line\">s1:</span><br><span class=\"line\">mov byte ptr [bx], &#x27; &#x27;</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s1</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub2:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">mov bx, 0B800H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov bx, 1</span><br><span class=\"line\">s2:</span><br><span class=\"line\">and byte ptr [bx], 11111000B ; 只设置最后3位</span><br><span class=\"line\">or byte ptr [bx], al</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s2</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub3:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">mov bx, 0B800H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov cl, 4</span><br><span class=\"line\">shl al, cl</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">mov bx, 1</span><br><span class=\"line\">s3:</span><br><span class=\"line\">and byte ptr [bx], 10001111B</span><br><span class=\"line\">or [bx], al</span><br><span class=\"line\">add bx, 2</span><br><span class=\"line\">loop s3</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">Sub4:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push cx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">push es</span><br><span class=\"line\">push si</span><br><span class=\"line\">push di</span><br><span class=\"line\">mov bx, 08B00H</span><br><span class=\"line\">mov es, bx</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov si, 160</span><br><span class=\"line\">mov di, 0</span><br><span class=\"line\">cld</span><br><span class=\"line\">mov cx, 24</span><br><span class=\"line\"></span><br><span class=\"line\">s4:</span><br><span class=\"line\">push cx</span><br><span class=\"line\">mov cx, 160</span><br><span class=\"line\">rep movsb</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">loop s4</span><br><span class=\"line\"></span><br><span class=\"line\">mov cx, 80</span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">s41:</span><br><span class=\"line\">mov byte ptr [160*24+si], &#x27; &#x27;</span><br><span class=\"line\">add si ,2</span><br><span class=\"line\">loop s41</span><br><span class=\"line\">pop di</span><br><span class=\"line\">pop si</span><br><span class=\"line\">pop es</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop cx</span><br><span class=\"line\">pop bx</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br><span class=\"line\">int7ched:</span><br><span class=\"line\">nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ah,1 ; 0 2 3</span><br><span class=\"line\">mov al,2</span><br><span class=\"line\">int 7CH</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411618416-c6c100a2-f4d1-4bc9-b3e6-22f83fcdcaee.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u97049213&amp;name=image.png&amp;originHeight=427&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=5698&amp;status=done&amp;style=none&amp;taskId=udfd4d7d0-2546-4521-8884-82d74fe5421&amp;title=%E5%8A%9F%E8%83%BD1%EF%BC%9A%E6%B8%85%E5%B1%8F&amp;width=620\" alt=\"image.png\" title=\"功能1：清屏\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411466691-92faf4b3-fbd7-4859-b68b-e403f87d23e1.png#averageHue=%230e0e0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u0af61a75&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=11776&amp;status=done&amp;style=none&amp;taskId=ud7c332b2-9214-4185-917e-392d79cda17&amp;title=%E5%8A%9F%E8%83%BD2%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%89%8D%E6%99%AF%E8%89%B2&amp;width=642\" alt=\"image.png\" title=\"功能2：设置前景色\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411696534-79bed444-6b2a-4a77-ad72-027fb2081a4b.png#averageHue=%2300a900&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ue6689a35&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=11354&amp;status=done&amp;style=none&amp;taskId=u07994587-f0a4-4e4c-b31e-52a54f59cd3&amp;title=%E5%8A%9F%E8%83%BD3%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E8%89%B2&amp;width=642\" alt=\"image.png\" title=\"功能3：设置背景色\"><br><a name=\"IRx7s\"></a></p>\n<h1 id=\"实验17-编写包含多个功能子程序的中断例程\"><a href=\"#实验17-编写包含多个功能子程序的中断例程\" class=\"headerlink\" title=\"实验17 编写包含多个功能子程序的中断例程\"></a>实验17 编写包含多个功能子程序的中断例程</h1><p>第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了<br><a name=\"upigZ\"></a></p>\n<h2 id=\"练习17-1\"><a href=\"#练习17-1\" class=\"headerlink\" title=\"练习17-1\"></a>练习17-1</h2><p>接受用户的键盘输入，输入”r”，”g”,“b”分别将屏幕上的字符设置为红色，绿色，蓝色</p>\n<ol>\n<li>编写源程序</li>\n</ol>\n<p>用功能号为0的int 16H中断例程读取键盘输入即可<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\"></span><br><span class=\"line\">show:</span><br><span class=\"line\">push ax</span><br><span class=\"line\">push es</span><br><span class=\"line\">push di</span><br><span class=\"line\"></span><br><span class=\"line\">mov ah, 0</span><br><span class=\"line\">int 16H</span><br><span class=\"line\"></span><br><span class=\"line\">mov bl, 1</span><br><span class=\"line\">cmp al,&#x27;b&#x27;</span><br><span class=\"line\">je showst</span><br><span class=\"line\">shl bl, 1</span><br><span class=\"line\">cmp al, &#x27;g&#x27;</span><br><span class=\"line\">je showst</span><br><span class=\"line\">shl bl, 1</span><br><span class=\"line\">cmp al, &#x27;r&#x27;</span><br><span class=\"line\">je showst</span><br><span class=\"line\">jmp short FRet</span><br><span class=\"line\"></span><br><span class=\"line\">showst:</span><br><span class=\"line\">mov ax, 0B800H</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\">mov di, 1</span><br><span class=\"line\">mov cx, 2000</span><br><span class=\"line\">s:</span><br><span class=\"line\">and byte ptr es:[di], 11111000B</span><br><span class=\"line\">or es:[di], bl</span><br><span class=\"line\">add di, 2</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">FRet:</span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>运行结果</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431818731-db0edf92-bc54-4bfc-a35f-613c796dddda.png#averageHue=%230f0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u2f889938&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8416&amp;status=done&amp;style=none&amp;taskId=u3c7affc7-f57c-470f-9cab-1a94bcb3c74&amp;title=r-red&amp;width=642\" alt=\"image.png\" title=\"r-red\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431840911-15621108-ffb6-42ce-94ab-603c36fe9540.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u1bb9ce94&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8174&amp;status=done&amp;style=none&amp;taskId=u26c95d33-ee9d-414a-9861-7aa91427bc6&amp;title=g-green&amp;width=642\" alt=\"image.png\" title=\"g-green\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431855013-727c9bbb-b9bf-43a5-9ca6-ea80957dfa92.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ucb1b0f24&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8133&amp;status=done&amp;style=none&amp;taskId=ub45cc602-bef7-4fba-9ec7-3d4b52f4485&amp;title=b-blue&amp;width=642\" alt=\"image.png\" title=\"b-blue\"><br><a name=\"Wyllk\"></a></p>\n<h1 id=\"Other\"><a href=\"#Other\" class=\"headerlink\" title=\"Other\"></a>Other</h1><p><a name=\"QMCD1\"></a></p>\n<h2 id=\"1-理解assume伪指令的作用\"><a href=\"#1-理解assume伪指令的作用\" class=\"headerlink\" title=\"1. 理解assume伪指令的作用\"></a>1. 理解assume伪指令的作用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">a db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b dw 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">mov ah, 0</span><br><span class=\"line\">mov al, a[si]</span><br><span class=\"line\">add b, ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>assume ds:data ss:stack</code></li>\n</ol>\n<ul>\n<li>assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器$DS、SS$中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:<code>mov ax, data ``mov ds, ax</code></li>\n<li>assume是伪指令，用于指示编译器将$DS、SS$分别与data段和stack段关联。①关联是什么意思呢？就是<strong>在编译时默认data段中的数据标号a、b的段地址在</strong>$DS$<strong>中</strong>，因此如果要正确访问到a、b的内容，必须用指令将data填入$DS$中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此<code>mov ax, data</code>在编译器看来是<code>mov ax, data段段地址</code>，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax</li>\n</ul>\n<p>如果在程序中省略<code>assume ds:data</code>，则会出现_不能用段寄存器寻址_的错误<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675343108877-68cf68d3-97ef-4ecb-8b4f-6da330149c94.png#averageHue=%23161616&amp;clientId=u3f46bb08-d532-4&amp;from=paste&amp;height=388&amp;id=uffd0ec43&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13264&amp;status=done&amp;style=none&amp;taskId=ud9fb02f3-e117-4559-bfe1-1659d6727ee&amp;title=&amp;width=583.6363509863864\" alt=\"image.png\"></p>\n<ol>\n<li><code>assume cs:codesg</code></li>\n</ol>\n<p>将$CS$与代码段关联，在程序加载时将代码段(codesg)的段地址放入$CS$中. 如果去掉该语句，则程序编译不通过，因为$CS$的值不确定<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675341791119-4c9029f0-b9e3-4e2f-b1b9-aa5d02685f8f.png#averageHue=%230d0d0d&amp;clientId=u3f46bb08-d532-4&amp;from=paste&amp;height=276&amp;id=u952199f2&amp;name=image.png&amp;originHeight=304&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9905&amp;status=done&amp;style=none&amp;taskId=ud6cc6c48-9ce9-4df5-a654-02e53729a4d&amp;title=&amp;width=581.8181692076126\" alt=\"image.png\"><br><a name=\"wwfwW\"></a></p>\n<h2 id=\"2-理解数据标号\"><a href=\"#2-理解数据标号\" class=\"headerlink\" title=\"2. 理解数据标号\"></a>2. 理解数据标号</h2><ol>\n<li>数据标号与地址标号的不同</li>\n</ol>\n<p>地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, es:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">a db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b dw 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov si, 0</span><br><span class=\"line\">mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">mov ah, 0</span><br><span class=\"line\">mov al, a[si]</span><br><span class=\"line\">add b, ax</span><br><span class=\"line\">inc si</span><br><span class=\"line\">loop s</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure><br>这里的a和b分别指代了</p>\n<ul>\n<li><strong>地址为</strong><code>**seg data:0**</code><strong>, 长度为byte的字节单元</strong></li>\n<li><strong>地址为</strong><code>**seg data:8**</code><strong>, 长度为word的字单元</strong></li>\n</ul>\n<ol>\n<li>如何用数据标号以简洁形式访问内存中的数据</li>\n</ol>\n<p>在上一个程序中，我们用<code>mov al, a[si]</code> <code>add b, ax</code>访问了data段的内容，在编译器看来，这两条语句是这样的: <code>mov al, es:0[si]``add es:[8], ax</code><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409971871-70ff728a-fa74-48ac-a742-be8ec319d677.png#averageHue=%23191919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u6e4d3ff6&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14859&amp;status=done&amp;style=none&amp;taskId=ua1726f99-29ec-46f7-ac48-ad448e15a63&amp;title=&amp;width=642\" alt=\"image.png\"><br>我们现在用更熟悉的<code>mov al, [si+a]</code> <code>add b[0], ax</code>形式，从编译器角度来看，这两种形式没有区别<br>这说明了在指令中<strong>a等价于</strong><code>**byte ptr [0]**</code><strong>，b等价于</strong><code>**word ptr [8]**</code>（仅含偏移地址信息，默认段地址在es中，因为<code>assume es:data</code>）<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675410379440-d032239f-bb7d-480f-a45d-f96f7d064cd3.png#averageHue=%231a1919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ubbac8493&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15290&amp;status=done&amp;style=none&amp;taskId=uce443a00-0b21-4ac2-89ac-bb7e70f3432&amp;title=&amp;width=642\" alt=\"image.png\"></p>\n<ol>\n<li>将标号当作数据定义<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">a db 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b dw 0</span><br><span class=\"line\">c dw a, b</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">mov dx, 2</span><br><span class=\"line\">mov dx, c</span><br><span class=\"line\">mov ax, c[1]</span><br><span class=\"line\"></span><br><span class=\"line\">mov ax, 4C00H</span><br><span class=\"line\">int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<code>c dw a, b</code>将数据标号当作数据定义，c指代地址为<code>seg data:000A</code>的字单元，<strong>该字单元的内容是a的偏移地址</strong>$0000$，下面是验证<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409382345-20e1a2f2-8973-4150-992a-2a8acb141fa9.png#averageHue=%23191919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ud990b41d&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15496&amp;status=done&amp;style=none&amp;taskId=u9d64f540-f9d7-4f4d-a179-67094b0601b&amp;title=&amp;width=642\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409496753-347acc0d-300d-4502-b228-e202ee4504a4.png#averageHue=%23101010&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=400&amp;id=u97a8ca97&amp;name=image.png&amp;originHeight=400&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12100&amp;status=done&amp;style=none&amp;taskId=u65363c06-9a66-4677-9782-717ab71b1b6&amp;title=&amp;width=640\" alt=\"image.png\"></li>\n</ol>"},{"title":"[csapp] datalab, bomblab, attacklab","date":"2023-03-06T05:00:00.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"IR5gF\"></a>\n# lab1 dataLab\n<!--more-->\n<a name=\"RKm5i\"></a>\n## 前提\n确保有一个linux系统，并已经执行过以下两条命令:<br />安装gcc：`sudo apt-get install build-essential`  <br />安装[gcc的交叉编译环境](https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea).)：`sudo apt-get install gcc-multilib`，因为实验的程序需要以32位方式编译<br />在[CMU的CSAPP网站](http://csapp.cs.cmu.edu/3e/labs.html)上下载实验所需资料，包括**README, Writeup，Self-Study Handout，**这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件\n<a name=\"IOcHR\"></a>\n## 1.bitXor(x,y)\n要用~和&实现异或^，即将结果中 1-0，0-1对应的位设置为1<br />x&y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br />(~x&~y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br />两个做交集即为结果。（位向量可以表示集合，&，|，~可视为 交，并，补操作）\n```cpp\n/*\nbitXor - x^y using only ~ and & \nExample: bitXor(4, 5) = 1\nLegal ops: ~ &\nMax ops: 14\nRating: 1\n*/\nint bitXor(int x, int y) {\n    return  ~(x&y) & ~(~x&~y) ; // if regardless '+' is illegal:(~x&y) + ((x)&(~y)) or ~((x&y) + ((~x)&(~y)))\n}\n```\n<a name=\"mB5XE\"></a>\n## 2.tmin\n最简单的一题：`000...001` --> `1000...000`\n```cpp\n/* \ntmin - return minimum two's complement integer \nLegal ops: ! ~ & ^ | + << >>\nMax ops: 4\nRating: 1\n*/\nint tmin(void) {\n  return 1<<31;\n}\n```\n<a name=\"pr9MQ\"></a>\n## 3.isTmax(x)\n这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了`!((~x) + (~x))`，但[测试结果出乎意料](https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471)，加法溢出导致了未知的行为。<br />根据 Tmax +1 = Tmin 的性质可以得出 ,  `100...000` + `011...111` = `111..1111` (-1)，可得出`!(~x^(x+1))`（^可替换为+）<br />处理特例-1： -1同样会产生结果1，根据 `-1+1==0`,`Tmax+1!=0`，进而`!(-1+1) !=0` ，`!(Tmax+1) ==0`.<br />所以`对Tmax, x+(x+1) = x` , `对-1,x+(x+1)!=x`<br />用`x+(x+1)` 替换原式中的第一项x，最终得出结果：`!(~((x+!(x+1))^(x+1)))`\n```cpp\n/*\nisTmax - returns 1 if x is the maximum, two's complement number,\nand 0 otherwise \negal ops: ! ~ & ^ | +\nMax ops: 10\nRating: 1\n*/\nint isTmax(int x) {\n  return !(~((x+!(x+1)) ^ (x+1))) ; \n   // !((~x) + (~x));  it should be right, the operator \"!\" seem to not work\n}\n```\n<a name=\"kHLgK\"></a>\n## 4.allOddBits(x)\n这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br />用好异或即可解决：构造`101...1010`，再用该数提取x中的奇数位，最后再与`101...1010`比较\n```cpp\n/* \nallOddBits - return 1 if all odd-numbered bits in word set to 1\nwhere bits are numbered from 0 (least significant) to 31 (most significant)\nExamples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\nLegal ops: ! ~ & ^ | + << >>\nMax ops: 12\nRating: 2\n*/\nint allOddBits(int x) {\n  int allOdd = (0xAA << 24) + (0xAA << 16) + (0xAA << 8) + 0xAA; // 10101010..101\n  return ! ((allOdd & x) ^ allOdd);   \n}\n```\n<a name=\"sswhY\"></a>\n## 5.isAsciiDigit(x)\n有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验---用异或执行比较操作。<br />x的最后四位，3bit 与 1,2bit不能同时为1，因而有`!((x&mask2)^mask2) + (!((x&mask3)^mask3)))`，难点在于怎么处理好式中三部分的逻辑关系\n```cpp\n/* \n * isAsciiDigit - return 1 if 0x30 <= x <= 0x39 (ASCII codes for characters '0' to '9')\n *   Example: isAsciiDigit(0x35) = 1.\n *            isAsciiDigit(0x3a) = 0.\n *            isAsciiDigit(0x05) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 3\n */\nint isAsciiDigit(int x) {\n  int mask1 = 0x3;   // 000...0011\n  int mask2 = 0xA;   // 1010\n  int mask3 = 0xC;   // 1100\n  return  !( ((x>>4)^mask1) | (!((x&mask2)^mask2) + (!((x&mask3)^mask3)) ) );\n}\n```\n<a name=\"DZZaa\"></a>\n## 6.conditional\n比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br />涉及的操作是把x转化为0与1两个值，再把`000...0001`转化为`111...1111`\n```cpp\n/* \n * conditional - same as x ? y : z \n *   Example: conditional(2,4,5) = 4\n *   Legal ops: ! ~ & ^ | + << >> \n *   Max ops: 16\n *   Rating: 3\n */\nint conditional(int x, int y, int z) {\n  int  judge = !(x ^ 0x0); // x=0 -> judge=1,whereas x!=0 -> judge=0\n  judge = (judge << 31)>>31; // 000...000 or 111...111\n  return ((~judge)&y) | (judge&z);\n}\n```\n<a name=\"MZZvz\"></a>\n## 7.isLessOrEqual(x, y)\n可通过减法`y-x>=0`判断`x<=y`，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br />那么这题就涉及加法溢出,需要对` x+uw  y `结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br />更好的想法是**分析式子**`**y-x**`**并加入一个conditional操作**：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。\n```cpp\n/* \n * isLessOrEqual - if x <= y  then return 1, else return 0 \n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) \n{\n  int Tmin = 1<<31; // 100...0000\n  int signY = Tmin & y;\n  int signX = Tmin & x;\n  int judge = (signY ^ signX)<<31; \n  x = (~x)+1;\n  return (judge&signX) | (~(judge>>31) & !((y+x)&Tmin)) ; // \n}\n```\n<a name=\"WP1Li\"></a>\n## 8.logicalNeg(x)\n这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br />于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的**positive overflow**现象，即 Tmax + x ，对任意x>0均会使结果变为负数，符号位由0 -->1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致[undefined behavior](http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3)）\n```cpp\n/* \n * logicalNeg - implement the ! operator, using all of \n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logi'calNeg(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4 \n */\nint logicalNeg(int x) {\n  int Tmin = 1<<31;\n  int Tmax = ~Tmin;\n  int signX = ((x&Tmin)>>31) & 0x1;\n  return (signX^0x1) & ((((x + Tmax)>>31)&0x1)^0x1);\n}\n```\n<a name=\"Y5Acb\"></a>\n## 9.howManyBits(x)\n这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：**当数的符号位为1时，将数按符号位扩展之后其值不会变**，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br />要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -> 0010)<br />按二分法逐步缩小范围，找到最左边的1\n```cpp\n/* howManyBits - return the minimum number of bits required to represent x in\n *             two's complement\n *  Examples: howManyBits(12) = 5\n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4\n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ & ^ | + << >>\n *  Max ops: 90\n *  Rating: 4\n */\nint howManyBits(int x) {\n  int b16,b8,b4,b2,b1,b0;\n  int signX = x>>31;\n  x = ((~signX) & x) | (signX&(~x));// if x is negative, let sign bit:1-> 0\n  \n  b16 = (!!(x>>16))<<4; // ensure high 16 bits exist 1 or not\n  x=x>>b16;\n  b8 = (!!(x>>8))<<3; // ensure high 8 bits \n  x=x>>b8;\n  b4 = (!!(x>>4))<<2; // ensure high 4 bits \n  x=x>>b4;  \n  b2 = (!!(x>>2))<<1; // ensure high 2 bits \n  x=x>>b2; \n  b1 = !!(x>>1); // ensure 31 bits or not \n  x = x>>b1;\n  b0 = x;\n  \n  return b0+b1+b2+b4+b8+b16+1; // 1: sign bit\n}\n```\n<a name=\"glYde\"></a>\n## 10.floatScale2(uf)\n先对题目做出一点解释：传入一个`unsigned`类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br />**整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论**<br />注意点：对normalized，f*2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么`frac = frac <<1`，这也使得denormalized能转化到normalized (smoothly)\n```cpp\n//float\n/* \n * floatScale2 - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument    // revision: NaN or infinity\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatScale2(unsigned uf) {\n  int musk_exp,musk_frac,sign,exp,frac,result;\n  musk_exp = 0xFF << 23;\n  musk_frac = 0x7FFFFF;\n  exp = (uf & musk_exp)>>23;\n  frac = uf & musk_frac;\n  sign = 0x1<<31 & uf;\n  result = 5;\n  if(exp == 0xFF  ) // NaN\n     result = uf;\n  else if(exp == 0x0) // denormalized\n  {  \n     if(frac == 0x0)\n     {\n        if(sign)  // -0.0\n           result = uf;\n        else     // +0.0\n           result = 0 ;\n     }\n     \n     else\n     {\n        frac = frac << 1;\n        result = sign+ (exp<<23) + frac;\n     }\n  }\n  \n  else if(exp != 0x0 && exp != 0xFF) // normalized\n  {\n     exp += 1;\n     result = sign+ (exp<<23) + frac;\n  }\n  return result;\n}\n```\n<a name=\"tO8yh\"></a>\n## 11.floatFloat2Int(uf)\n浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br />对题目的解释：返回浮点数f的int型表示，如输入`12345.0 (0x4640E400)`, 正确输出为`12345 (0x3039)`<br />注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E>31时，属于out of range\n```cpp\n/* \n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\n \nint floatFloat2Int(unsigned uf) {\n  int musk_exp,musk_frac,exp,frac,sign,E,Bias,result;\n  musk_exp = 0xFF << 23;\n  musk_frac = 0x7FFFFF;\n  exp = (uf & musk_exp)>>23;\n  frac = uf & musk_frac;\n  sign = 0x1<<31 & uf;\n  Bias = 127;\n  result = 5;\n  if(exp == 0xFF  ) // NaN or infinity\n     result = 0x80000000u;\n     \n  else if(exp == 0x0)\n     result = 0;\n     \n  else if(exp != 0x0 && exp != 0xFF) // normalized\n  {\n     E = exp -Bias;  // bit_num of fraction\n     if(E < 0)\n        result = 0;\n     else if (E>31)\n        result = 0x80000000u;\n     else\n     {\n        frac = frac>>(23-E);\n        result = (0x1 << E) + frac ; \n        if(sign == 0x1<<31)\n           result = - result;\n     }\n  }\n  \n  return result;\n}\n```\n<a name=\"UlJMS\"></a>\n## 12.floatPower2(x)\n注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large\n```cpp\n/* \n * floatPower2 - Return bit-level equivalent of the expression 2.0^x\n *   (2.0 raised to the power x) for any 32-bit integer x.\n *\n *   The unsigned value that is returned should have the identical bit\n *   representation as the single-precision floating-point number 2.0^x.\n *   If the result is too small to be represented as a denorm, return\n *   0. If too large, return +INF.\n * \n *   Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while \n *   Max ops: 30 \n *   Rating: 4\n */\nunsigned floatPower2(int x) {\n  int exp,frac,E,Bias,result;\n  Bias = 127;\n  result = 5;\n  E = x;\n  if(x<1 && x!=0)\n     return 0;\n\n  else if(x >= 0x1 || x == 0)\n  {\n     frac = 0x0;\n     exp = E+Bias;\n     if(exp > 254)  // 1111 1110\n        {\n           exp = 0xFF;\n           result = exp <<23+frac;         \n        }\n     else\n        result = (exp<<23) + frac; \n  }    \n  \n  return result ;\n}\n```\n<a name=\"iHsuB\"></a>\n## consequence\n`make`<br />`./driver.pl`\n<a name=\"SLl25\"></a>\n### ![data_lab_success.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1669795434321-27bd7778-bde0-4d21-9ae0-425e1e785bd1.png#averageHue=%230d0c0c&clientId=u8b4f2be4-4c9f-4&from=ui&id=ue9c8e7dc&name=data_lab_success.png&originHeight=631&originWidth=1162&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183673&status=done&style=none&taskId=u00d5bd76-a7dc-4107-8697-fafe865d7ec&title=)\n\n---\n\n<a name=\"FsQk5\"></a>\n# lab2 bombLab\n<a name=\"mm3BW\"></a>\n## phase_1\n\n1. 反汇编`main`函数：`read_line`函数之后寄存器`%rax`和`%rdi`存储了我们输入的字符串的首地址(后续的phase都是如此)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677142575501-aadca48e-4054-40dc-977b-4719009de3e3.png#averageHue=%2362372c&clientId=u40dabece-2d53-4&from=paste&height=113&id=u7f5a75e8&name=image.png&originHeight=113&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65961&status=done&style=none&taskId=u19a9cc96-f38d-462d-9d4b-fbdd1e6cd16&title=&width=1058)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163430669-16842232-e1ab-4ac7-a90d-8f9a18e1c5d2.png#averageHue=%232d2d2d&clientId=u40dabece-2d53-4&from=paste&height=128&id=u1267f1f6&name=image.png&originHeight=128&originWidth=1060&originalType=binary&ratio=1&rotation=0&showTitle=true&size=59576&status=done&style=none&taskId=ufdd9544b-0308-49f4-86fd-49a8013d976&title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%281%29&width=1060 \"验证%rdi指向输入字符串(1)\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163457263-f780263b-09ed-4875-bafc-0f00d7e8e894.png#averageHue=%23323232&clientId=u40dabece-2d53-4&from=paste&height=77&id=ubbe401e0&name=image.png&originHeight=77&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=true&size=31472&status=done&style=none&taskId=u152fe82b-0961-427e-bd1e-8a6755f1504&title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%282%29&width=723 \"验证%rdi指向输入字符串(2)\")\n\n2. 反汇编`strings_not_equal`函数：该函数在输入字符串与目的字符串相同时，将寄存器`%rax`（通常用作函数返回值）赋值为0 (1 vice versa)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143001741-9ecdcda9-b9a6-4b31-a450-5d80ed226850.png#averageHue=%23302f2f&clientId=u40dabece-2d53-4&from=paste&height=147&id=u575b769d&name=image.png&originHeight=147&originWidth=1140&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79269&status=done&style=none&taskId=u9916894f-f032-4f63-b09d-6ce04314c3f&title=&width=1140)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143020716-757eda92-ee3e-4fe0-9c1b-597af2e24eab.png#averageHue=%23323131&clientId=u40dabece-2d53-4&from=paste&height=214&id=uca455390&name=image.png&originHeight=214&originWidth=973&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98661&status=done&style=none&taskId=u7c4aadd7-6706-4e4d-8a95-2e31a1df894&title=&width=973)\n\n3. 反汇编`phase_1`函数：`strings_not_equal`函数返回值为0时，`test %eax, %eax`能使`je 0x400ef7<phase_1+23>`执行，phase_1 defused (explode vice versa)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143312955-e1e9a80c-1730-48ae-84f7-5dfded69d3a9.png#averageHue=%232e2d2d&clientId=u40dabece-2d53-4&from=paste&height=361&id=ue40fcfa2&name=image.png&originHeight=361&originWidth=1126&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206173&status=done&style=none&taskId=u54ecca10-9722-4536-ba3f-f972c656feb&title=&width=1126)\n\n4. 至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用`strings_not_equal`函数之前赋值的`%esi：0x402400`寄存器中\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143752561-a0f86e1a-fc9c-4ff2-b386-d8d929f293c5.png#averageHue=%23333333&clientId=u40dabece-2d53-4&from=paste&height=102&id=ua334cc19&name=image.png&originHeight=102&originWidth=1118&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39885&status=done&style=none&taskId=u26286ab1-642e-4f50-9434-8d65b1add7d&title=&width=1118)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143789980-9946be38-59bb-4852-bd3c-72747f67fc16.png#averageHue=%23333333&clientId=u40dabece-2d53-4&from=paste&height=152&id=u0cd1b8f0&name=image.png&originHeight=152&originWidth=1065&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69532&status=done&style=none&taskId=u1b6e1505-7e71-4000-8504-44c050e2921&title=&width=1065)\n<a name=\"aPHyw\"></a>\n## phase_2\n\n1. 反汇编`read_six_numbers`函数：可以推断出其实现了`sscanf(input, \"%d %d %d %d %d %d\",&a1,&a2,&a3,&a4,&a5,&a6)`的功能，其中`&a1~&a6`分别在1)`%rcx:0x4(%rsi)`2)`%r8:0x8(%rsi)`3)`%r9:0xc(%rsi)`4)`%rsp:0x10(%rsi)`5)`0x8(%rsp):0x14(%rsi), 0x18(%rsi) ` 前3个指针存储在寄存器中传递给`sscanf`函数，后三个指针存储在为`read_six_numbers`函数分配的栈空间中,可以推断出`%rsi`为一个含有六个元素的数组的首地址\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677148614935-cd29c501-e2a8-4185-9924-0829124ef293.png#averageHue=%232e2d2d&clientId=u40dabece-2d53-4&from=paste&height=506&id=ue62a1cc7&name=image.png&originHeight=506&originWidth=1045&originalType=binary&ratio=1&rotation=0&showTitle=false&size=292132&status=done&style=none&taskId=udf564ea8-5d5d-4db1-9fe7-6784845d360&title=&width=1045)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150202265-dda02d42-7661-48f0-9ec1-5b420d781e9d.png#averageHue=%23313131&clientId=u40dabece-2d53-4&from=paste&height=74&id=u5d32cc04&name=image.png&originHeight=74&originWidth=675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24474&status=done&style=none&taskId=u7f387e07-3b4e-4ad1-bae1-5f9cf213c77&title=&width=675)\n\n2. 反汇编`phase_2`函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150067118-dd3962a5-1458-4a3e-9399-4cf1699ca7a7.png#averageHue=%23423227&clientId=u40dabece-2d53-4&from=paste&height=656&id=u8a1ec132&name=image.png&originHeight=656&originWidth=885&originalType=binary&ratio=1&rotation=0&showTitle=false&size=478280&status=done&style=none&taskId=u1da79441-ac63-407b-ab6c-037fd3e1450&title=&width=885)\n\n3. 自此，我们可以判断出这六个数字分别是$2^0,2^1,2^2,2^3,2^4,2^5$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677149991615-e3f805b9-b4b0-4f49-bfbf-36dc2153557b.png#averageHue=%23313131&clientId=u40dabece-2d53-4&from=paste&height=112&id=ua5f4ba93&name=image.png&originHeight=112&originWidth=782&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34849&status=done&style=none&taskId=u43537a4a-415e-4df2-b80d-0601d361576&title=&width=782)\n<a name=\"XKRDk\"></a>\n## phase_3\n\n1. 反汇编`phase_3`：从`(%esi)`的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(`cmpl 0x7,0x8(rsp)`)，并根据这个值执行间接跳转操作(`jmp *0x402470(,rax,8)`)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150892423-92750918-b2b5-4aa5-9b0e-e08eec5cffdd.png#averageHue=%23141313&clientId=u40dabece-2d53-4&from=paste&height=150&id=uf4734a85&name=image.png&originHeight=150&originWidth=1074&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61373&status=done&style=none&taskId=u56bba885-3031-4576-9ddd-85ccf2060e9&title=&width=1074)\n\n2. 查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的`0x8(%rsp`：1 2 3 4 5 6 7\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677072562462-74d53e52-6a59-498d-9186-02f1b43b8be5.png#averageHue=%23131313&clientId=u39d47224-2023-4&from=paste&height=324&id=u10476384&name=image.png&originHeight=324&originWidth=1067&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80101&status=done&style=none&taskId=u49754a92-19b8-499c-8daf-4c666824406&title=&width=1067)\n\n3. 根据后续的赋值-跳转指令，可以得到对应的7个`0xc(%rsp)`：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151557789-3726bd23-9a03-48c7-bb2b-1a31a71ae4c0.png#averageHue=%23121212&clientId=u40dabece-2d53-4&from=paste&height=286&id=ud77abcea&name=image.png&originHeight=327&originWidth=347&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72813&status=done&style=none&taskId=uaa3da35e-6e2a-42ba-af96-025e357b784&title=&width=304)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151578594-a2486d66-586a-473a-ba87-8ed30e462b01.png#averageHue=%231e1e1e&clientId=u40dabece-2d53-4&from=paste&height=294&id=ud120ef9a&name=image.png&originHeight=391&originWidth=354&originalType=binary&ratio=1&rotation=0&showTitle=false&size=101567&status=done&style=none&taskId=ub5d0284e-6af4-4113-b8cd-89ebdce0f6d&title=&width=266)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073427546-61c8a627-e902-4132-922f-d9c30d888865.png#averageHue=%23303030&clientId=u39d47224-2023-4&from=paste&height=50&id=u47146b93&name=image.png&originHeight=75&originWidth=297&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8224&status=done&style=none&taskId=u32d95d06-a5d5-44ea-9c62-17652eea139&title=&width=197)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073446185-f50d15ab-e6e5-4d7f-b87a-7c41585c225e.png#averageHue=%232f2f2f&clientId=u39d47224-2023-4&from=paste&height=47&id=ue4a4e105&name=image.png&originHeight=70&originWidth=287&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8707&status=done&style=none&taskId=u21abdc4b-34e0-4b23-8ae8-6a213e06389&title=&width=192)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073458555-0aefc97d-f40a-4b0b-8e5e-1c592d1478fb.png#averageHue=%23313131&clientId=u39d47224-2023-4&from=paste&height=51&id=u12915178&name=image.png&originHeight=74&originWidth=307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8649&status=done&style=none&taskId=u884bf4d9-3d42-48e3-9d32-a6cc91f0115&title=&width=212)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073483221-c6634274-ca68-4d70-b35d-bcf9c12bc64d.png#averageHue=%23292929&clientId=u39d47224-2023-4&from=paste&height=48&id=u8a9d1cb9&name=image.png&originHeight=71&originWidth=296&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10382&status=done&style=none&taskId=u3d742e48-f459-45a3-abcb-5a2e46a9698&title=&width=201)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073498912-78462783-24d1-48c5-bd9c-dc0efd391d71.png#averageHue=%232a2a29&clientId=u39d47224-2023-4&from=paste&height=47&id=uc7e8ea56&name=image.png&originHeight=75&originWidth=290&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11606&status=done&style=none&taskId=u579ff7da-06cc-49aa-bbb5-7d665920365&title=&width=183)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073505761-bdd3ef17-0fcd-491a-8c9d-c021bd67b4a8.png#averageHue=%23272727&clientId=u39d47224-2023-4&from=paste&height=53&id=u656875e3&name=image.png&originHeight=78&originWidth=307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11833&status=done&style=none&taskId=u1ec87705-b895-47c3-98cb-1da89ebe401&title=&width=208)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073525247-e99ecac4-12c7-4929-ac87-722029dcb4fd.png#averageHue=%23303030&clientId=u39d47224-2023-4&from=paste&height=49&id=uaaf9dd91&name=image.png&originHeight=74&originWidth=316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8976&status=done&style=none&taskId=u262b648d-9811-41df-9106-07a991aca4a&title=&width=208)\n<a name=\"Qae7S\"></a>\n## phase_4\n\n1. 反汇编`phase_4`函数：开头部分具有与`phase_3`函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(`cmpl $0xe, 0x8(%rsp)`)，之后函数调用`func4`函数，传入三个参数`%edx`, `%esi`, `0x8(%rsp)`。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(`test %eax, %eax`)。后续的`cmpl $0x0, 0xc(%rsp)`足以确定第2个值为0\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206362623-39fe4977-5cab-4016-9003-2541d41dbe6a.png#averageHue=%232a2823&clientId=u15f83395-fa33-4&from=paste&height=416&id=ubcbcc5b1&name=image.png&originHeight=587&originWidth=1125&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=601648&status=done&style=none&taskId=ucd50703b-cd59-4e1b-b4f1-5fefbaddeb2&title=&width=797)\n\n2. 反汇编`func4`函数：出现了`func4`调用自身的情况，所以`func4`是一个递归函数。第1部分将`%rax`赋值为`%edx`-`%esi`,再加上它的最高位(`%rax >> 31`)，接着执行算数右移。这里加上最高位的原因在于，当后续`%rax`在递归中值减少为-1时，最高位是符号位1，两者相加能保证`%rax`始终大于等于0，结合后续汇编内容，可以推断出第一个值`0x8(%rsp)`应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果`%ecx > %edi`，那么就使`%ecx`变为`%esi`到`%edx`的中间值(`lea -0x1(%rcx), %edx`)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回`phase_4`的`%rax`值为1\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677204842268-34841e29-56e5-4d63-9e9f-b1576cec24a4.png#averageHue=%232b2a2a&clientId=u15f83395-fa33-4&from=paste&height=562&id=u81eba999&name=image.png&originHeight=843&originWidth=1305&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=520895&status=done&style=none&taskId=u37b9260f-a9c9-4dd9-abb9-dd995610f26&title=&width=870)\n\n3. 自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206164369-fa35758d-403b-483b-ad52-af80ef73df84.png#averageHue=%232c2c2c&clientId=u15f83395-fa33-4&from=paste&height=49&id=u3b0eedfa&name=image.png&originHeight=74&originWidth=649&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17085&status=done&style=none&taskId=ub467ca8a-a273-4b74-b425-f72d9e99ae4&title=&width=432.6666666666667)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206214348-cbc56dfd-faed-4afb-8859-c6bb00e4be62.png#averageHue=%232c2c2c&clientId=u15f83395-fa33-4&from=paste&height=49&id=ub80967c2&name=image.png&originHeight=74&originWidth=686&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17880&status=done&style=none&taskId=u78e1925a-de3d-4ff7-a76b-00e4657dd48&title=&width=457.3333333333333)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206249049-10571826-c506-4fdf-bcae-4ca9487bd383.png#averageHue=%232d2d2d&clientId=u15f83395-fa33-4&from=paste&height=46&id=u3c92002a&name=image.png&originHeight=75&originWidth=713&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17666&status=done&style=none&taskId=u81f0177a-9477-484d-bc60-f8009a91d73&title=&width=435.3333435058594)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206271742-0b02d5c9-234f-465e-9fb7-6a9cb6c3b2f3.png#averageHue=%232c2c2c&clientId=u15f83395-fa33-4&from=paste&height=49&id=u0a7235e4&name=image.png&originHeight=73&originWidth=674&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17218&status=done&style=none&taskId=u48f4584a-4771-47be-b5b5-5281e909d12&title=&width=449.3333333333333)\n<a name=\"Kxq7k\"></a>\n## phase_5\n\n1. 反汇编`phase_5`函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)\n```c\nint index\nint i = 0 // %rax\ndo{\nindex = *(input+i);\nindex = index& 0xf; // take lower four bits\ndest[0] = source[index]; // dest: (%rsp+0x10+%rax) source: 0x4024b0\nif(string_not_equal(dest, target) == 0) // target: 0x40245e --- \"flyers\"\n      //defuse\nelse\n   explode_bomb();\n}while(i>6)\n```\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227102569-50a0daeb-22b8-4911-84ee-83283088ca0d.png#averageHue=%23211710&clientId=ub432d06a-c081-4&from=paste&height=629&id=u029c0758&name=image.png&originHeight=944&originWidth=901&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=467386&status=done&style=none&taskId=uaa2e377e-a27a-4e06-9129-f19ece505a9&title=&width=600.6666666666666)\n\n2. 分别查看`source: 0x4024b0`和`target: 0x40245e`处的字符串，我们要做的就是使输入字符串形成的索引值能够从`0x4024b0`处的字符集中提取出 \"flyers\"\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227207876-48a2e806-f23e-49ec-982e-698183c7bc19.png#averageHue=%23151515&clientId=ub432d06a-c081-4&from=paste&height=52&id=u3302b9b7&name=image.png&originHeight=78&originWidth=1766&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=39766&status=done&style=none&taskId=u6f4121a7-1717-4bf8-9d35-1f34adc43a8&title=&width=1177.3333333333333)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227244326-73d2e1d2-8fa8-4452-bb1c-64b132ecd786.png#averageHue=%23131313&clientId=ub432d06a-c081-4&from=paste&height=49&id=u7ad1cd69&name=image.png&originHeight=73&originWidth=906&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18317&status=done&style=none&taskId=u0a7a9ee0-efaa-4b08-8a9e-6e726ed5958&title=&width=604)\n\n3. 我们的输入字符串每个字符在内存中占一个byte，`movzbl (%rbx, %rax, 1), %ecx`说明了一次循环提取一个字符，并只取该字符的低四位(`and $0xf, %edx`)作为索引值\n4. 首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228092474-185f8fde-3015-4a64-ae85-2a4931bb2ca9.png#averageHue=%23191919&clientId=ub432d06a-c081-4&from=paste&height=72&id=u2762ccc0&name=image.png&originHeight=108&originWidth=741&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24485&status=done&style=none&taskId=u4d7584c2-7474-4bc2-8df3-b7710936568&title=&width=494)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228432835-1ddc8d9b-d067-4d80-82c1-d63b067d6c25.png#averageHue=%23191919&clientId=ub432d06a-c081-4&from=paste&height=71&id=uaf8564a8&name=image.png&originHeight=107&originWidth=705&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24585&status=done&style=none&taskId=ud201852c-7855-4553-8543-43f2a63028c&title=&width=470)\n<a name=\"BuuHr\"></a>\n## phase_6\n\n1. thinking process\n```c\nphase_6(input)\n{\nint a1 = 0;  // %r12d\nint* input_copy = input; // mov %rsp, %r13\nint val; // %eax\n\nwhile(1)\n{\n    val = *(input_copy); // 0x0(%r13)\n    val = val-1;\n    if(val>5)  explode()  // 元素值不得大于6\n        \n    ++a1; // add $0x1, %r12d\n    if(a1 == 6) break; // jmp 95\n    int a2 = a1; // mov %r12d, %ebx\n    do{   // 65\n        val = *(input+a2);\n        if(val == *input_copy)\n            explode();\n        ++a2;\n        }while(a2<= 5 ) // 87\n    ++input_copy; // add $0x4, %r13\n} // 93\n/*两个信息：(已验证)\n1. 输入字符串中所有元素不大于6\n2. 输入字符串中所有元素互不相等 */ 0~6\n\nint* sentry = input+6; // mov 0x18(%rsp), %rsi   95\nint* input_copy_2 = input; // %rax\nint a3 = 7; // %edx, %ecx\ndo{\n    *(input_copy_2) = a3 - *(input_copy_2);\n    ++input_copy_2;\n}while(input_copy_2 != sentry)\n/* 更新输入字符串所有值为：7-初始值(已证实), \n结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */\n \nint a4 = 0; // 123 %esi  -- index\nint a5; // %edx\nint a6; // %eax  -- index\noffset_166:\nif(input[a4] <= 1) // 166  %ecx\n{\n    a5 = 0x6032d0; // 143\n    offset_148:\n    *(input+0x20+2*a4) = a5; // 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48\n                             //   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320   \n    a4 += 4; // add $0x4, %rsi \n    if(a4 ==  24 )\n        goto offset_183; // 161 \n    else \n        goto offset_166;\n}\nelse  // 均要走这个else， 可能有一个不走这个else -->肯定有一个不走\n{\n    a6 = 1;  // 171  \n    &a5 = 0x6032d0; // 176  这个地址+0x8能多次跳转\n    do{ // 130\n        a5 = *(&a5 + 0x8) ; // mov 0x8(%rdx),%rdx  链表?\n        ++a6; \n    }while(a6 != *(input+a4) ) // 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)\n    goto offset_148;         // recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5\n} // 181\n\noffset_183：    function: link node in order\nint a7 = input[8]; //%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address\nint* input_copy_3 = input+10 // %rax  0x28(%rsp)\nint* input_copy_4 = input+20 // %rsi  0x50(%rsp)\na3 = a7; // a3:%rcx\nwhile(1){ // 201\n    a5 = *input_copy_3; //a5:%rdx [10][12]...[18][20] 6\n    *(a3+0x8) = a5; // 0x8(%rcx)\n    input_copy_3 += 2; // 0x8 \n    if(input_copy_3 == input_copy_4) break; // 215 \n    a3 = a5; // mov %rdx, %rcx\n}    //   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)\n// 结束时 %rdx = * (input + 18)\n\n*(*(input+18) + 2 ) = 0; // 222   set last node's pointer to nullptr\nint a8 = 5; // %ebp\nint a9 // %rax \ndo\n{\n &a9 = *(a7+2); // %rax   initial a7 = input[8]\n  a9 = *a9; // mov (%rax), %eax\nif(*(*(input+8)) < a9) // cmp %eax, (%rbx) \n    explode();   // 验证是否降序\na7 = *(*(input+8)+2); // mov 0x8(%rbx), %rbx 更新%rbx  \n--a8;\n}while(a8>0)\n\n}\n// over\n    \n/*inital:\n0x14c(0): 332;\n0x0a8(1): 168;\n0x39c(2): 924;\n0x2b3(3): 691\n0x1dd(4): 477\n0x1bb(5): 443\n\n2->3->4->5->0->1 */\n\n\n```\n\n2. 我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是`0x6032d0`这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使`0x6032d0`这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677403752602-71565a7a-ae83-4e0e-a0d7-cdd2e3df1fd5.png#averageHue=%23232222&clientId=u54232b82-dfec-4&from=paste&height=165&id=u5a9db9de&name=image.png&originHeight=248&originWidth=1501&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=164901&status=done&style=none&taskId=u365af322-15ad-46fb-9cfc-245887947ea&title=list%20after%20sort&width=1000.6666666666666 \"list after sort\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677402131273-de3ea8a9-669e-4bf2-8194-cccb235cd58b.png#averageHue=%23282828&clientId=u54232b82-dfec-4&from=paste&height=217&id=ucd4dd2ed&name=image.png&originHeight=325&originWidth=1104&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146781&status=done&style=none&taskId=u67c0a4b5-d060-40b2-9b3c-921a69962c7&title=&width=736)\n<a name=\"QjpMp\"></a>\n## secret_phase\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404056138-294107ed-6f1c-4477-83c9-44b00041ef4b.png#averageHue=%232a2929&clientId=u54232b82-dfec-4&from=paste&height=152&id=u674c8aa7&name=image.png&originHeight=228&originWidth=1213&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42994&status=done&style=none&taskId=u89aa5f1c-7b78-46bb-b51c-a2062f218dc&title=&width=808.6666666666666)\n\n1. 发现彩蛋\n\n以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用`objdump -t bomb`查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404753141-3d41a656-d41d-476c-aae5-e51421f24d6e.png#averageHue=%230b0b0a&clientId=u54232b82-dfec-4&from=paste&height=338&id=u59b20a1e&name=image.png&originHeight=507&originWidth=1706&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=217929&status=done&style=none&taskId=ub07a14e6-ebf4-4769-b55c-e586658a966&title=&width=1137.3333333333333)\n\n2. 怎么触发\n\n1)谁调用了secret_phase：`secret_phase`既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在`main`函数中寻找可能调用`secret_base`的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在`phase_defused`函数中，反汇编`phase_defused`函数，果然发现了调用`secret_phase`的指令<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404954528-c0e39bd3-077e-49cd-a460-d820f2047ce8.png#averageHue=%232b2a2a&clientId=u54232b82-dfec-4&from=paste&height=488&id=u9e4e339a&name=image.png&originHeight=732&originWidth=1266&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=459111&status=done&style=none&taskId=u6d1b7d59-0bf7-4df3-9948-00a20fc914f&title=&width=844)<br />2）在phase_defused中如何触发：从`main`函数可以看出，bomb文件在每次未触发炸弹而执行完一个phase的时候都会调用一次`phase_defused`。分析phase_defused，该函数当输入字符串表示分隔的数字值时，如果数字个数小于6个，直接返回，对应phase1~phase5；如果数字等于6个，继续执行，对应phase6<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414713624-83322f4b-2b99-42ce-9152-3c094464743d.png#averageHue=%232a2a29&clientId=u54232b82-dfec-4&from=paste&height=167&id=u4e91d4e7&name=image.png&originHeight=251&originWidth=1753&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=206560&status=done&style=none&taskId=u8107d152-8bbe-44eb-beb6-bd477c6e492&title=&width=1168.6666666666667)<br />接着从地址`0x603870`处读取两个数字，一个字符串<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414792269-cc61be84-af1a-449f-b88a-efdf5b602450.png#averageHue=%23262626&clientId=u54232b82-dfec-4&from=paste&height=52&id=u54634d3d&name=image.png&originHeight=78&originWidth=676&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=25535&status=done&style=none&taskId=uf1933c57-b4a3-46a2-a583-11eeb6c7623&title=&width=450.6666666666667)<br />经过验证，地址`0x603870`为phase_4阶段输入字符串的开始地址<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414872028-db9b7aa7-d78c-450a-877d-8d643d89022d.png#averageHue=%23272626&clientId=u54232b82-dfec-4&from=paste&height=52&id=u20d9ba63&name=image.png&originHeight=78&originWidth=763&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=32367&status=done&style=none&taskId=uf4f5ab27-77d8-4b6a-9614-34ea9d69b04&title=&width=508.6666666666667)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414887631-8de449af-6eff-4f20-9632-860f0d751f77.png#averageHue=%232b2b2b&clientId=u54232b82-dfec-4&from=paste&height=51&id=u78a64d3f&name=image.png&originHeight=76&originWidth=856&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=31655&status=done&style=none&taskId=u1f45d585-4254-407d-a785-6859f161d5b&title=&width=570.6666666666666)<br />根据后续逻辑，只要在phase_4阶段时输入`\"7 0 DrEvil\"`即可触发`secret_bomb`<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415081966-c8dd9474-52be-4ca5-b73b-da79cea387f2.png#averageHue=%232b2a2a&clientId=u54232b82-dfec-4&from=paste&height=289&id=uff04a21c&name=image.png&originHeight=434&originWidth=1193&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=295794&status=done&style=none&taskId=uc3d47c14-4fd2-4066-8097-d303800fa51&title=&width=795.3333333333334)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415023030-75fb6b08-160a-41a7-ac0c-2cd054c806ee.png#averageHue=%23272727&clientId=u54232b82-dfec-4&from=paste&height=53&id=u647b3556&name=image.png&originHeight=79&originWidth=501&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19252&status=done&style=none&taskId=ubfabe50b-c88f-4d79-8759-413c728c17a&title=&width=334)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415142283-f37e926f-a289-4c18-9170-346e631d561e.png#averageHue=%232a2a2a&clientId=u54232b82-dfec-4&from=paste&height=361&id=uc5b1fa4e&name=image.png&originHeight=542&originWidth=1158&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=228864&status=done&style=none&taskId=u4bbc5a61-2cb2-48b7-95b7-d8b064cb1ad&title=&width=772)\n\n3. 终章：拆解secret_phase\n\n1）反编译secret_base\n```c\nsecret_phase()\n{\n    int input_2;// (%rdi)\n    &input_2 = read_line(); //  %rdi\n    \n    int a1 = 0xa; // %edx\n    int a2 = 0x0; // %esi\n    long int input_num_1 = strtol(input_2); // %rax\n    long int input_num_2 = input_num_1 // %rbx\n    input_num_1 -= 1; \n    if(input_num_1 > 0x3e8 /*1000*/) explode();\n    // 输入的数字字符串 值小于 1001\n    a2 = input_num_2;// mov %ebx, %esi  \n    &input_2 = 0x6030f0;\n    int ret = fun7(&input_2,a2,input_num_1); // ret_value: %rax\n    \n    if(ret == 0x2)\n        defused();\n    else\n        explode(); \n}\n\nint fun7(&input_2, a2, input_num_1)\n{\n    if(&input_2 == 0x0) return -1; // avoid endless recursion\n    int a3 = *(&input_2);  // 9 %edx   initial a3 = 24\n    if(a3 <= a2) goto offset_28; // 13  a2是输入值 \n\n    // a3 > a2\n    input_2 = *(&input_2 + 0x8); // +2  turn left\n    input_num_1 = fun7(&input_2, a2, input_num_1); // 19\n\n    input_num_1 *= 2; // input_num_q is 1 here\n    return input_num_1;\n\n    offset_28:\n    input_num_1 = 0;\n    if(a3 == a2) return input_num_1;\t\n\n    // a3 < a2\n    input_2 = *(&input_2 + 0x10); // +4   turn right\n    input_num_1 = fun7(&input_2, a2, input_num_1); // 0\n    input_num_1 = 2*input_num_1 + 1;  // 1\n    return input_num_1;\n}\n\n```\n2）有了phase_6的经验，我在查看了特殊地址`0x6030f0`的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址`0x6030f0`为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合`secret_phase`的逻辑，在子函数`fun7`返回值为2时defuse，经过分析，`fun7`这个递归函数，在最后三次递归时为turn left(`&input_2 + 0x8`）->turn right(`&input_2 + 0x10`) -> return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484445488-99b96bb8-8026-406a-8606-b6ed814389d7.png#averageHue=%232b2b2b&clientId=u289fcf2a-d904-4&from=paste&height=565&id=u5030ad8b&name=image.png&originHeight=848&originWidth=1530&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=595091&status=done&style=none&taskId=uf7e602a3-1dfa-4402-88da-6b6d06e26db&title=&width=1020)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484586007-34081aec-ae5a-409a-9270-7503f23d697b.png#averageHue=%23fefefe&clientId=u289fcf2a-d904-4&from=paste&height=268&id=u3886e51a&name=image.png&originHeight=321&originWidth=613&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=45328&status=done&style=none&taskId=uc94db6c6-0837-40f5-8324-986eeadfa19&title=&width=511.66668701171875)<br />3) 至此，整个bomblab就结束了，花费了我十多个小时完成了这个lab还是很值得的，伴随这一个又一个defuse，成就感是满满的，哈哈哈<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484822762-1f6d54b5-8a8f-405e-ab5b-b3de5c095440.png#averageHue=%232d2d2d&clientId=u289fcf2a-d904-4&from=paste&height=309&id=ua22fc755&name=image.png&originHeight=463&originWidth=1657&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=276450&status=done&style=none&taskId=ua2ea40a4-48b8-410d-a36d-c5de36dd026&title=&width=1104.6666666666667)\n\n---\n\n<a name=\"SLpu6\"></a>\n# lab3 attacklab\n<a name=\"UbCO7\"></a>\n## 前提\n\n1. 注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04\n\n 博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题\n\n2. exploit string用工具`hex/2raw`构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。\n\nwriteup的附录A介绍了多种`hex/2raw`接受输入字符串并传递给ctarget的多种方式，我习惯用：<br />`./hex2raw < exploit_string.txt | ./ctarget -q`<br />这条命令将`exploit_string.txt`作为`hex2raw`的输入，并建立管道将`hex2raw`的输出传输到`./ctarget`中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行`./hex2raw`那么将无法中止输入\n<a name=\"Kk3w5\"></a>\n## phase_1\n\n1. 反汇编`ctarget`：可用`objdump -d ctarget`获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585087533-3d1cfcba-4dd9-41f4-8cc8-bb4c35b8674f.png#averageHue=%231b1b1b&clientId=u2c7b2c0d-00ea-4&from=paste&height=40&id=u07c104d6&name=image.png&originHeight=60&originWidth=1223&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=26128&status=done&style=none&taskId=u6e9b8aa5-d406-4587-b032-e270697a03a&title=&width=815.3333333333334)<br />这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了\n\n2. `vim dis_ctarget.asm`查看`getbuf`函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者`test`函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看`touch1`函数，它的地址在`0x004017c0`处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585873581-353e1114-4253-4b23-aceb-6ba85c12e660.png#averageHue=%231c1c1c&clientId=u2c7b2c0d-00ea-4&from=paste&height=318&id=ub151bf36&name=image.png&originHeight=477&originWidth=1375&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=178834&status=done&style=none&taskId=u661b7e64-355d-4240-a2ac-0d48718019c&title=&width=916.6666666666666)\n\n3. `vim phase_1.txt`输入\n\n $\\begin{matrix}\n  &00  &00  &00  &00  &00  &00  &00 &00 \\\\\n  &00 &00  & 00 &00  &00  &00  &00 &00 \\\\\n  &00  &00  &00  &00 &00  &00  &00  &00\\\\\n  &00  &00  &00  &00  &00  &00  &00  &00\\\\\n  &00  &00  &00  &00  &00  &00  &00  &00\\\\\n  &c0 &17  &40  &00  &00  &00  &00\n\\end{matrix}$<br />最后留了一个字节以供gets放入' \\n ' (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677586525442-cc13fc97-7de2-4bc6-90c7-bdb9356cc9b4.png#averageHue=%231c1c1c&clientId=u2c7b2c0d-00ea-4&from=paste&height=196&id=u93bb9ade&name=image.png&originHeight=294&originWidth=1896&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=129168&status=done&style=none&taskId=u503e0466-2b33-4b30-9a9e-f21980d78e7&title=&width=1264)\n<a name=\"xCSRi\"></a>\n## phase_2\n\n1. 编写汇编代码，转化为字节码：`vim asb.s`，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637642575-745a9de7-6e49-4ef0-9f44-46dbe3cfb8a0.png#averageHue=%23232323&clientId=u7f8a8b62-e84b-4&from=paste&height=62&id=uc88e8483&name=image.png&originHeight=93&originWidth=380&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15349&status=done&style=none&taskId=u1fe3d97e-2ee2-4e3f-b2f0-921ac53df4e&title=&width=253.33333333333334)<br />line1将`cookie`值赋给`%rdi`传参给`touch2`；ine2将2`touch2`的地址压入栈中，目的在于在`ret`指令执行后，从栈中弹出并赋值给`%rip`的返回地址是`touch2`的地址<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637347348-81a97333-5ab5-4766-b689-e0a40d50a9b1.png#averageHue=%23131313&clientId=u7f8a8b62-e84b-4&from=paste&height=221&id=u494680d1&name=image.png&originHeight=331&originWidth=1165&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=130023&status=done&style=none&taskId=u8d81b4ca-fd2a-4ce9-ba46-d1e09ded02c&title=%E8%8E%B7%E5%8F%96touch2%E7%9A%84%E5%9C%B0%E5%9D%80&width=776.6666666666666 \"获取touch2的地址\")<br />writeup的附录B提示我们将gcc与objdump结合使用产生指令序列的字节码<br />`gcc -c asb.s`<br />`objdump -d asb.o > asb.d`<br />这样我们就得到了指令序列的字节码，可用于构造exploit_string<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638192080-ecafc66a-645a-4bf0-a9d2-af3a00412381.png#averageHue=%23191918&clientId=u7f8a8b62-e84b-4&from=paste&height=203&id=u9041b219&name=image.png&originHeight=304&originWidth=962&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=84296&status=done&style=none&taskId=ue5e430b5-0a7a-42c3-8791-f51017acec7&title=&width=641.3333333333334)\n\n2. 构造`phase_2.txt`，因为`asb.o`中的代码本身就已经逆序，所以直接输入即可；用于覆盖`test`栈帧中返回地址的值可由`%rsp`的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是`%rsp`的值\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677591555601-28a75db3-4efc-445a-bd75-67d6722d57ee.png#averageHue=%231d1d1d&clientId=u2c7b2c0d-00ea-4&from=paste&height=359&id=pvcAu&name=image.png&originHeight=539&originWidth=1175&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=188389&status=done&style=none&taskId=u8ffbde5e-78e3-433e-a1a6-dfa4742b694&title=%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%80%BC&width=783.3333333333334 \"获取栈顶值\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638376139-5fb21190-4237-424f-a168-1c204bce6ef7.png#averageHue=%231b1b1b&clientId=u7f8a8b62-e84b-4&from=paste&height=406&id=ud656f730&name=image.png&originHeight=609&originWidth=806&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=117050&status=done&style=none&taskId=u39e09168-0d44-4223-a419-2cad498a46f&title=phase_2_exploit_string&width=537.3333333333334 \"phase_2_exploit_string\")\n\n3. 攻击生效\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638454464-852c44b4-14f9-43fe-8e9f-a927c267b260.png#averageHue=%230b0b0b&clientId=u7f8a8b62-e84b-4&from=paste&height=233&id=ua99fc494&name=image.png&originHeight=349&originWidth=1225&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146341&status=done&style=none&taskId=uba333293-f36a-4b4a-bd6b-7ab4d63bd03&title=&width=816.6666666666666)\n<a name=\"TVVPU\"></a>\n## phase_3\n\n1. 与`phase_2`很像，但这次要传递的参数是字符串形式的`cookie`。因为`getbuf`的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串`cookie`放在`test`函数的栈帧中，地址`0x5561dca8`；获取`touch3`函数的地址，编写攻击代码\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677673769317-083e3c3d-3eb7-4716-8b34-154511f96d34.png#averageHue=%231c1c1c&clientId=ub6cccc71-6474-4&from=paste&height=236&id=ufe6c6401&name=image.png&originHeight=354&originWidth=1183&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=123850&status=done&style=none&taskId=ue426e205-3b8c-42f1-a2ca-516774edd68&title=&width=788.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678328785-d2f2582c-e25c-484b-83d8-4a0a2595ab07.png#averageHue=%23060606&clientId=ub6cccc71-6474-4&from=paste&height=61&id=u15b6d558&name=image.png&originHeight=91&originWidth=347&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11449&status=done&style=none&taskId=u1ce98f2a-043c-4c00-b0a0-20b0f14e918&title=&width=231.33333333333334)\n\n2. `ascii -ax`查看十六进制形式的ascii-table，得出`\"59b997fa\"`的ascii形式为`35 39 62 39 39 37 66 61`\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678551264-8b3b6a28-3390-45cb-bbc6-b20f241eb472.png#averageHue=%231d1d1d&clientId=ub6cccc71-6474-4&from=paste&height=247&id=u95244bf5&name=image.png&originHeight=370&originWidth=1204&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=116378&status=done&style=none&taskId=u6e6beaa6-64b0-4c0c-ba41-3a88510ea43&title=&width=802.6666666666666)\n\n3. 覆盖返回地址和test栈帧，写入攻击代码的地址和字符串`cookie`\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678755332-3ea51646-6c2b-4212-8f6a-d6fe5551fa9a.png#averageHue=%23202020&clientId=ub6cccc71-6474-4&from=paste&height=210&id=u5caf20c9&name=image.png&originHeight=315&originWidth=871&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=61586&status=done&style=none&taskId=uc183fab2-b53c-4109-9912-d5f30dc3d02&title=&width=580.6666666666666)\n\n4. 攻击生效\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678782689-4f003174-6f36-4200-87cd-d46e586d9907.png#averageHue=%231d1d1d&clientId=ub6cccc71-6474-4&from=paste&height=235&id=u145918cd&name=image.png&originHeight=353&originWidth=1184&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=131718&status=done&style=none&taskId=u08615a2d-ec29-45b1-bc0c-7f9a93e2212&title=&width=789.3333333333334)\n<a name=\"UnHwd\"></a>\n## phase_4\n确定攻击方案：`rtarget`由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用`ctarget`自身的代码实现攻击，具体做法是通过地址跳转，截取`ctarget`的部分代码用作攻击代码；`gadget`指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串`gadget`的地址，那么一旦执行其中一个`gadget`，`ret`指令就会不断的从栈中弹出新的`gadget`的地址赋给`%rip`,由此引发多个`gadget`的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）\n\n1. `cookie`的值不可能从`rgadget`中找到，需要我们自己放到栈中，如同`phase_3`一样，放的位置不能是`getbuf`的缓冲区，因此我们将其放到`test`的栈帧中；接着要实现`mov $0x59b997fa,%rdi`，需执行`popq %rdi`，根据writeup的参照表，先在`start_farm`和`end_farm`之间寻找`5f`，结果没有，但是找到了`58 90`,地址为`0x004019ab`，这代表`popq %rax  nop`，因此我们需要用`%rax`作介质传递`cookie`给`%rdi`，而在farm中我们也确实找到了`movq %rax, %rdi：48 89 c7`，地址为`0x004019c5`，一共用到了两个`gadget`\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748308138-674aa437-9522-414c-afcf-828967ad2c1b.png#averageHue=%231f1f1f&clientId=u0689b11d-a2d1-4&from=paste&height=82&id=ueb5eeaef&name=image.png&originHeight=123&originWidth=1061&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44128&status=done&style=none&taskId=u3043295b-c67b-407d-81b2-642907b3b41&title=&width=707.3333333333334)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748250489-e3dcf01c-ae26-4997-a969-4efde7d2c835.png#averageHue=%231c1b1b&clientId=u0689b11d-a2d1-4&from=paste&height=163&id=ube7f5b3e&name=image.png&originHeight=244&originWidth=1060&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=73997&status=done&style=none&taskId=ub3c3a582-4fc1-4e85-ac8e-de93a3fa7d2&title=&width=706.6666666666666)\n\n2. 按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒\n\n![yuque_diagram.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750944719-6ccf095c-ffce-4020-8cb6-f5b0f0fde9f8.png#averageHue=%2310222d&clientId=u0689b11d-a2d1-4&from=ui&height=546&id=u0eb7edee&name=yuque_diagram.png&originHeight=1110&originWidth=380&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=38484&status=done&style=none&taskId=uf668df10-5035-4532-8f4f-6e2ef500940&title=&width=187)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677751046005-10305a9e-443a-4de9-9d53-344ef204db84.png#averageHue=%23202020&clientId=u0689b11d-a2d1-4&from=paste&height=186&id=u3879cf7f&name=image.png&originHeight=279&originWidth=762&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=62095&status=done&style=none&taskId=uef71dd0c-5925-4f87-8c3b-ca049535c44&title=&width=508)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750954828-918501d5-682b-4638-ac25-f66bced64fb7.png#averageHue=%231c1c1c&clientId=u0689b11d-a2d1-4&from=paste&height=235&id=u61b7152b&name=image.png&originHeight=353&originWidth=1387&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=128770&status=done&style=none&taskId=u3e63c29c-34df-412e-b6ae-c66bfaa71c6&title=&width=924.6666666666666)\n\n\n","source":"_posts/csapp-lab.md","raw":"---\ntitle: \"[csapp] datalab, bomblab, attacklab\"\ndate: 2023/03/06\ncategories:\n- CSAPP\ntags: \n- Foundation\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"IR5gF\"></a>\n# lab1 dataLab\n<!--more-->\n<a name=\"RKm5i\"></a>\n## 前提\n确保有一个linux系统，并已经执行过以下两条命令:<br />安装gcc：`sudo apt-get install build-essential`  <br />安装[gcc的交叉编译环境](https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea).)：`sudo apt-get install gcc-multilib`，因为实验的程序需要以32位方式编译<br />在[CMU的CSAPP网站](http://csapp.cs.cmu.edu/3e/labs.html)上下载实验所需资料，包括**README, Writeup，Self-Study Handout，**这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件\n<a name=\"IOcHR\"></a>\n## 1.bitXor(x,y)\n要用~和&实现异或^，即将结果中 1-0，0-1对应的位设置为1<br />x&y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br />(~x&~y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br />两个做交集即为结果。（位向量可以表示集合，&，|，~可视为 交，并，补操作）\n```cpp\n/*\nbitXor - x^y using only ~ and & \nExample: bitXor(4, 5) = 1\nLegal ops: ~ &\nMax ops: 14\nRating: 1\n*/\nint bitXor(int x, int y) {\n    return  ~(x&y) & ~(~x&~y) ; // if regardless '+' is illegal:(~x&y) + ((x)&(~y)) or ~((x&y) + ((~x)&(~y)))\n}\n```\n<a name=\"mB5XE\"></a>\n## 2.tmin\n最简单的一题：`000...001` --> `1000...000`\n```cpp\n/* \ntmin - return minimum two's complement integer \nLegal ops: ! ~ & ^ | + << >>\nMax ops: 4\nRating: 1\n*/\nint tmin(void) {\n  return 1<<31;\n}\n```\n<a name=\"pr9MQ\"></a>\n## 3.isTmax(x)\n这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了`!((~x) + (~x))`，但[测试结果出乎意料](https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471)，加法溢出导致了未知的行为。<br />根据 Tmax +1 = Tmin 的性质可以得出 ,  `100...000` + `011...111` = `111..1111` (-1)，可得出`!(~x^(x+1))`（^可替换为+）<br />处理特例-1： -1同样会产生结果1，根据 `-1+1==0`,`Tmax+1!=0`，进而`!(-1+1) !=0` ，`!(Tmax+1) ==0`.<br />所以`对Tmax, x+(x+1) = x` , `对-1,x+(x+1)!=x`<br />用`x+(x+1)` 替换原式中的第一项x，最终得出结果：`!(~((x+!(x+1))^(x+1)))`\n```cpp\n/*\nisTmax - returns 1 if x is the maximum, two's complement number,\nand 0 otherwise \negal ops: ! ~ & ^ | +\nMax ops: 10\nRating: 1\n*/\nint isTmax(int x) {\n  return !(~((x+!(x+1)) ^ (x+1))) ; \n   // !((~x) + (~x));  it should be right, the operator \"!\" seem to not work\n}\n```\n<a name=\"kHLgK\"></a>\n## 4.allOddBits(x)\n这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br />用好异或即可解决：构造`101...1010`，再用该数提取x中的奇数位，最后再与`101...1010`比较\n```cpp\n/* \nallOddBits - return 1 if all odd-numbered bits in word set to 1\nwhere bits are numbered from 0 (least significant) to 31 (most significant)\nExamples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\nLegal ops: ! ~ & ^ | + << >>\nMax ops: 12\nRating: 2\n*/\nint allOddBits(int x) {\n  int allOdd = (0xAA << 24) + (0xAA << 16) + (0xAA << 8) + 0xAA; // 10101010..101\n  return ! ((allOdd & x) ^ allOdd);   \n}\n```\n<a name=\"sswhY\"></a>\n## 5.isAsciiDigit(x)\n有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验---用异或执行比较操作。<br />x的最后四位，3bit 与 1,2bit不能同时为1，因而有`!((x&mask2)^mask2) + (!((x&mask3)^mask3)))`，难点在于怎么处理好式中三部分的逻辑关系\n```cpp\n/* \n * isAsciiDigit - return 1 if 0x30 <= x <= 0x39 (ASCII codes for characters '0' to '9')\n *   Example: isAsciiDigit(0x35) = 1.\n *            isAsciiDigit(0x3a) = 0.\n *            isAsciiDigit(0x05) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 3\n */\nint isAsciiDigit(int x) {\n  int mask1 = 0x3;   // 000...0011\n  int mask2 = 0xA;   // 1010\n  int mask3 = 0xC;   // 1100\n  return  !( ((x>>4)^mask1) | (!((x&mask2)^mask2) + (!((x&mask3)^mask3)) ) );\n}\n```\n<a name=\"DZZaa\"></a>\n## 6.conditional\n比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br />涉及的操作是把x转化为0与1两个值，再把`000...0001`转化为`111...1111`\n```cpp\n/* \n * conditional - same as x ? y : z \n *   Example: conditional(2,4,5) = 4\n *   Legal ops: ! ~ & ^ | + << >> \n *   Max ops: 16\n *   Rating: 3\n */\nint conditional(int x, int y, int z) {\n  int  judge = !(x ^ 0x0); // x=0 -> judge=1,whereas x!=0 -> judge=0\n  judge = (judge << 31)>>31; // 000...000 or 111...111\n  return ((~judge)&y) | (judge&z);\n}\n```\n<a name=\"MZZvz\"></a>\n## 7.isLessOrEqual(x, y)\n可通过减法`y-x>=0`判断`x<=y`，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br />那么这题就涉及加法溢出,需要对` x+uw  y `结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br />更好的想法是**分析式子**`**y-x**`**并加入一个conditional操作**：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。\n```cpp\n/* \n * isLessOrEqual - if x <= y  then return 1, else return 0 \n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) \n{\n  int Tmin = 1<<31; // 100...0000\n  int signY = Tmin & y;\n  int signX = Tmin & x;\n  int judge = (signY ^ signX)<<31; \n  x = (~x)+1;\n  return (judge&signX) | (~(judge>>31) & !((y+x)&Tmin)) ; // \n}\n```\n<a name=\"WP1Li\"></a>\n## 8.logicalNeg(x)\n这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br />于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的**positive overflow**现象，即 Tmax + x ，对任意x>0均会使结果变为负数，符号位由0 -->1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致[undefined behavior](http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3)）\n```cpp\n/* \n * logicalNeg - implement the ! operator, using all of \n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logi'calNeg(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4 \n */\nint logicalNeg(int x) {\n  int Tmin = 1<<31;\n  int Tmax = ~Tmin;\n  int signX = ((x&Tmin)>>31) & 0x1;\n  return (signX^0x1) & ((((x + Tmax)>>31)&0x1)^0x1);\n}\n```\n<a name=\"Y5Acb\"></a>\n## 9.howManyBits(x)\n这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：**当数的符号位为1时，将数按符号位扩展之后其值不会变**，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br />要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -> 0010)<br />按二分法逐步缩小范围，找到最左边的1\n```cpp\n/* howManyBits - return the minimum number of bits required to represent x in\n *             two's complement\n *  Examples: howManyBits(12) = 5\n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4\n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ & ^ | + << >>\n *  Max ops: 90\n *  Rating: 4\n */\nint howManyBits(int x) {\n  int b16,b8,b4,b2,b1,b0;\n  int signX = x>>31;\n  x = ((~signX) & x) | (signX&(~x));// if x is negative, let sign bit:1-> 0\n  \n  b16 = (!!(x>>16))<<4; // ensure high 16 bits exist 1 or not\n  x=x>>b16;\n  b8 = (!!(x>>8))<<3; // ensure high 8 bits \n  x=x>>b8;\n  b4 = (!!(x>>4))<<2; // ensure high 4 bits \n  x=x>>b4;  \n  b2 = (!!(x>>2))<<1; // ensure high 2 bits \n  x=x>>b2; \n  b1 = !!(x>>1); // ensure 31 bits or not \n  x = x>>b1;\n  b0 = x;\n  \n  return b0+b1+b2+b4+b8+b16+1; // 1: sign bit\n}\n```\n<a name=\"glYde\"></a>\n## 10.floatScale2(uf)\n先对题目做出一点解释：传入一个`unsigned`类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br />**整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论**<br />注意点：对normalized，f*2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么`frac = frac <<1`，这也使得denormalized能转化到normalized (smoothly)\n```cpp\n//float\n/* \n * floatScale2 - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument    // revision: NaN or infinity\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatScale2(unsigned uf) {\n  int musk_exp,musk_frac,sign,exp,frac,result;\n  musk_exp = 0xFF << 23;\n  musk_frac = 0x7FFFFF;\n  exp = (uf & musk_exp)>>23;\n  frac = uf & musk_frac;\n  sign = 0x1<<31 & uf;\n  result = 5;\n  if(exp == 0xFF  ) // NaN\n     result = uf;\n  else if(exp == 0x0) // denormalized\n  {  \n     if(frac == 0x0)\n     {\n        if(sign)  // -0.0\n           result = uf;\n        else     // +0.0\n           result = 0 ;\n     }\n     \n     else\n     {\n        frac = frac << 1;\n        result = sign+ (exp<<23) + frac;\n     }\n  }\n  \n  else if(exp != 0x0 && exp != 0xFF) // normalized\n  {\n     exp += 1;\n     result = sign+ (exp<<23) + frac;\n  }\n  return result;\n}\n```\n<a name=\"tO8yh\"></a>\n## 11.floatFloat2Int(uf)\n浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br />对题目的解释：返回浮点数f的int型表示，如输入`12345.0 (0x4640E400)`, 正确输出为`12345 (0x3039)`<br />注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E>31时，属于out of range\n```cpp\n/* \n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\n \nint floatFloat2Int(unsigned uf) {\n  int musk_exp,musk_frac,exp,frac,sign,E,Bias,result;\n  musk_exp = 0xFF << 23;\n  musk_frac = 0x7FFFFF;\n  exp = (uf & musk_exp)>>23;\n  frac = uf & musk_frac;\n  sign = 0x1<<31 & uf;\n  Bias = 127;\n  result = 5;\n  if(exp == 0xFF  ) // NaN or infinity\n     result = 0x80000000u;\n     \n  else if(exp == 0x0)\n     result = 0;\n     \n  else if(exp != 0x0 && exp != 0xFF) // normalized\n  {\n     E = exp -Bias;  // bit_num of fraction\n     if(E < 0)\n        result = 0;\n     else if (E>31)\n        result = 0x80000000u;\n     else\n     {\n        frac = frac>>(23-E);\n        result = (0x1 << E) + frac ; \n        if(sign == 0x1<<31)\n           result = - result;\n     }\n  }\n  \n  return result;\n}\n```\n<a name=\"UlJMS\"></a>\n## 12.floatPower2(x)\n注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large\n```cpp\n/* \n * floatPower2 - Return bit-level equivalent of the expression 2.0^x\n *   (2.0 raised to the power x) for any 32-bit integer x.\n *\n *   The unsigned value that is returned should have the identical bit\n *   representation as the single-precision floating-point number 2.0^x.\n *   If the result is too small to be represented as a denorm, return\n *   0. If too large, return +INF.\n * \n *   Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while \n *   Max ops: 30 \n *   Rating: 4\n */\nunsigned floatPower2(int x) {\n  int exp,frac,E,Bias,result;\n  Bias = 127;\n  result = 5;\n  E = x;\n  if(x<1 && x!=0)\n     return 0;\n\n  else if(x >= 0x1 || x == 0)\n  {\n     frac = 0x0;\n     exp = E+Bias;\n     if(exp > 254)  // 1111 1110\n        {\n           exp = 0xFF;\n           result = exp <<23+frac;         \n        }\n     else\n        result = (exp<<23) + frac; \n  }    \n  \n  return result ;\n}\n```\n<a name=\"iHsuB\"></a>\n## consequence\n`make`<br />`./driver.pl`\n<a name=\"SLl25\"></a>\n### ![data_lab_success.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1669795434321-27bd7778-bde0-4d21-9ae0-425e1e785bd1.png#averageHue=%230d0c0c&clientId=u8b4f2be4-4c9f-4&from=ui&id=ue9c8e7dc&name=data_lab_success.png&originHeight=631&originWidth=1162&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183673&status=done&style=none&taskId=u00d5bd76-a7dc-4107-8697-fafe865d7ec&title=)\n\n---\n\n<a name=\"FsQk5\"></a>\n# lab2 bombLab\n<a name=\"mm3BW\"></a>\n## phase_1\n\n1. 反汇编`main`函数：`read_line`函数之后寄存器`%rax`和`%rdi`存储了我们输入的字符串的首地址(后续的phase都是如此)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677142575501-aadca48e-4054-40dc-977b-4719009de3e3.png#averageHue=%2362372c&clientId=u40dabece-2d53-4&from=paste&height=113&id=u7f5a75e8&name=image.png&originHeight=113&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65961&status=done&style=none&taskId=u19a9cc96-f38d-462d-9d4b-fbdd1e6cd16&title=&width=1058)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163430669-16842232-e1ab-4ac7-a90d-8f9a18e1c5d2.png#averageHue=%232d2d2d&clientId=u40dabece-2d53-4&from=paste&height=128&id=u1267f1f6&name=image.png&originHeight=128&originWidth=1060&originalType=binary&ratio=1&rotation=0&showTitle=true&size=59576&status=done&style=none&taskId=ufdd9544b-0308-49f4-86fd-49a8013d976&title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%281%29&width=1060 \"验证%rdi指向输入字符串(1)\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163457263-f780263b-09ed-4875-bafc-0f00d7e8e894.png#averageHue=%23323232&clientId=u40dabece-2d53-4&from=paste&height=77&id=ubbe401e0&name=image.png&originHeight=77&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=true&size=31472&status=done&style=none&taskId=u152fe82b-0961-427e-bd1e-8a6755f1504&title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%282%29&width=723 \"验证%rdi指向输入字符串(2)\")\n\n2. 反汇编`strings_not_equal`函数：该函数在输入字符串与目的字符串相同时，将寄存器`%rax`（通常用作函数返回值）赋值为0 (1 vice versa)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143001741-9ecdcda9-b9a6-4b31-a450-5d80ed226850.png#averageHue=%23302f2f&clientId=u40dabece-2d53-4&from=paste&height=147&id=u575b769d&name=image.png&originHeight=147&originWidth=1140&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79269&status=done&style=none&taskId=u9916894f-f032-4f63-b09d-6ce04314c3f&title=&width=1140)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143020716-757eda92-ee3e-4fe0-9c1b-597af2e24eab.png#averageHue=%23323131&clientId=u40dabece-2d53-4&from=paste&height=214&id=uca455390&name=image.png&originHeight=214&originWidth=973&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98661&status=done&style=none&taskId=u7c4aadd7-6706-4e4d-8a95-2e31a1df894&title=&width=973)\n\n3. 反汇编`phase_1`函数：`strings_not_equal`函数返回值为0时，`test %eax, %eax`能使`je 0x400ef7<phase_1+23>`执行，phase_1 defused (explode vice versa)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143312955-e1e9a80c-1730-48ae-84f7-5dfded69d3a9.png#averageHue=%232e2d2d&clientId=u40dabece-2d53-4&from=paste&height=361&id=ue40fcfa2&name=image.png&originHeight=361&originWidth=1126&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206173&status=done&style=none&taskId=u54ecca10-9722-4536-ba3f-f972c656feb&title=&width=1126)\n\n4. 至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用`strings_not_equal`函数之前赋值的`%esi：0x402400`寄存器中\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143752561-a0f86e1a-fc9c-4ff2-b386-d8d929f293c5.png#averageHue=%23333333&clientId=u40dabece-2d53-4&from=paste&height=102&id=ua334cc19&name=image.png&originHeight=102&originWidth=1118&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39885&status=done&style=none&taskId=u26286ab1-642e-4f50-9434-8d65b1add7d&title=&width=1118)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143789980-9946be38-59bb-4852-bd3c-72747f67fc16.png#averageHue=%23333333&clientId=u40dabece-2d53-4&from=paste&height=152&id=u0cd1b8f0&name=image.png&originHeight=152&originWidth=1065&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69532&status=done&style=none&taskId=u1b6e1505-7e71-4000-8504-44c050e2921&title=&width=1065)\n<a name=\"aPHyw\"></a>\n## phase_2\n\n1. 反汇编`read_six_numbers`函数：可以推断出其实现了`sscanf(input, \"%d %d %d %d %d %d\",&a1,&a2,&a3,&a4,&a5,&a6)`的功能，其中`&a1~&a6`分别在1)`%rcx:0x4(%rsi)`2)`%r8:0x8(%rsi)`3)`%r9:0xc(%rsi)`4)`%rsp:0x10(%rsi)`5)`0x8(%rsp):0x14(%rsi), 0x18(%rsi) ` 前3个指针存储在寄存器中传递给`sscanf`函数，后三个指针存储在为`read_six_numbers`函数分配的栈空间中,可以推断出`%rsi`为一个含有六个元素的数组的首地址\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677148614935-cd29c501-e2a8-4185-9924-0829124ef293.png#averageHue=%232e2d2d&clientId=u40dabece-2d53-4&from=paste&height=506&id=ue62a1cc7&name=image.png&originHeight=506&originWidth=1045&originalType=binary&ratio=1&rotation=0&showTitle=false&size=292132&status=done&style=none&taskId=udf564ea8-5d5d-4db1-9fe7-6784845d360&title=&width=1045)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150202265-dda02d42-7661-48f0-9ec1-5b420d781e9d.png#averageHue=%23313131&clientId=u40dabece-2d53-4&from=paste&height=74&id=u5d32cc04&name=image.png&originHeight=74&originWidth=675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24474&status=done&style=none&taskId=u7f387e07-3b4e-4ad1-bae1-5f9cf213c77&title=&width=675)\n\n2. 反汇编`phase_2`函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150067118-dd3962a5-1458-4a3e-9399-4cf1699ca7a7.png#averageHue=%23423227&clientId=u40dabece-2d53-4&from=paste&height=656&id=u8a1ec132&name=image.png&originHeight=656&originWidth=885&originalType=binary&ratio=1&rotation=0&showTitle=false&size=478280&status=done&style=none&taskId=u1da79441-ac63-407b-ab6c-037fd3e1450&title=&width=885)\n\n3. 自此，我们可以判断出这六个数字分别是$2^0,2^1,2^2,2^3,2^4,2^5$\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677149991615-e3f805b9-b4b0-4f49-bfbf-36dc2153557b.png#averageHue=%23313131&clientId=u40dabece-2d53-4&from=paste&height=112&id=ua5f4ba93&name=image.png&originHeight=112&originWidth=782&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34849&status=done&style=none&taskId=u43537a4a-415e-4df2-b80d-0601d361576&title=&width=782)\n<a name=\"XKRDk\"></a>\n## phase_3\n\n1. 反汇编`phase_3`：从`(%esi)`的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(`cmpl 0x7,0x8(rsp)`)，并根据这个值执行间接跳转操作(`jmp *0x402470(,rax,8)`)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150892423-92750918-b2b5-4aa5-9b0e-e08eec5cffdd.png#averageHue=%23141313&clientId=u40dabece-2d53-4&from=paste&height=150&id=uf4734a85&name=image.png&originHeight=150&originWidth=1074&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61373&status=done&style=none&taskId=u56bba885-3031-4576-9ddd-85ccf2060e9&title=&width=1074)\n\n2. 查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的`0x8(%rsp`：1 2 3 4 5 6 7\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677072562462-74d53e52-6a59-498d-9186-02f1b43b8be5.png#averageHue=%23131313&clientId=u39d47224-2023-4&from=paste&height=324&id=u10476384&name=image.png&originHeight=324&originWidth=1067&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80101&status=done&style=none&taskId=u49754a92-19b8-499c-8daf-4c666824406&title=&width=1067)\n\n3. 根据后续的赋值-跳转指令，可以得到对应的7个`0xc(%rsp)`：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151557789-3726bd23-9a03-48c7-bb2b-1a31a71ae4c0.png#averageHue=%23121212&clientId=u40dabece-2d53-4&from=paste&height=286&id=ud77abcea&name=image.png&originHeight=327&originWidth=347&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72813&status=done&style=none&taskId=uaa3da35e-6e2a-42ba-af96-025e357b784&title=&width=304)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151578594-a2486d66-586a-473a-ba87-8ed30e462b01.png#averageHue=%231e1e1e&clientId=u40dabece-2d53-4&from=paste&height=294&id=ud120ef9a&name=image.png&originHeight=391&originWidth=354&originalType=binary&ratio=1&rotation=0&showTitle=false&size=101567&status=done&style=none&taskId=ub5d0284e-6af4-4113-b8cd-89ebdce0f6d&title=&width=266)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073427546-61c8a627-e902-4132-922f-d9c30d888865.png#averageHue=%23303030&clientId=u39d47224-2023-4&from=paste&height=50&id=u47146b93&name=image.png&originHeight=75&originWidth=297&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8224&status=done&style=none&taskId=u32d95d06-a5d5-44ea-9c62-17652eea139&title=&width=197)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073446185-f50d15ab-e6e5-4d7f-b87a-7c41585c225e.png#averageHue=%232f2f2f&clientId=u39d47224-2023-4&from=paste&height=47&id=ue4a4e105&name=image.png&originHeight=70&originWidth=287&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8707&status=done&style=none&taskId=u21abdc4b-34e0-4b23-8ae8-6a213e06389&title=&width=192)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073458555-0aefc97d-f40a-4b0b-8e5e-1c592d1478fb.png#averageHue=%23313131&clientId=u39d47224-2023-4&from=paste&height=51&id=u12915178&name=image.png&originHeight=74&originWidth=307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8649&status=done&style=none&taskId=u884bf4d9-3d42-48e3-9d32-a6cc91f0115&title=&width=212)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073483221-c6634274-ca68-4d70-b35d-bcf9c12bc64d.png#averageHue=%23292929&clientId=u39d47224-2023-4&from=paste&height=48&id=u8a9d1cb9&name=image.png&originHeight=71&originWidth=296&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10382&status=done&style=none&taskId=u3d742e48-f459-45a3-abcb-5a2e46a9698&title=&width=201)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073498912-78462783-24d1-48c5-bd9c-dc0efd391d71.png#averageHue=%232a2a29&clientId=u39d47224-2023-4&from=paste&height=47&id=uc7e8ea56&name=image.png&originHeight=75&originWidth=290&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11606&status=done&style=none&taskId=u579ff7da-06cc-49aa-bbb5-7d665920365&title=&width=183)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073505761-bdd3ef17-0fcd-491a-8c9d-c021bd67b4a8.png#averageHue=%23272727&clientId=u39d47224-2023-4&from=paste&height=53&id=u656875e3&name=image.png&originHeight=78&originWidth=307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11833&status=done&style=none&taskId=u1ec87705-b895-47c3-98cb-1da89ebe401&title=&width=208)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073525247-e99ecac4-12c7-4929-ac87-722029dcb4fd.png#averageHue=%23303030&clientId=u39d47224-2023-4&from=paste&height=49&id=uaaf9dd91&name=image.png&originHeight=74&originWidth=316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8976&status=done&style=none&taskId=u262b648d-9811-41df-9106-07a991aca4a&title=&width=208)\n<a name=\"Qae7S\"></a>\n## phase_4\n\n1. 反汇编`phase_4`函数：开头部分具有与`phase_3`函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(`cmpl $0xe, 0x8(%rsp)`)，之后函数调用`func4`函数，传入三个参数`%edx`, `%esi`, `0x8(%rsp)`。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(`test %eax, %eax`)。后续的`cmpl $0x0, 0xc(%rsp)`足以确定第2个值为0\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206362623-39fe4977-5cab-4016-9003-2541d41dbe6a.png#averageHue=%232a2823&clientId=u15f83395-fa33-4&from=paste&height=416&id=ubcbcc5b1&name=image.png&originHeight=587&originWidth=1125&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=601648&status=done&style=none&taskId=ucd50703b-cd59-4e1b-b4f1-5fefbaddeb2&title=&width=797)\n\n2. 反汇编`func4`函数：出现了`func4`调用自身的情况，所以`func4`是一个递归函数。第1部分将`%rax`赋值为`%edx`-`%esi`,再加上它的最高位(`%rax >> 31`)，接着执行算数右移。这里加上最高位的原因在于，当后续`%rax`在递归中值减少为-1时，最高位是符号位1，两者相加能保证`%rax`始终大于等于0，结合后续汇编内容，可以推断出第一个值`0x8(%rsp)`应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果`%ecx > %edi`，那么就使`%ecx`变为`%esi`到`%edx`的中间值(`lea -0x1(%rcx), %edx`)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回`phase_4`的`%rax`值为1\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677204842268-34841e29-56e5-4d63-9e9f-b1576cec24a4.png#averageHue=%232b2a2a&clientId=u15f83395-fa33-4&from=paste&height=562&id=u81eba999&name=image.png&originHeight=843&originWidth=1305&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=520895&status=done&style=none&taskId=u37b9260f-a9c9-4dd9-abb9-dd995610f26&title=&width=870)\n\n3. 自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206164369-fa35758d-403b-483b-ad52-af80ef73df84.png#averageHue=%232c2c2c&clientId=u15f83395-fa33-4&from=paste&height=49&id=u3b0eedfa&name=image.png&originHeight=74&originWidth=649&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17085&status=done&style=none&taskId=ub467ca8a-a273-4b74-b425-f72d9e99ae4&title=&width=432.6666666666667)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206214348-cbc56dfd-faed-4afb-8859-c6bb00e4be62.png#averageHue=%232c2c2c&clientId=u15f83395-fa33-4&from=paste&height=49&id=ub80967c2&name=image.png&originHeight=74&originWidth=686&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17880&status=done&style=none&taskId=u78e1925a-de3d-4ff7-a76b-00e4657dd48&title=&width=457.3333333333333)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206249049-10571826-c506-4fdf-bcae-4ca9487bd383.png#averageHue=%232d2d2d&clientId=u15f83395-fa33-4&from=paste&height=46&id=u3c92002a&name=image.png&originHeight=75&originWidth=713&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17666&status=done&style=none&taskId=u81f0177a-9477-484d-bc60-f8009a91d73&title=&width=435.3333435058594)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206271742-0b02d5c9-234f-465e-9fb7-6a9cb6c3b2f3.png#averageHue=%232c2c2c&clientId=u15f83395-fa33-4&from=paste&height=49&id=u0a7235e4&name=image.png&originHeight=73&originWidth=674&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17218&status=done&style=none&taskId=u48f4584a-4771-47be-b5b5-5281e909d12&title=&width=449.3333333333333)\n<a name=\"Kxq7k\"></a>\n## phase_5\n\n1. 反汇编`phase_5`函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)\n```c\nint index\nint i = 0 // %rax\ndo{\nindex = *(input+i);\nindex = index& 0xf; // take lower four bits\ndest[0] = source[index]; // dest: (%rsp+0x10+%rax) source: 0x4024b0\nif(string_not_equal(dest, target) == 0) // target: 0x40245e --- \"flyers\"\n      //defuse\nelse\n   explode_bomb();\n}while(i>6)\n```\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227102569-50a0daeb-22b8-4911-84ee-83283088ca0d.png#averageHue=%23211710&clientId=ub432d06a-c081-4&from=paste&height=629&id=u029c0758&name=image.png&originHeight=944&originWidth=901&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=467386&status=done&style=none&taskId=uaa2e377e-a27a-4e06-9129-f19ece505a9&title=&width=600.6666666666666)\n\n2. 分别查看`source: 0x4024b0`和`target: 0x40245e`处的字符串，我们要做的就是使输入字符串形成的索引值能够从`0x4024b0`处的字符集中提取出 \"flyers\"\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227207876-48a2e806-f23e-49ec-982e-698183c7bc19.png#averageHue=%23151515&clientId=ub432d06a-c081-4&from=paste&height=52&id=u3302b9b7&name=image.png&originHeight=78&originWidth=1766&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=39766&status=done&style=none&taskId=u6f4121a7-1717-4bf8-9d35-1f34adc43a8&title=&width=1177.3333333333333)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227244326-73d2e1d2-8fa8-4452-bb1c-64b132ecd786.png#averageHue=%23131313&clientId=ub432d06a-c081-4&from=paste&height=49&id=u7ad1cd69&name=image.png&originHeight=73&originWidth=906&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18317&status=done&style=none&taskId=u0a7a9ee0-efaa-4b08-8a9e-6e726ed5958&title=&width=604)\n\n3. 我们的输入字符串每个字符在内存中占一个byte，`movzbl (%rbx, %rax, 1), %ecx`说明了一次循环提取一个字符，并只取该字符的低四位(`and $0xf, %edx`)作为索引值\n4. 首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228092474-185f8fde-3015-4a64-ae85-2a4931bb2ca9.png#averageHue=%23191919&clientId=ub432d06a-c081-4&from=paste&height=72&id=u2762ccc0&name=image.png&originHeight=108&originWidth=741&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24485&status=done&style=none&taskId=u4d7584c2-7474-4bc2-8df3-b7710936568&title=&width=494)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228432835-1ddc8d9b-d067-4d80-82c1-d63b067d6c25.png#averageHue=%23191919&clientId=ub432d06a-c081-4&from=paste&height=71&id=uaf8564a8&name=image.png&originHeight=107&originWidth=705&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24585&status=done&style=none&taskId=ud201852c-7855-4553-8543-43f2a63028c&title=&width=470)\n<a name=\"BuuHr\"></a>\n## phase_6\n\n1. thinking process\n```c\nphase_6(input)\n{\nint a1 = 0;  // %r12d\nint* input_copy = input; // mov %rsp, %r13\nint val; // %eax\n\nwhile(1)\n{\n    val = *(input_copy); // 0x0(%r13)\n    val = val-1;\n    if(val>5)  explode()  // 元素值不得大于6\n        \n    ++a1; // add $0x1, %r12d\n    if(a1 == 6) break; // jmp 95\n    int a2 = a1; // mov %r12d, %ebx\n    do{   // 65\n        val = *(input+a2);\n        if(val == *input_copy)\n            explode();\n        ++a2;\n        }while(a2<= 5 ) // 87\n    ++input_copy; // add $0x4, %r13\n} // 93\n/*两个信息：(已验证)\n1. 输入字符串中所有元素不大于6\n2. 输入字符串中所有元素互不相等 */ 0~6\n\nint* sentry = input+6; // mov 0x18(%rsp), %rsi   95\nint* input_copy_2 = input; // %rax\nint a3 = 7; // %edx, %ecx\ndo{\n    *(input_copy_2) = a3 - *(input_copy_2);\n    ++input_copy_2;\n}while(input_copy_2 != sentry)\n/* 更新输入字符串所有值为：7-初始值(已证实), \n结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */\n \nint a4 = 0; // 123 %esi  -- index\nint a5; // %edx\nint a6; // %eax  -- index\noffset_166:\nif(input[a4] <= 1) // 166  %ecx\n{\n    a5 = 0x6032d0; // 143\n    offset_148:\n    *(input+0x20+2*a4) = a5; // 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48\n                             //   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320   \n    a4 += 4; // add $0x4, %rsi \n    if(a4 ==  24 )\n        goto offset_183; // 161 \n    else \n        goto offset_166;\n}\nelse  // 均要走这个else， 可能有一个不走这个else -->肯定有一个不走\n{\n    a6 = 1;  // 171  \n    &a5 = 0x6032d0; // 176  这个地址+0x8能多次跳转\n    do{ // 130\n        a5 = *(&a5 + 0x8) ; // mov 0x8(%rdx),%rdx  链表?\n        ++a6; \n    }while(a6 != *(input+a4) ) // 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)\n    goto offset_148;         // recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5\n} // 181\n\noffset_183：    function: link node in order\nint a7 = input[8]; //%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address\nint* input_copy_3 = input+10 // %rax  0x28(%rsp)\nint* input_copy_4 = input+20 // %rsi  0x50(%rsp)\na3 = a7; // a3:%rcx\nwhile(1){ // 201\n    a5 = *input_copy_3; //a5:%rdx [10][12]...[18][20] 6\n    *(a3+0x8) = a5; // 0x8(%rcx)\n    input_copy_3 += 2; // 0x8 \n    if(input_copy_3 == input_copy_4) break; // 215 \n    a3 = a5; // mov %rdx, %rcx\n}    //   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)\n// 结束时 %rdx = * (input + 18)\n\n*(*(input+18) + 2 ) = 0; // 222   set last node's pointer to nullptr\nint a8 = 5; // %ebp\nint a9 // %rax \ndo\n{\n &a9 = *(a7+2); // %rax   initial a7 = input[8]\n  a9 = *a9; // mov (%rax), %eax\nif(*(*(input+8)) < a9) // cmp %eax, (%rbx) \n    explode();   // 验证是否降序\na7 = *(*(input+8)+2); // mov 0x8(%rbx), %rbx 更新%rbx  \n--a8;\n}while(a8>0)\n\n}\n// over\n    \n/*inital:\n0x14c(0): 332;\n0x0a8(1): 168;\n0x39c(2): 924;\n0x2b3(3): 691\n0x1dd(4): 477\n0x1bb(5): 443\n\n2->3->4->5->0->1 */\n\n\n```\n\n2. 我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是`0x6032d0`这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使`0x6032d0`这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677403752602-71565a7a-ae83-4e0e-a0d7-cdd2e3df1fd5.png#averageHue=%23232222&clientId=u54232b82-dfec-4&from=paste&height=165&id=u5a9db9de&name=image.png&originHeight=248&originWidth=1501&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=164901&status=done&style=none&taskId=u365af322-15ad-46fb-9cfc-245887947ea&title=list%20after%20sort&width=1000.6666666666666 \"list after sort\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677402131273-de3ea8a9-669e-4bf2-8194-cccb235cd58b.png#averageHue=%23282828&clientId=u54232b82-dfec-4&from=paste&height=217&id=ucd4dd2ed&name=image.png&originHeight=325&originWidth=1104&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146781&status=done&style=none&taskId=u67c0a4b5-d060-40b2-9b3c-921a69962c7&title=&width=736)\n<a name=\"QjpMp\"></a>\n## secret_phase\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404056138-294107ed-6f1c-4477-83c9-44b00041ef4b.png#averageHue=%232a2929&clientId=u54232b82-dfec-4&from=paste&height=152&id=u674c8aa7&name=image.png&originHeight=228&originWidth=1213&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42994&status=done&style=none&taskId=u89aa5f1c-7b78-46bb-b51c-a2062f218dc&title=&width=808.6666666666666)\n\n1. 发现彩蛋\n\n以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用`objdump -t bomb`查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404753141-3d41a656-d41d-476c-aae5-e51421f24d6e.png#averageHue=%230b0b0a&clientId=u54232b82-dfec-4&from=paste&height=338&id=u59b20a1e&name=image.png&originHeight=507&originWidth=1706&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=217929&status=done&style=none&taskId=ub07a14e6-ebf4-4769-b55c-e586658a966&title=&width=1137.3333333333333)\n\n2. 怎么触发\n\n1)谁调用了secret_phase：`secret_phase`既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在`main`函数中寻找可能调用`secret_base`的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在`phase_defused`函数中，反汇编`phase_defused`函数，果然发现了调用`secret_phase`的指令<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404954528-c0e39bd3-077e-49cd-a460-d820f2047ce8.png#averageHue=%232b2a2a&clientId=u54232b82-dfec-4&from=paste&height=488&id=u9e4e339a&name=image.png&originHeight=732&originWidth=1266&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=459111&status=done&style=none&taskId=u6d1b7d59-0bf7-4df3-9948-00a20fc914f&title=&width=844)<br />2）在phase_defused中如何触发：从`main`函数可以看出，bomb文件在每次未触发炸弹而执行完一个phase的时候都会调用一次`phase_defused`。分析phase_defused，该函数当输入字符串表示分隔的数字值时，如果数字个数小于6个，直接返回，对应phase1~phase5；如果数字等于6个，继续执行，对应phase6<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414713624-83322f4b-2b99-42ce-9152-3c094464743d.png#averageHue=%232a2a29&clientId=u54232b82-dfec-4&from=paste&height=167&id=u4e91d4e7&name=image.png&originHeight=251&originWidth=1753&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=206560&status=done&style=none&taskId=u8107d152-8bbe-44eb-beb6-bd477c6e492&title=&width=1168.6666666666667)<br />接着从地址`0x603870`处读取两个数字，一个字符串<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414792269-cc61be84-af1a-449f-b88a-efdf5b602450.png#averageHue=%23262626&clientId=u54232b82-dfec-4&from=paste&height=52&id=u54634d3d&name=image.png&originHeight=78&originWidth=676&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=25535&status=done&style=none&taskId=uf1933c57-b4a3-46a2-a583-11eeb6c7623&title=&width=450.6666666666667)<br />经过验证，地址`0x603870`为phase_4阶段输入字符串的开始地址<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414872028-db9b7aa7-d78c-450a-877d-8d643d89022d.png#averageHue=%23272626&clientId=u54232b82-dfec-4&from=paste&height=52&id=u20d9ba63&name=image.png&originHeight=78&originWidth=763&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=32367&status=done&style=none&taskId=uf4f5ab27-77d8-4b6a-9614-34ea9d69b04&title=&width=508.6666666666667)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414887631-8de449af-6eff-4f20-9632-860f0d751f77.png#averageHue=%232b2b2b&clientId=u54232b82-dfec-4&from=paste&height=51&id=u78a64d3f&name=image.png&originHeight=76&originWidth=856&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=31655&status=done&style=none&taskId=u1f45d585-4254-407d-a785-6859f161d5b&title=&width=570.6666666666666)<br />根据后续逻辑，只要在phase_4阶段时输入`\"7 0 DrEvil\"`即可触发`secret_bomb`<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415081966-c8dd9474-52be-4ca5-b73b-da79cea387f2.png#averageHue=%232b2a2a&clientId=u54232b82-dfec-4&from=paste&height=289&id=uff04a21c&name=image.png&originHeight=434&originWidth=1193&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=295794&status=done&style=none&taskId=uc3d47c14-4fd2-4066-8097-d303800fa51&title=&width=795.3333333333334)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415023030-75fb6b08-160a-41a7-ac0c-2cd054c806ee.png#averageHue=%23272727&clientId=u54232b82-dfec-4&from=paste&height=53&id=u647b3556&name=image.png&originHeight=79&originWidth=501&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19252&status=done&style=none&taskId=ubfabe50b-c88f-4d79-8759-413c728c17a&title=&width=334)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415142283-f37e926f-a289-4c18-9170-346e631d561e.png#averageHue=%232a2a2a&clientId=u54232b82-dfec-4&from=paste&height=361&id=uc5b1fa4e&name=image.png&originHeight=542&originWidth=1158&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=228864&status=done&style=none&taskId=u4bbc5a61-2cb2-48b7-95b7-d8b064cb1ad&title=&width=772)\n\n3. 终章：拆解secret_phase\n\n1）反编译secret_base\n```c\nsecret_phase()\n{\n    int input_2;// (%rdi)\n    &input_2 = read_line(); //  %rdi\n    \n    int a1 = 0xa; // %edx\n    int a2 = 0x0; // %esi\n    long int input_num_1 = strtol(input_2); // %rax\n    long int input_num_2 = input_num_1 // %rbx\n    input_num_1 -= 1; \n    if(input_num_1 > 0x3e8 /*1000*/) explode();\n    // 输入的数字字符串 值小于 1001\n    a2 = input_num_2;// mov %ebx, %esi  \n    &input_2 = 0x6030f0;\n    int ret = fun7(&input_2,a2,input_num_1); // ret_value: %rax\n    \n    if(ret == 0x2)\n        defused();\n    else\n        explode(); \n}\n\nint fun7(&input_2, a2, input_num_1)\n{\n    if(&input_2 == 0x0) return -1; // avoid endless recursion\n    int a3 = *(&input_2);  // 9 %edx   initial a3 = 24\n    if(a3 <= a2) goto offset_28; // 13  a2是输入值 \n\n    // a3 > a2\n    input_2 = *(&input_2 + 0x8); // +2  turn left\n    input_num_1 = fun7(&input_2, a2, input_num_1); // 19\n\n    input_num_1 *= 2; // input_num_q is 1 here\n    return input_num_1;\n\n    offset_28:\n    input_num_1 = 0;\n    if(a3 == a2) return input_num_1;\t\n\n    // a3 < a2\n    input_2 = *(&input_2 + 0x10); // +4   turn right\n    input_num_1 = fun7(&input_2, a2, input_num_1); // 0\n    input_num_1 = 2*input_num_1 + 1;  // 1\n    return input_num_1;\n}\n\n```\n2）有了phase_6的经验，我在查看了特殊地址`0x6030f0`的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址`0x6030f0`为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合`secret_phase`的逻辑，在子函数`fun7`返回值为2时defuse，经过分析，`fun7`这个递归函数，在最后三次递归时为turn left(`&input_2 + 0x8`）->turn right(`&input_2 + 0x10`) -> return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484445488-99b96bb8-8026-406a-8606-b6ed814389d7.png#averageHue=%232b2b2b&clientId=u289fcf2a-d904-4&from=paste&height=565&id=u5030ad8b&name=image.png&originHeight=848&originWidth=1530&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=595091&status=done&style=none&taskId=uf7e602a3-1dfa-4402-88da-6b6d06e26db&title=&width=1020)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484586007-34081aec-ae5a-409a-9270-7503f23d697b.png#averageHue=%23fefefe&clientId=u289fcf2a-d904-4&from=paste&height=268&id=u3886e51a&name=image.png&originHeight=321&originWidth=613&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=45328&status=done&style=none&taskId=uc94db6c6-0837-40f5-8324-986eeadfa19&title=&width=511.66668701171875)<br />3) 至此，整个bomblab就结束了，花费了我十多个小时完成了这个lab还是很值得的，伴随这一个又一个defuse，成就感是满满的，哈哈哈<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484822762-1f6d54b5-8a8f-405e-ab5b-b3de5c095440.png#averageHue=%232d2d2d&clientId=u289fcf2a-d904-4&from=paste&height=309&id=ua22fc755&name=image.png&originHeight=463&originWidth=1657&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=276450&status=done&style=none&taskId=ua2ea40a4-48b8-410d-a36d-c5de36dd026&title=&width=1104.6666666666667)\n\n---\n\n<a name=\"SLpu6\"></a>\n# lab3 attacklab\n<a name=\"UbCO7\"></a>\n## 前提\n\n1. 注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04\n\n 博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题\n\n2. exploit string用工具`hex/2raw`构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。\n\nwriteup的附录A介绍了多种`hex/2raw`接受输入字符串并传递给ctarget的多种方式，我习惯用：<br />`./hex2raw < exploit_string.txt | ./ctarget -q`<br />这条命令将`exploit_string.txt`作为`hex2raw`的输入，并建立管道将`hex2raw`的输出传输到`./ctarget`中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行`./hex2raw`那么将无法中止输入\n<a name=\"Kk3w5\"></a>\n## phase_1\n\n1. 反汇编`ctarget`：可用`objdump -d ctarget`获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585087533-3d1cfcba-4dd9-41f4-8cc8-bb4c35b8674f.png#averageHue=%231b1b1b&clientId=u2c7b2c0d-00ea-4&from=paste&height=40&id=u07c104d6&name=image.png&originHeight=60&originWidth=1223&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=26128&status=done&style=none&taskId=u6e9b8aa5-d406-4587-b032-e270697a03a&title=&width=815.3333333333334)<br />这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了\n\n2. `vim dis_ctarget.asm`查看`getbuf`函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者`test`函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看`touch1`函数，它的地址在`0x004017c0`处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585873581-353e1114-4253-4b23-aceb-6ba85c12e660.png#averageHue=%231c1c1c&clientId=u2c7b2c0d-00ea-4&from=paste&height=318&id=ub151bf36&name=image.png&originHeight=477&originWidth=1375&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=178834&status=done&style=none&taskId=u661b7e64-355d-4240-a2ac-0d48718019c&title=&width=916.6666666666666)\n\n3. `vim phase_1.txt`输入\n\n $\\begin{matrix}\n  &00  &00  &00  &00  &00  &00  &00 &00 \\\\\n  &00 &00  & 00 &00  &00  &00  &00 &00 \\\\\n  &00  &00  &00  &00 &00  &00  &00  &00\\\\\n  &00  &00  &00  &00  &00  &00  &00  &00\\\\\n  &00  &00  &00  &00  &00  &00  &00  &00\\\\\n  &c0 &17  &40  &00  &00  &00  &00\n\\end{matrix}$<br />最后留了一个字节以供gets放入' \\n ' (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677586525442-cc13fc97-7de2-4bc6-90c7-bdb9356cc9b4.png#averageHue=%231c1c1c&clientId=u2c7b2c0d-00ea-4&from=paste&height=196&id=u93bb9ade&name=image.png&originHeight=294&originWidth=1896&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=129168&status=done&style=none&taskId=u503e0466-2b33-4b30-9a9e-f21980d78e7&title=&width=1264)\n<a name=\"xCSRi\"></a>\n## phase_2\n\n1. 编写汇编代码，转化为字节码：`vim asb.s`，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637642575-745a9de7-6e49-4ef0-9f44-46dbe3cfb8a0.png#averageHue=%23232323&clientId=u7f8a8b62-e84b-4&from=paste&height=62&id=uc88e8483&name=image.png&originHeight=93&originWidth=380&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15349&status=done&style=none&taskId=u1fe3d97e-2ee2-4e3f-b2f0-921ac53df4e&title=&width=253.33333333333334)<br />line1将`cookie`值赋给`%rdi`传参给`touch2`；ine2将2`touch2`的地址压入栈中，目的在于在`ret`指令执行后，从栈中弹出并赋值给`%rip`的返回地址是`touch2`的地址<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637347348-81a97333-5ab5-4766-b689-e0a40d50a9b1.png#averageHue=%23131313&clientId=u7f8a8b62-e84b-4&from=paste&height=221&id=u494680d1&name=image.png&originHeight=331&originWidth=1165&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=130023&status=done&style=none&taskId=u8d81b4ca-fd2a-4ce9-ba46-d1e09ded02c&title=%E8%8E%B7%E5%8F%96touch2%E7%9A%84%E5%9C%B0%E5%9D%80&width=776.6666666666666 \"获取touch2的地址\")<br />writeup的附录B提示我们将gcc与objdump结合使用产生指令序列的字节码<br />`gcc -c asb.s`<br />`objdump -d asb.o > asb.d`<br />这样我们就得到了指令序列的字节码，可用于构造exploit_string<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638192080-ecafc66a-645a-4bf0-a9d2-af3a00412381.png#averageHue=%23191918&clientId=u7f8a8b62-e84b-4&from=paste&height=203&id=u9041b219&name=image.png&originHeight=304&originWidth=962&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=84296&status=done&style=none&taskId=ue5e430b5-0a7a-42c3-8791-f51017acec7&title=&width=641.3333333333334)\n\n2. 构造`phase_2.txt`，因为`asb.o`中的代码本身就已经逆序，所以直接输入即可；用于覆盖`test`栈帧中返回地址的值可由`%rsp`的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是`%rsp`的值\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677591555601-28a75db3-4efc-445a-bd75-67d6722d57ee.png#averageHue=%231d1d1d&clientId=u2c7b2c0d-00ea-4&from=paste&height=359&id=pvcAu&name=image.png&originHeight=539&originWidth=1175&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=188389&status=done&style=none&taskId=u8ffbde5e-78e3-433e-a1a6-dfa4742b694&title=%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%80%BC&width=783.3333333333334 \"获取栈顶值\")<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638376139-5fb21190-4237-424f-a168-1c204bce6ef7.png#averageHue=%231b1b1b&clientId=u7f8a8b62-e84b-4&from=paste&height=406&id=ud656f730&name=image.png&originHeight=609&originWidth=806&originalType=binary&ratio=1.5&rotation=0&showTitle=true&size=117050&status=done&style=none&taskId=u39e09168-0d44-4223-a419-2cad498a46f&title=phase_2_exploit_string&width=537.3333333333334 \"phase_2_exploit_string\")\n\n3. 攻击生效\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638454464-852c44b4-14f9-43fe-8e9f-a927c267b260.png#averageHue=%230b0b0b&clientId=u7f8a8b62-e84b-4&from=paste&height=233&id=ua99fc494&name=image.png&originHeight=349&originWidth=1225&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146341&status=done&style=none&taskId=uba333293-f36a-4b4a-bd6b-7ab4d63bd03&title=&width=816.6666666666666)\n<a name=\"TVVPU\"></a>\n## phase_3\n\n1. 与`phase_2`很像，但这次要传递的参数是字符串形式的`cookie`。因为`getbuf`的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串`cookie`放在`test`函数的栈帧中，地址`0x5561dca8`；获取`touch3`函数的地址，编写攻击代码\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677673769317-083e3c3d-3eb7-4716-8b34-154511f96d34.png#averageHue=%231c1c1c&clientId=ub6cccc71-6474-4&from=paste&height=236&id=ufe6c6401&name=image.png&originHeight=354&originWidth=1183&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=123850&status=done&style=none&taskId=ue426e205-3b8c-42f1-a2ca-516774edd68&title=&width=788.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678328785-d2f2582c-e25c-484b-83d8-4a0a2595ab07.png#averageHue=%23060606&clientId=ub6cccc71-6474-4&from=paste&height=61&id=u15b6d558&name=image.png&originHeight=91&originWidth=347&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11449&status=done&style=none&taskId=u1ce98f2a-043c-4c00-b0a0-20b0f14e918&title=&width=231.33333333333334)\n\n2. `ascii -ax`查看十六进制形式的ascii-table，得出`\"59b997fa\"`的ascii形式为`35 39 62 39 39 37 66 61`\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678551264-8b3b6a28-3390-45cb-bbc6-b20f241eb472.png#averageHue=%231d1d1d&clientId=ub6cccc71-6474-4&from=paste&height=247&id=u95244bf5&name=image.png&originHeight=370&originWidth=1204&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=116378&status=done&style=none&taskId=u6e6beaa6-64b0-4c0c-ba41-3a88510ea43&title=&width=802.6666666666666)\n\n3. 覆盖返回地址和test栈帧，写入攻击代码的地址和字符串`cookie`\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678755332-3ea51646-6c2b-4212-8f6a-d6fe5551fa9a.png#averageHue=%23202020&clientId=ub6cccc71-6474-4&from=paste&height=210&id=u5caf20c9&name=image.png&originHeight=315&originWidth=871&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=61586&status=done&style=none&taskId=uc183fab2-b53c-4109-9912-d5f30dc3d02&title=&width=580.6666666666666)\n\n4. 攻击生效\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678782689-4f003174-6f36-4200-87cd-d46e586d9907.png#averageHue=%231d1d1d&clientId=ub6cccc71-6474-4&from=paste&height=235&id=u145918cd&name=image.png&originHeight=353&originWidth=1184&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=131718&status=done&style=none&taskId=u08615a2d-ec29-45b1-bc0c-7f9a93e2212&title=&width=789.3333333333334)\n<a name=\"UnHwd\"></a>\n## phase_4\n确定攻击方案：`rtarget`由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用`ctarget`自身的代码实现攻击，具体做法是通过地址跳转，截取`ctarget`的部分代码用作攻击代码；`gadget`指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串`gadget`的地址，那么一旦执行其中一个`gadget`，`ret`指令就会不断的从栈中弹出新的`gadget`的地址赋给`%rip`,由此引发多个`gadget`的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）\n\n1. `cookie`的值不可能从`rgadget`中找到，需要我们自己放到栈中，如同`phase_3`一样，放的位置不能是`getbuf`的缓冲区，因此我们将其放到`test`的栈帧中；接着要实现`mov $0x59b997fa,%rdi`，需执行`popq %rdi`，根据writeup的参照表，先在`start_farm`和`end_farm`之间寻找`5f`，结果没有，但是找到了`58 90`,地址为`0x004019ab`，这代表`popq %rax  nop`，因此我们需要用`%rax`作介质传递`cookie`给`%rdi`，而在farm中我们也确实找到了`movq %rax, %rdi：48 89 c7`，地址为`0x004019c5`，一共用到了两个`gadget`\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748308138-674aa437-9522-414c-afcf-828967ad2c1b.png#averageHue=%231f1f1f&clientId=u0689b11d-a2d1-4&from=paste&height=82&id=ueb5eeaef&name=image.png&originHeight=123&originWidth=1061&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44128&status=done&style=none&taskId=u3043295b-c67b-407d-81b2-642907b3b41&title=&width=707.3333333333334)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748250489-e3dcf01c-ae26-4997-a969-4efde7d2c835.png#averageHue=%231c1b1b&clientId=u0689b11d-a2d1-4&from=paste&height=163&id=ube7f5b3e&name=image.png&originHeight=244&originWidth=1060&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=73997&status=done&style=none&taskId=ub3c3a582-4fc1-4e85-ac8e-de93a3fa7d2&title=&width=706.6666666666666)\n\n2. 按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒\n\n![yuque_diagram.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750944719-6ccf095c-ffce-4020-8cb6-f5b0f0fde9f8.png#averageHue=%2310222d&clientId=u0689b11d-a2d1-4&from=ui&height=546&id=u0eb7edee&name=yuque_diagram.png&originHeight=1110&originWidth=380&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=38484&status=done&style=none&taskId=uf668df10-5035-4532-8f4f-6e2ef500940&title=&width=187)![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677751046005-10305a9e-443a-4de9-9d53-344ef204db84.png#averageHue=%23202020&clientId=u0689b11d-a2d1-4&from=paste&height=186&id=u3879cf7f&name=image.png&originHeight=279&originWidth=762&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=62095&status=done&style=none&taskId=uef71dd0c-5925-4f87-8c3b-ca049535c44&title=&width=508)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750954828-918501d5-682b-4638-ac25-f66bced64fb7.png#averageHue=%231c1c1c&clientId=u0689b11d-a2d1-4&from=paste&height=235&id=u61b7152b&name=image.png&originHeight=353&originWidth=1387&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=128770&status=done&style=none&taskId=u3e63c29c-34df-412e-b6ae-c66bfaa71c6&title=&width=924.6666666666666)\n\n\n","slug":"csapp-lab","published":1,"updated":"2023-03-13T15:47:12.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfmf6v9r00041gvaf24ub5l2","content":"<p><meta name=\"referrer\" content=\"no-referrer\"><br><a name=\"IR5gF\"></a></p>\n<h1 id=\"lab1-dataLab\"><a href=\"#lab1-dataLab\" class=\"headerlink\" title=\"lab1 dataLab\"></a>lab1 dataLab</h1><span id=\"more\"></span>\n<p><a name=\"RKm5i\"></a></p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>确保有一个linux系统，并已经执行过以下两条命令:<br>安装gcc：<code>sudo apt-get install build-essential</code>  <br>安装<a href=\"https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea\">gcc的交叉编译环境</a>.)：<code>sudo apt-get install gcc-multilib</code>，因为实验的程序需要以32位方式编译<br>在<a href=\"http://csapp.cs.cmu.edu/3e/labs.html\">CMU的CSAPP网站</a>上下载实验所需资料，包括<strong>README, Writeup，Self-Study Handout，</strong>这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件<br><a name=\"IOcHR\"></a></p>\n<h2 id=\"1-bitXor-x-y\"><a href=\"#1-bitXor-x-y\" class=\"headerlink\" title=\"1.bitXor(x,y)\"></a>1.bitXor(x,y)</h2><p>要用~和&amp;实现异或^，即将结果中 1-0，0-1对应的位设置为1<br>x&amp;y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br>(~x&amp;~y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br>两个做交集即为结果。（位向量可以表示集合，&amp;，|，~可视为 交，并，补操作）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">bitXor - x^y using only ~ and &amp; </span></span><br><span class=\"line\"><span class=\"comment\">Example: bitXor(4, 5) = 1</span></span><br><span class=\"line\"><span class=\"comment\">Legal ops: ~ &amp;</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 14</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitXor</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  ~(x&amp;y) &amp; ~(~x&amp;~y) ; <span class=\"comment\">// if regardless &#x27;+&#x27; is illegal:(~x&amp;y) + ((x)&amp;(~y)) or ~((x&amp;y) + ((~x)&amp;(~y)))</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"mB5XE\"></a></p>\n<h2 id=\"2-tmin\"><a href=\"#2-tmin\" class=\"headerlink\" title=\"2.tmin\"></a>2.tmin</h2><p>最简单的一题：<code>000...001</code> —&gt; <code>1000...000</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">tmin - return minimum two&#x27;s complement integer </span></span><br><span class=\"line\"><span class=\"comment\">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 4</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tmin</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"pr9MQ\"></a></p>\n<h2 id=\"3-isTmax-x\"><a href=\"#3-isTmax-x\" class=\"headerlink\" title=\"3.isTmax(x)\"></a>3.isTmax(x)</h2><p>这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了<code>!((~x) + (~x))</code>，但<a href=\"https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471\">测试结果出乎意料</a>，加法溢出导致了未知的行为。<br>根据 Tmax +1 = Tmin 的性质可以得出 ,  <code>100...000</code> + <code>011...111</code> = <code>111..1111</code> (-1)，可得出<code>!(~x^(x+1))</code>（^可替换为+）<br>处理特例-1： -1同样会产生结果1，根据 <code>-1+1==0</code>,<code>Tmax+1!=0</code>，进而<code>!(-1+1) !=0</code> ，<code>!(Tmax+1) ==0</code>.<br>所以<code>对Tmax, x+(x+1) = x</code> , <code>对-1,x+(x+1)!=x</code><br>用<code>x+(x+1)</code> 替换原式中的第一项x，最终得出结果：<code>!(~((x+!(x+1))^(x+1)))</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class=\"line\"><span class=\"comment\">and 0 otherwise </span></span><br><span class=\"line\"><span class=\"comment\">egal ops: ! ~ &amp; ^ | +</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 10</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">isTmax</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !(~((x+!(x+<span class=\"number\">1</span>)) ^ (x+<span class=\"number\">1</span>))) ; </span><br><span class=\"line\">   <span class=\"comment\">// !((~x) + (~x));  it should be right, the operator &quot;!&quot; seem to not work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"kHLgK\"></a></p>\n<h2 id=\"4-allOddBits-x\"><a href=\"#4-allOddBits-x\" class=\"headerlink\" title=\"4.allOddBits(x)\"></a>4.allOddBits(x)</h2><p>这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br>用好异或即可解决：构造<code>101...1010</code>，再用该数提取x中的奇数位，最后再与<code>101...1010</code>比较<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class=\"line\"><span class=\"comment\">where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class=\"line\"><span class=\"comment\">Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class=\"line\"><span class=\"comment\">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 12</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">allOddBits</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> allOdd = (<span class=\"number\">0xAA</span> &lt;&lt; <span class=\"number\">24</span>) + (<span class=\"number\">0xAA</span> &lt;&lt; <span class=\"number\">16</span>) + (<span class=\"number\">0xAA</span> &lt;&lt; <span class=\"number\">8</span>) + <span class=\"number\">0xAA</span>; <span class=\"comment\">// 10101010..101</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ! ((allOdd &amp; x) ^ allOdd);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"sswhY\"></a></p>\n<h2 id=\"5-isAsciiDigit-x\"><a href=\"#5-isAsciiDigit-x\" class=\"headerlink\" title=\"5.isAsciiDigit(x)\"></a>5.isAsciiDigit(x)</h2><p>有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验—-用异或执行比较操作。<br>x的最后四位，3bit 与 1,2bit不能同时为1，因而有<code>!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)))</code>，难点在于怎么处理好式中三部分的逻辑关系<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class=\"line\"><span class=\"comment\"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class=\"line\"><span class=\"comment\"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">isAsciiDigit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> mask1 = <span class=\"number\">0x3</span>;   <span class=\"comment\">// 000...0011</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mask2 = <span class=\"number\">0xA</span>;   <span class=\"comment\">// 1010</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mask3 = <span class=\"number\">0xC</span>;   <span class=\"comment\">// 1100</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>  !( ((x&gt;&gt;<span class=\"number\">4</span>)^mask1) | (!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)) ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"DZZaa\"></a></p>\n<h2 id=\"6-conditional\"><a href=\"#6-conditional\" class=\"headerlink\" title=\"6.conditional\"></a>6.conditional</h2><p>比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br>涉及的操作是把x转化为0与1两个值，再把<code>000...0001</code>转化为<code>111...1111</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * conditional - same as x ? y : z </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: conditional(2,4,5) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; </span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 16</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">conditional</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> z)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>  judge = !(x ^ <span class=\"number\">0x0</span>); <span class=\"comment\">// x=0 -&gt; judge=1,whereas x!=0 -&gt; judge=0</span></span><br><span class=\"line\">  judge = (judge &lt;&lt; <span class=\"number\">31</span>)&gt;&gt;<span class=\"number\">31</span>; <span class=\"comment\">// 000...000 or 111...111</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((~judge)&amp;y) | (judge&amp;z);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"MZZvz\"></a></p>\n<h2 id=\"7-isLessOrEqual-x-y\"><a href=\"#7-isLessOrEqual-x-y\" class=\"headerlink\" title=\"7.isLessOrEqual(x, y)\"></a>7.isLessOrEqual(x, y)</h2><p>可通过减法<code>y-x&gt;=0</code>判断<code>x&lt;=y</code>，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br>那么这题就涉及加法溢出,需要对<code>x+uw  y</code>结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br>更好的想法是<strong>分析式子</strong><code>**y-x**</code><strong>并加入一个conditional操作</strong>：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 24</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">isLessOrEqual</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> Tmin = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>; <span class=\"comment\">// 100...0000</span></span><br><span class=\"line\">  <span class=\"type\">int</span> signY = Tmin &amp; y;</span><br><span class=\"line\">  <span class=\"type\">int</span> signX = Tmin &amp; x;</span><br><span class=\"line\">  <span class=\"type\">int</span> judge = (signY ^ signX)&lt;&lt;<span class=\"number\">31</span>; </span><br><span class=\"line\">  x = (~x)+<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (judge&amp;signX) | (~(judge&gt;&gt;<span class=\"number\">31</span>) &amp; !((y+x)&amp;Tmin)) ; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"WP1Li\"></a></p>\n<h2 id=\"8-logicalNeg-x\"><a href=\"#8-logicalNeg-x\" class=\"headerlink\" title=\"8.logicalNeg(x)\"></a>8.logicalNeg(x)</h2><p>这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br>于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的<strong>positive overflow</strong>现象，即 Tmax + x ，对任意x&gt;0均会使结果变为负数，符号位由0 —&gt;1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致<a href=\"http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3\">undefined behavior</a>）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class=\"line\"><span class=\"comment\"> *              the legal operators except !</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: logicalNeg(3) = 0, logi&#x27;calNeg(0) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 12</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">logicalNeg</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> Tmin = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> Tmax = ~Tmin;</span><br><span class=\"line\">  <span class=\"type\">int</span> signX = ((x&amp;Tmin)&gt;&gt;<span class=\"number\">31</span>) &amp; <span class=\"number\">0x1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (signX^<span class=\"number\">0x1</span>) &amp; ((((x + Tmax)&gt;&gt;<span class=\"number\">31</span>)&amp;<span class=\"number\">0x1</span>)^<span class=\"number\">0x1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"Y5Acb\"></a></p>\n<h2 id=\"9-howManyBits-x\"><a href=\"#9-howManyBits-x\" class=\"headerlink\" title=\"9.howManyBits(x)\"></a>9.howManyBits(x)</h2><p>这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：<strong>当数的符号位为1时，将数按符号位扩展之后其值不会变</strong>，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br>要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -&gt; 0010)<br>按二分法逐步缩小范围，找到最左边的1<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class=\"line\"><span class=\"comment\"> *             two&#x27;s complement</span></span><br><span class=\"line\"><span class=\"comment\"> *  Examples: howManyBits(12) = 5</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(298) = 10</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(-5) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(0)  = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(-1) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(0x80000000) = 32</span></span><br><span class=\"line\"><span class=\"comment\"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *  Max ops: 90</span></span><br><span class=\"line\"><span class=\"comment\"> *  Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">howManyBits</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class=\"line\">  <span class=\"type\">int</span> signX = x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">  x = ((~signX) &amp; x) | (signX&amp;(~x));<span class=\"comment\">// if x is negative, let sign bit:1-&gt; 0</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  b16 = (!!(x&gt;&gt;<span class=\"number\">16</span>))&lt;&lt;<span class=\"number\">4</span>; <span class=\"comment\">// ensure high 16 bits exist 1 or not</span></span><br><span class=\"line\">  x=x&gt;&gt;b16;</span><br><span class=\"line\">  b8 = (!!(x&gt;&gt;<span class=\"number\">8</span>))&lt;&lt;<span class=\"number\">3</span>; <span class=\"comment\">// ensure high 8 bits </span></span><br><span class=\"line\">  x=x&gt;&gt;b8;</span><br><span class=\"line\">  b4 = (!!(x&gt;&gt;<span class=\"number\">4</span>))&lt;&lt;<span class=\"number\">2</span>; <span class=\"comment\">// ensure high 4 bits </span></span><br><span class=\"line\">  x=x&gt;&gt;b4;  </span><br><span class=\"line\">  b2 = (!!(x&gt;&gt;<span class=\"number\">2</span>))&lt;&lt;<span class=\"number\">1</span>; <span class=\"comment\">// ensure high 2 bits </span></span><br><span class=\"line\">  x=x&gt;&gt;b2; </span><br><span class=\"line\">  b1 = !!(x&gt;&gt;<span class=\"number\">1</span>); <span class=\"comment\">// ensure 31 bits or not </span></span><br><span class=\"line\">  x = x&gt;&gt;b1;</span><br><span class=\"line\">  b0 = x;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> b0+b1+b2+b4+b8+b16+<span class=\"number\">1</span>; <span class=\"comment\">// 1: sign bit</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"glYde\"></a></p>\n<h2 id=\"10-floatScale2-uf\"><a href=\"#10-floatScale2-uf\" class=\"headerlink\" title=\"10.floatScale2(uf)\"></a>10.floatScale2(uf)</h2><p>先对题目做出一点解释：传入一个<code>unsigned</code>类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br><strong>整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论</strong><br>注意点：对normalized，f*2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么<code>frac = frac &lt;&lt;1</code>，这也使得denormalized能转化到normalized (smoothly)<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//float</span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument    // revision: NaN or infinity</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"title\">floatScale2</span><span class=\"params\">(<span class=\"type\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> musk_exp,musk_frac,sign,exp,frac,result;</span><br><span class=\"line\">  musk_exp = <span class=\"number\">0xFF</span> &lt;&lt; <span class=\"number\">23</span>;</span><br><span class=\"line\">  musk_frac = <span class=\"number\">0x7FFFFF</span>;</span><br><span class=\"line\">  exp = (uf &amp; musk_exp)&gt;&gt;<span class=\"number\">23</span>;</span><br><span class=\"line\">  frac = uf &amp; musk_frac;</span><br><span class=\"line\">  sign = <span class=\"number\">0x1</span>&lt;&lt;<span class=\"number\">31</span> &amp; uf;</span><br><span class=\"line\">  result = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(exp == <span class=\"number\">0xFF</span>  ) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">     result = uf;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp == <span class=\"number\">0x0</span>) <span class=\"comment\">// denormalized</span></span><br><span class=\"line\">  &#123;  </span><br><span class=\"line\">     <span class=\"keyword\">if</span>(frac == <span class=\"number\">0x0</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sign)  <span class=\"comment\">// -0.0</span></span><br><span class=\"line\">           result = uf;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>     <span class=\"comment\">// +0.0</span></span><br><span class=\"line\">           result = <span class=\"number\">0</span> ;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        frac = frac &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        result = sign+ (exp&lt;&lt;<span class=\"number\">23</span>) + frac;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp != <span class=\"number\">0x0</span> &amp;&amp; exp != <span class=\"number\">0xFF</span>) <span class=\"comment\">// normalized</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     exp += <span class=\"number\">1</span>;</span><br><span class=\"line\">     result = sign+ (exp&lt;&lt;<span class=\"number\">23</span>) + frac;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"tO8yh\"></a></p>\n<h2 id=\"11-floatFloat2Int-uf\"><a href=\"#11-floatFloat2Int-uf\" class=\"headerlink\" title=\"11.floatFloat2Int(uf)\"></a>11.floatFloat2Int(uf)</h2><p>浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br>对题目的解释：返回浮点数f的int型表示，如输入<code>12345.0 (0x4640E400)</code>, 正确输出为<code>12345 (0x3039)</code><br>注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E&gt;31时，属于out of range<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class=\"line\"><span class=\"comment\"> *   for floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Argument is passed as unsigned int, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point value.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class=\"line\"><span class=\"comment\"> *   0x80000000u.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">floatFloat2Int</span><span class=\"params\">(<span class=\"type\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> musk_exp,musk_frac,exp,frac,sign,E,Bias,result;</span><br><span class=\"line\">  musk_exp = <span class=\"number\">0xFF</span> &lt;&lt; <span class=\"number\">23</span>;</span><br><span class=\"line\">  musk_frac = <span class=\"number\">0x7FFFFF</span>;</span><br><span class=\"line\">  exp = (uf &amp; musk_exp)&gt;&gt;<span class=\"number\">23</span>;</span><br><span class=\"line\">  frac = uf &amp; musk_frac;</span><br><span class=\"line\">  sign = <span class=\"number\">0x1</span>&lt;&lt;<span class=\"number\">31</span> &amp; uf;</span><br><span class=\"line\">  Bias = <span class=\"number\">127</span>;</span><br><span class=\"line\">  result = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(exp == <span class=\"number\">0xFF</span>  ) <span class=\"comment\">// NaN or infinity</span></span><br><span class=\"line\">     result = <span class=\"number\">0x80000000</span>u;</span><br><span class=\"line\">     </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp == <span class=\"number\">0x0</span>)</span><br><span class=\"line\">     result = <span class=\"number\">0</span>;</span><br><span class=\"line\">     </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp != <span class=\"number\">0x0</span> &amp;&amp; exp != <span class=\"number\">0xFF</span>) <span class=\"comment\">// normalized</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     E = exp -Bias;  <span class=\"comment\">// bit_num of fraction</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(E &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        result = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (E&gt;<span class=\"number\">31</span>)</span><br><span class=\"line\">        result = <span class=\"number\">0x80000000</span>u;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        frac = frac&gt;&gt;(<span class=\"number\">23</span>-E);</span><br><span class=\"line\">        result = (<span class=\"number\">0x1</span> &lt;&lt; E) + frac ; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sign == <span class=\"number\">0x1</span>&lt;&lt;<span class=\"number\">31</span>)</span><br><span class=\"line\">           result = - result;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"UlJMS\"></a></p>\n<h2 id=\"12-floatPower2-x\"><a href=\"#12-floatPower2-x\" class=\"headerlink\" title=\"12.floatPower2(x)\"></a>12.floatPower2(x)</h2><p>注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class=\"line\"><span class=\"comment\"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class=\"line\"><span class=\"comment\"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class=\"line\"><span class=\"comment\"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class=\"line\"><span class=\"comment\"> *   0. If too large, return +INF.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30 </span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"title\">floatPower2</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> exp,frac,E,Bias,result;</span><br><span class=\"line\">  Bias = <span class=\"number\">127</span>;</span><br><span class=\"line\">  result = <span class=\"number\">5</span>;</span><br><span class=\"line\">  E = x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">1</span> &amp;&amp; x!=<span class=\"number\">0</span>)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x &gt;= <span class=\"number\">0x1</span> || x == <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     frac = <span class=\"number\">0x0</span>;</span><br><span class=\"line\">     exp = E+Bias;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(exp &gt; <span class=\"number\">254</span>)  <span class=\"comment\">// 1111 1110</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           exp = <span class=\"number\">0xFF</span>;</span><br><span class=\"line\">           result = exp &lt;&lt;<span class=\"number\">23</span>+frac;         </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">        result = (exp&lt;&lt;<span class=\"number\">23</span>) + frac; </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"iHsuB\"></a></p>\n<h2 id=\"consequence\"><a href=\"#consequence\" class=\"headerlink\" title=\"consequence\"></a>consequence</h2><p><code>make</code><br><code>./driver.pl</code><br><a name=\"SLl25\"></a></p>\n<h3 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1669795434321-27bd7778-bde0-4d21-9ae0-425e1e785bd1.png#averageHue=%230d0c0c&amp;clientId=u8b4f2be4-4c9f-4&amp;from=ui&amp;id=ue9c8e7dc&amp;name=data_lab_success.png&amp;originHeight=631&amp;originWidth=1162&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183673&amp;status=done&amp;style=none&amp;taskId=u00d5bd76-a7dc-4107-8697-fafe865d7ec&amp;title=\" alt=\"data_lab_success.png\"></h3><hr>\n<p><a name=\"FsQk5\"></a></p>\n<h1 id=\"lab2-bombLab\"><a href=\"#lab2-bombLab\" class=\"headerlink\" title=\"lab2 bombLab\"></a>lab2 bombLab</h1><p><a name=\"mm3BW\"></a></p>\n<h2 id=\"phase-1\"><a href=\"#phase-1\" class=\"headerlink\" title=\"phase_1\"></a>phase_1</h2><ol>\n<li>反汇编<code>main</code>函数：<code>read_line</code>函数之后寄存器<code>%rax</code>和<code>%rdi</code>存储了我们输入的字符串的首地址(后续的phase都是如此)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677142575501-aadca48e-4054-40dc-977b-4719009de3e3.png#averageHue=%2362372c&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=113&amp;id=u7f5a75e8&amp;name=image.png&amp;originHeight=113&amp;originWidth=1058&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65961&amp;status=done&amp;style=none&amp;taskId=u19a9cc96-f38d-462d-9d4b-fbdd1e6cd16&amp;title=&amp;width=1058\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163430669-16842232-e1ab-4ac7-a90d-8f9a18e1c5d2.png#averageHue=%232d2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=128&amp;id=u1267f1f6&amp;name=image.png&amp;originHeight=128&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=59576&amp;status=done&amp;style=none&amp;taskId=ufdd9544b-0308-49f4-86fd-49a8013d976&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%281%29&amp;width=1060\" alt=\"image.png\" title=\"验证%rdi指向输入字符串(1)\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163457263-f780263b-09ed-4875-bafc-0f00d7e8e894.png#averageHue=%23323232&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=77&amp;id=ubbe401e0&amp;name=image.png&amp;originHeight=77&amp;originWidth=723&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=31472&amp;status=done&amp;style=none&amp;taskId=u152fe82b-0961-427e-bd1e-8a6755f1504&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%282%29&amp;width=723\" alt=\"image.png\" title=\"验证%rdi指向输入字符串(2)\"></p>\n<ol>\n<li>反汇编<code>strings_not_equal</code>函数：该函数在输入字符串与目的字符串相同时，将寄存器<code>%rax</code>（通常用作函数返回值）赋值为0 (1 vice versa)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143001741-9ecdcda9-b9a6-4b31-a450-5d80ed226850.png#averageHue=%23302f2f&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=147&amp;id=u575b769d&amp;name=image.png&amp;originHeight=147&amp;originWidth=1140&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=79269&amp;status=done&amp;style=none&amp;taskId=u9916894f-f032-4f63-b09d-6ce04314c3f&amp;title=&amp;width=1140\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143020716-757eda92-ee3e-4fe0-9c1b-597af2e24eab.png#averageHue=%23323131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=214&amp;id=uca455390&amp;name=image.png&amp;originHeight=214&amp;originWidth=973&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98661&amp;status=done&amp;style=none&amp;taskId=u7c4aadd7-6706-4e4d-8a95-2e31a1df894&amp;title=&amp;width=973\" alt=\"image.png\"></p>\n<ol>\n<li>反汇编<code>phase_1</code>函数：<code>strings_not_equal</code>函数返回值为0时，<code>test %eax, %eax</code>能使<code>je 0x400ef7&lt;phase_1+23&gt;</code>执行，phase_1 defused (explode vice versa)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143312955-e1e9a80c-1730-48ae-84f7-5dfded69d3a9.png#averageHue=%232e2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=361&amp;id=ue40fcfa2&amp;name=image.png&amp;originHeight=361&amp;originWidth=1126&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=206173&amp;status=done&amp;style=none&amp;taskId=u54ecca10-9722-4536-ba3f-f972c656feb&amp;title=&amp;width=1126\" alt=\"image.png\"></p>\n<ol>\n<li>至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用<code>strings_not_equal</code>函数之前赋值的<code>%esi：0x402400</code>寄存器中</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143752561-a0f86e1a-fc9c-4ff2-b386-d8d929f293c5.png#averageHue=%23333333&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=102&amp;id=ua334cc19&amp;name=image.png&amp;originHeight=102&amp;originWidth=1118&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39885&amp;status=done&amp;style=none&amp;taskId=u26286ab1-642e-4f50-9434-8d65b1add7d&amp;title=&amp;width=1118\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143789980-9946be38-59bb-4852-bd3c-72747f67fc16.png#averageHue=%23333333&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=152&amp;id=u0cd1b8f0&amp;name=image.png&amp;originHeight=152&amp;originWidth=1065&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=69532&amp;status=done&amp;style=none&amp;taskId=u1b6e1505-7e71-4000-8504-44c050e2921&amp;title=&amp;width=1065\" alt=\"image.png\"><br><a name=\"aPHyw\"></a></p>\n<h2 id=\"phase-2\"><a href=\"#phase-2\" class=\"headerlink\" title=\"phase_2\"></a>phase_2</h2><ol>\n<li>反汇编<code>read_six_numbers</code>函数：可以推断出其实现了<code>sscanf(input, &quot;%d %d %d %d %d %d&quot;,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6)</code>的功能，其中<code>&amp;a1~&amp;a6</code>分别在1)<code>%rcx:0x4(%rsi)</code>2)<code>%r8:0x8(%rsi)</code>3)<code>%r9:0xc(%rsi)</code>4)<code>%rsp:0x10(%rsi)</code>5)<code>0x8(%rsp):0x14(%rsi), 0x18(%rsi)</code> 前3个指针存储在寄存器中传递给<code>sscanf</code>函数，后三个指针存储在为<code>read_six_numbers</code>函数分配的栈空间中,可以推断出<code>%rsi</code>为一个含有六个元素的数组的首地址</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677148614935-cd29c501-e2a8-4185-9924-0829124ef293.png#averageHue=%232e2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=506&amp;id=ue62a1cc7&amp;name=image.png&amp;originHeight=506&amp;originWidth=1045&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=292132&amp;status=done&amp;style=none&amp;taskId=udf564ea8-5d5d-4db1-9fe7-6784845d360&amp;title=&amp;width=1045\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150202265-dda02d42-7661-48f0-9ec1-5b420d781e9d.png#averageHue=%23313131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=74&amp;id=u5d32cc04&amp;name=image.png&amp;originHeight=74&amp;originWidth=675&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24474&amp;status=done&amp;style=none&amp;taskId=u7f387e07-3b4e-4ad1-bae1-5f9cf213c77&amp;title=&amp;width=675\" alt=\"image.png\"></p>\n<ol>\n<li>反汇编<code>phase_2</code>函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150067118-dd3962a5-1458-4a3e-9399-4cf1699ca7a7.png#averageHue=%23423227&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=656&amp;id=u8a1ec132&amp;name=image.png&amp;originHeight=656&amp;originWidth=885&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=478280&amp;status=done&amp;style=none&amp;taskId=u1da79441-ac63-407b-ab6c-037fd3e1450&amp;title=&amp;width=885\" alt=\"image.png\"></p>\n<ol>\n<li>自此，我们可以判断出这六个数字分别是$2^0,2^1,2^2,2^3,2^4,2^5$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677149991615-e3f805b9-b4b0-4f49-bfbf-36dc2153557b.png#averageHue=%23313131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=112&amp;id=ua5f4ba93&amp;name=image.png&amp;originHeight=112&amp;originWidth=782&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34849&amp;status=done&amp;style=none&amp;taskId=u43537a4a-415e-4df2-b80d-0601d361576&amp;title=&amp;width=782\" alt=\"image.png\"><br><a name=\"XKRDk\"></a></p>\n<h2 id=\"phase-3\"><a href=\"#phase-3\" class=\"headerlink\" title=\"phase_3\"></a>phase_3</h2><ol>\n<li>反汇编<code>phase_3</code>：从<code>(%esi)</code>的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(<code>cmpl 0x7,0x8(rsp)</code>)，并根据这个值执行间接跳转操作(<code>jmp *0x402470(,rax,8)</code>)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150892423-92750918-b2b5-4aa5-9b0e-e08eec5cffdd.png#averageHue=%23141313&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=150&amp;id=uf4734a85&amp;name=image.png&amp;originHeight=150&amp;originWidth=1074&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61373&amp;status=done&amp;style=none&amp;taskId=u56bba885-3031-4576-9ddd-85ccf2060e9&amp;title=&amp;width=1074\" alt=\"image.png\"></p>\n<ol>\n<li>查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的<code>0x8(%rsp</code>：1 2 3 4 5 6 7</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677072562462-74d53e52-6a59-498d-9186-02f1b43b8be5.png#averageHue=%23131313&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=324&amp;id=u10476384&amp;name=image.png&amp;originHeight=324&amp;originWidth=1067&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80101&amp;status=done&amp;style=none&amp;taskId=u49754a92-19b8-499c-8daf-4c666824406&amp;title=&amp;width=1067\" alt=\"image.png\"></p>\n<ol>\n<li>根据后续的赋值-跳转指令，可以得到对应的7个<code>0xc(%rsp)</code>：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151557789-3726bd23-9a03-48c7-bb2b-1a31a71ae4c0.png#averageHue=%23121212&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=286&amp;id=ud77abcea&amp;name=image.png&amp;originHeight=327&amp;originWidth=347&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72813&amp;status=done&amp;style=none&amp;taskId=uaa3da35e-6e2a-42ba-af96-025e357b784&amp;title=&amp;width=304\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151578594-a2486d66-586a-473a-ba87-8ed30e462b01.png#averageHue=%231e1e1e&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=294&amp;id=ud120ef9a&amp;name=image.png&amp;originHeight=391&amp;originWidth=354&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101567&amp;status=done&amp;style=none&amp;taskId=ub5d0284e-6af4-4113-b8cd-89ebdce0f6d&amp;title=&amp;width=266\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073427546-61c8a627-e902-4132-922f-d9c30d888865.png#averageHue=%23303030&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=50&amp;id=u47146b93&amp;name=image.png&amp;originHeight=75&amp;originWidth=297&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8224&amp;status=done&amp;style=none&amp;taskId=u32d95d06-a5d5-44ea-9c62-17652eea139&amp;title=&amp;width=197\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073446185-f50d15ab-e6e5-4d7f-b87a-7c41585c225e.png#averageHue=%232f2f2f&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=47&amp;id=ue4a4e105&amp;name=image.png&amp;originHeight=70&amp;originWidth=287&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8707&amp;status=done&amp;style=none&amp;taskId=u21abdc4b-34e0-4b23-8ae8-6a213e06389&amp;title=&amp;width=192\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073458555-0aefc97d-f40a-4b0b-8e5e-1c592d1478fb.png#averageHue=%23313131&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=51&amp;id=u12915178&amp;name=image.png&amp;originHeight=74&amp;originWidth=307&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8649&amp;status=done&amp;style=none&amp;taskId=u884bf4d9-3d42-48e3-9d32-a6cc91f0115&amp;title=&amp;width=212\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073483221-c6634274-ca68-4d70-b35d-bcf9c12bc64d.png#averageHue=%23292929&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=48&amp;id=u8a9d1cb9&amp;name=image.png&amp;originHeight=71&amp;originWidth=296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10382&amp;status=done&amp;style=none&amp;taskId=u3d742e48-f459-45a3-abcb-5a2e46a9698&amp;title=&amp;width=201\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073498912-78462783-24d1-48c5-bd9c-dc0efd391d71.png#averageHue=%232a2a29&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=47&amp;id=uc7e8ea56&amp;name=image.png&amp;originHeight=75&amp;originWidth=290&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11606&amp;status=done&amp;style=none&amp;taskId=u579ff7da-06cc-49aa-bbb5-7d665920365&amp;title=&amp;width=183\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073505761-bdd3ef17-0fcd-491a-8c9d-c021bd67b4a8.png#averageHue=%23272727&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=53&amp;id=u656875e3&amp;name=image.png&amp;originHeight=78&amp;originWidth=307&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11833&amp;status=done&amp;style=none&amp;taskId=u1ec87705-b895-47c3-98cb-1da89ebe401&amp;title=&amp;width=208\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073525247-e99ecac4-12c7-4929-ac87-722029dcb4fd.png#averageHue=%23303030&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=49&amp;id=uaaf9dd91&amp;name=image.png&amp;originHeight=74&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8976&amp;status=done&amp;style=none&amp;taskId=u262b648d-9811-41df-9106-07a991aca4a&amp;title=&amp;width=208\" alt=\"image.png\"><br><a name=\"Qae7S\"></a></p>\n<h2 id=\"phase-4\"><a href=\"#phase-4\" class=\"headerlink\" title=\"phase_4\"></a>phase_4</h2><ol>\n<li>反汇编<code>phase_4</code>函数：开头部分具有与<code>phase_3</code>函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(<code>cmpl $0xe, 0x8(%rsp)</code>)，之后函数调用<code>func4</code>函数，传入三个参数<code>%edx</code>, <code>%esi</code>, <code>0x8(%rsp)</code>。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(<code>test %eax, %eax</code>)。后续的<code>cmpl $0x0, 0xc(%rsp)</code>足以确定第2个值为0</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206362623-39fe4977-5cab-4016-9003-2541d41dbe6a.png#averageHue=%232a2823&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=416&amp;id=ubcbcc5b1&amp;name=image.png&amp;originHeight=587&amp;originWidth=1125&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=601648&amp;status=done&amp;style=none&amp;taskId=ucd50703b-cd59-4e1b-b4f1-5fefbaddeb2&amp;title=&amp;width=797\" alt=\"image.png\"></p>\n<ol>\n<li>反汇编<code>func4</code>函数：出现了<code>func4</code>调用自身的情况，所以<code>func4</code>是一个递归函数。第1部分将<code>%rax</code>赋值为<code>%edx</code>-<code>%esi</code>,再加上它的最高位(<code>%rax &gt;&gt; 31</code>)，接着执行算数右移。这里加上最高位的原因在于，当后续<code>%rax</code>在递归中值减少为-1时，最高位是符号位1，两者相加能保证<code>%rax</code>始终大于等于0，结合后续汇编内容，可以推断出第一个值<code>0x8(%rsp)</code>应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果<code>%ecx &gt; %edi</code>，那么就使<code>%ecx</code>变为<code>%esi</code>到<code>%edx</code>的中间值(<code>lea -0x1(%rcx), %edx</code>)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回<code>phase_4</code>的<code>%rax</code>值为1</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677204842268-34841e29-56e5-4d63-9e9f-b1576cec24a4.png#averageHue=%232b2a2a&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=562&amp;id=u81eba999&amp;name=image.png&amp;originHeight=843&amp;originWidth=1305&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=520895&amp;status=done&amp;style=none&amp;taskId=u37b9260f-a9c9-4dd9-abb9-dd995610f26&amp;title=&amp;width=870\" alt=\"image.png\"></p>\n<ol>\n<li>自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206164369-fa35758d-403b-483b-ad52-af80ef73df84.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=u3b0eedfa&amp;name=image.png&amp;originHeight=74&amp;originWidth=649&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17085&amp;status=done&amp;style=none&amp;taskId=ub467ca8a-a273-4b74-b425-f72d9e99ae4&amp;title=&amp;width=432.6666666666667\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206214348-cbc56dfd-faed-4afb-8859-c6bb00e4be62.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=ub80967c2&amp;name=image.png&amp;originHeight=74&amp;originWidth=686&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17880&amp;status=done&amp;style=none&amp;taskId=u78e1925a-de3d-4ff7-a76b-00e4657dd48&amp;title=&amp;width=457.3333333333333\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206249049-10571826-c506-4fdf-bcae-4ca9487bd383.png#averageHue=%232d2d2d&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=46&amp;id=u3c92002a&amp;name=image.png&amp;originHeight=75&amp;originWidth=713&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17666&amp;status=done&amp;style=none&amp;taskId=u81f0177a-9477-484d-bc60-f8009a91d73&amp;title=&amp;width=435.3333435058594\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206271742-0b02d5c9-234f-465e-9fb7-6a9cb6c3b2f3.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=u0a7235e4&amp;name=image.png&amp;originHeight=73&amp;originWidth=674&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17218&amp;status=done&amp;style=none&amp;taskId=u48f4584a-4771-47be-b5b5-5281e909d12&amp;title=&amp;width=449.3333333333333\" alt=\"image.png\"><br><a name=\"Kxq7k\"></a></p>\n<h2 id=\"phase-5\"><a href=\"#phase-5\" class=\"headerlink\" title=\"phase_5\"></a>phase_5</h2><ol>\n<li><p>反汇编<code>phase_5</code>函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> index</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">0</span> <span class=\"comment\">// %rax</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">index = *(input+i);</span><br><span class=\"line\">index = index&amp; <span class=\"number\">0xf</span>; <span class=\"comment\">// take lower four bits</span></span><br><span class=\"line\">dest[<span class=\"number\">0</span>] = source[index]; <span class=\"comment\">// dest: (%rsp+0x10+%rax) source: 0x4024b0</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(string_not_equal(dest, target) == <span class=\"number\">0</span>) <span class=\"comment\">// target: 0x40245e --- &quot;flyers&quot;</span></span><br><span class=\"line\">      <span class=\"comment\">//defuse</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">   explode_bomb();</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(i&gt;<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227102569-50a0daeb-22b8-4911-84ee-83283088ca0d.png#averageHue=%23211710&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=629&amp;id=u029c0758&amp;name=image.png&amp;originHeight=944&amp;originWidth=901&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=467386&amp;status=done&amp;style=none&amp;taskId=uaa2e377e-a27a-4e06-9129-f19ece505a9&amp;title=&amp;width=600.6666666666666\" alt=\"image.png\"></p>\n</li>\n<li><p>分别查看<code>source: 0x4024b0</code>和<code>target: 0x40245e</code>处的字符串，我们要做的就是使输入字符串形成的索引值能够从<code>0x4024b0</code>处的字符集中提取出 “flyers”</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227207876-48a2e806-f23e-49ec-982e-698183c7bc19.png#averageHue=%23151515&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=52&amp;id=u3302b9b7&amp;name=image.png&amp;originHeight=78&amp;originWidth=1766&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=39766&amp;status=done&amp;style=none&amp;taskId=u6f4121a7-1717-4bf8-9d35-1f34adc43a8&amp;title=&amp;width=1177.3333333333333\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227244326-73d2e1d2-8fa8-4452-bb1c-64b132ecd786.png#averageHue=%23131313&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=49&amp;id=u7ad1cd69&amp;name=image.png&amp;originHeight=73&amp;originWidth=906&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=18317&amp;status=done&amp;style=none&amp;taskId=u0a7a9ee0-efaa-4b08-8a9e-6e726ed5958&amp;title=&amp;width=604\" alt=\"image.png\"></p>\n<ol>\n<li>我们的输入字符串每个字符在内存中占一个byte，<code>movzbl (%rbx, %rax, 1), %ecx</code>说明了一次循环提取一个字符，并只取该字符的低四位(<code>and $0xf, %edx</code>)作为索引值</li>\n<li>首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228092474-185f8fde-3015-4a64-ae85-2a4931bb2ca9.png#averageHue=%23191919&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=72&amp;id=u2762ccc0&amp;name=image.png&amp;originHeight=108&amp;originWidth=741&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=24485&amp;status=done&amp;style=none&amp;taskId=u4d7584c2-7474-4bc2-8df3-b7710936568&amp;title=&amp;width=494\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228432835-1ddc8d9b-d067-4d80-82c1-d63b067d6c25.png#averageHue=%23191919&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=71&amp;id=uaf8564a8&amp;name=image.png&amp;originHeight=107&amp;originWidth=705&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=24585&amp;status=done&amp;style=none&amp;taskId=ud201852c-7855-4553-8543-43f2a63028c&amp;title=&amp;width=470\" alt=\"image.png\"><br><a name=\"BuuHr\"></a></p>\n<h2 id=\"phase-6\"><a href=\"#phase-6\" class=\"headerlink\" title=\"phase_6\"></a>phase_6</h2><ol>\n<li><p>thinking process</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">phase_6(input)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> a1 = <span class=\"number\">0</span>;  <span class=\"comment\">// %r12d</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy = input; <span class=\"comment\">// mov %rsp, %r13</span></span><br><span class=\"line\"><span class=\"type\">int</span> val; <span class=\"comment\">// %eax</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    val = *(input_copy); <span class=\"comment\">// 0x0(%r13)</span></span><br><span class=\"line\">    val = val<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(val&gt;<span class=\"number\">5</span>)  explode()  <span class=\"comment\">// 元素值不得大于6</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    ++a1; <span class=\"comment\">// add $0x1, %r12d</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a1 == <span class=\"number\">6</span>) <span class=\"keyword\">break</span>; <span class=\"comment\">// jmp 95</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a2 = a1; <span class=\"comment\">// mov %r12d, %ebx</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;   <span class=\"comment\">// 65</span></span><br><span class=\"line\">        val = *(input+a2);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(val == *input_copy)</span><br><span class=\"line\">            explode();</span><br><span class=\"line\">        ++a2;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(a2&lt;= <span class=\"number\">5</span> ) <span class=\"comment\">// 87</span></span><br><span class=\"line\">    ++input_copy; <span class=\"comment\">// add $0x4, %r13</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 93</span></span><br><span class=\"line\"><span class=\"comment\">/*两个信息：(已验证)</span></span><br><span class=\"line\"><span class=\"comment\">1. 输入字符串中所有元素不大于6</span></span><br><span class=\"line\"><span class=\"comment\">2. 输入字符串中所有元素互不相等 */</span> <span class=\"number\">0</span>~<span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span>* sentry = input+<span class=\"number\">6</span>; <span class=\"comment\">// mov 0x18(%rsp), %rsi   95</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy_2 = input; <span class=\"comment\">// %rax</span></span><br><span class=\"line\"><span class=\"type\">int</span> a3 = <span class=\"number\">7</span>; <span class=\"comment\">// %edx, %ecx</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">    *(input_copy_2) = a3 - *(input_copy_2);</span><br><span class=\"line\">    ++input_copy_2;</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(input_copy_2 != sentry)</span><br><span class=\"line\"><span class=\"comment\">/* 更新输入字符串所有值为：7-初始值(已证实), </span></span><br><span class=\"line\"><span class=\"comment\">结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">int</span> a4 = <span class=\"number\">0</span>; <span class=\"comment\">// 123 %esi  -- index</span></span><br><span class=\"line\"><span class=\"type\">int</span> a5; <span class=\"comment\">// %edx</span></span><br><span class=\"line\"><span class=\"type\">int</span> a6; <span class=\"comment\">// %eax  -- index</span></span><br><span class=\"line\">offset_166:</span><br><span class=\"line\"><span class=\"keyword\">if</span>(input[a4] &lt;= <span class=\"number\">1</span>) <span class=\"comment\">// 166  %ecx</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a5 = <span class=\"number\">0x6032d0</span>; <span class=\"comment\">// 143</span></span><br><span class=\"line\">    offset_148:</span><br><span class=\"line\">    *(input+<span class=\"number\">0x20</span>+<span class=\"number\">2</span>*a4) = a5; <span class=\"comment\">// 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48</span></span><br><span class=\"line\">                             <span class=\"comment\">//   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320   </span></span><br><span class=\"line\">    a4 += <span class=\"number\">4</span>; <span class=\"comment\">// add $0x4, %rsi </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a4 ==  <span class=\"number\">24</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> offset_183; <span class=\"comment\">// 161 </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> offset_166;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>  <span class=\"comment\">// 均要走这个else， 可能有一个不走这个else --&gt;肯定有一个不走</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a6 = <span class=\"number\">1</span>;  <span class=\"comment\">// 171  </span></span><br><span class=\"line\">    &amp;a5 = <span class=\"number\">0x6032d0</span>; <span class=\"comment\">// 176  这个地址+0x8能多次跳转</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123; <span class=\"comment\">// 130</span></span><br><span class=\"line\">        a5 = *(&amp;a5 + <span class=\"number\">0x8</span>) ; <span class=\"comment\">// mov 0x8(%rdx),%rdx  链表?</span></span><br><span class=\"line\">        ++a6; </span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(a6 != *(input+a4) ) <span class=\"comment\">// 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> offset_148;         <span class=\"comment\">// recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 181</span></span><br><span class=\"line\"></span><br><span class=\"line\">offset_183：    function: link node in order</span><br><span class=\"line\"><span class=\"type\">int</span> a7 = input[<span class=\"number\">8</span>]; <span class=\"comment\">//%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy_3 = input+<span class=\"number\">10</span> <span class=\"comment\">// %rax  0x28(%rsp)</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy_4 = input+<span class=\"number\">20</span> <span class=\"comment\">// %rsi  0x50(%rsp)</span></span><br><span class=\"line\">a3 = a7; <span class=\"comment\">// a3:%rcx</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123; <span class=\"comment\">// 201</span></span><br><span class=\"line\">    a5 = *input_copy_3; <span class=\"comment\">//a5:%rdx [10][12]...[18][20] 6</span></span><br><span class=\"line\">    *(a3+<span class=\"number\">0x8</span>) = a5; <span class=\"comment\">// 0x8(%rcx)</span></span><br><span class=\"line\">    input_copy_3 += <span class=\"number\">2</span>; <span class=\"comment\">// 0x8 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(input_copy_3 == input_copy_4) <span class=\"keyword\">break</span>; <span class=\"comment\">// 215 </span></span><br><span class=\"line\">    a3 = a5; <span class=\"comment\">// mov %rdx, %rcx</span></span><br><span class=\"line\">&#125;    <span class=\"comment\">//   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)</span></span><br><span class=\"line\"><span class=\"comment\">// 结束时 %rdx = * (input + 18)</span></span><br><span class=\"line\"></span><br><span class=\"line\">*(*(input+<span class=\"number\">18</span>) + <span class=\"number\">2</span> ) = <span class=\"number\">0</span>; <span class=\"comment\">// 222   set last node&#x27;s pointer to nullptr</span></span><br><span class=\"line\"><span class=\"type\">int</span> a8 = <span class=\"number\">5</span>; <span class=\"comment\">// %ebp</span></span><br><span class=\"line\"><span class=\"type\">int</span> a9 <span class=\"comment\">// %rax </span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> &amp;a9 = *(a7+<span class=\"number\">2</span>); <span class=\"comment\">// %rax   initial a7 = input[8]</span></span><br><span class=\"line\">  a9 = *a9; <span class=\"comment\">// mov (%rax), %eax</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(*(*(input+<span class=\"number\">8</span>)) &lt; a9) <span class=\"comment\">// cmp %eax, (%rbx) </span></span><br><span class=\"line\">    explode();   <span class=\"comment\">// 验证是否降序</span></span><br><span class=\"line\">a7 = *(*(input+<span class=\"number\">8</span>)+<span class=\"number\">2</span>); <span class=\"comment\">// mov 0x8(%rbx), %rbx 更新%rbx  </span></span><br><span class=\"line\">--a8;</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(a8&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// over</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/*inital:</span></span><br><span class=\"line\"><span class=\"comment\">0x14c(0): 332;</span></span><br><span class=\"line\"><span class=\"comment\">0x0a8(1): 168;</span></span><br><span class=\"line\"><span class=\"comment\">0x39c(2): 924;</span></span><br><span class=\"line\"><span class=\"comment\">0x2b3(3): 691</span></span><br><span class=\"line\"><span class=\"comment\">0x1dd(4): 477</span></span><br><span class=\"line\"><span class=\"comment\">0x1bb(5): 443</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">2-&gt;3-&gt;4-&gt;5-&gt;0-&gt;1 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是<code>0x6032d0</code>这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使<code>0x6032d0</code>这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677403752602-71565a7a-ae83-4e0e-a0d7-cdd2e3df1fd5.png#averageHue=%23232222&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=165&amp;id=u5a9db9de&amp;name=image.png&amp;originHeight=248&amp;originWidth=1501&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=164901&amp;status=done&amp;style=none&amp;taskId=u365af322-15ad-46fb-9cfc-245887947ea&amp;title=list%20after%20sort&amp;width=1000.6666666666666\" alt=\"image.png\" title=\"list after sort\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677402131273-de3ea8a9-669e-4bf2-8194-cccb235cd58b.png#averageHue=%23282828&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=217&amp;id=ucd4dd2ed&amp;name=image.png&amp;originHeight=325&amp;originWidth=1104&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=146781&amp;status=done&amp;style=none&amp;taskId=u67c0a4b5-d060-40b2-9b3c-921a69962c7&amp;title=&amp;width=736\" alt=\"image.png\"><br><a name=\"QjpMp\"></a></p>\n<h2 id=\"secret-phase\"><a href=\"#secret-phase\" class=\"headerlink\" title=\"secret_phase\"></a>secret_phase</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404056138-294107ed-6f1c-4477-83c9-44b00041ef4b.png#averageHue=%232a2929&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=152&amp;id=u674c8aa7&amp;name=image.png&amp;originHeight=228&amp;originWidth=1213&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=42994&amp;status=done&amp;style=none&amp;taskId=u89aa5f1c-7b78-46bb-b51c-a2062f218dc&amp;title=&amp;width=808.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>发现彩蛋</li>\n</ol>\n<p>以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用<code>objdump -t bomb</code>查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404753141-3d41a656-d41d-476c-aae5-e51421f24d6e.png#averageHue=%230b0b0a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=338&amp;id=u59b20a1e&amp;name=image.png&amp;originHeight=507&amp;originWidth=1706&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=217929&amp;status=done&amp;style=none&amp;taskId=ub07a14e6-ebf4-4769-b55c-e586658a966&amp;title=&amp;width=1137.3333333333333\" alt=\"image.png\"></p>\n<ol>\n<li>怎么触发</li>\n</ol>\n<p>1)谁调用了secret_phase：<code>secret_phase</code>既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在<code>main</code>函数中寻找可能调用<code>secret_base</code>的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在<code>phase_defused</code>函数中，反汇编<code>phase_defused</code>函数，果然发现了调用<code>secret_phase</code>的指令<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404954528-c0e39bd3-077e-49cd-a460-d820f2047ce8.png#averageHue=%232b2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=488&amp;id=u9e4e339a&amp;name=image.png&amp;originHeight=732&amp;originWidth=1266&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=459111&amp;status=done&amp;style=none&amp;taskId=u6d1b7d59-0bf7-4df3-9948-00a20fc914f&amp;title=&amp;width=844\" alt=\"image.png\"><br>2）在phase_defused中如何触发：从<code>main</code>函数可以看出，bomb文件在每次未触发炸弹而执行完一个phase的时候都会调用一次<code>phase_defused</code>。分析phase_defused，该函数当输入字符串表示分隔的数字值时，如果数字个数小于6个，直接返回，对应phase1~phase5；如果数字等于6个，继续执行，对应phase6<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414713624-83322f4b-2b99-42ce-9152-3c094464743d.png#averageHue=%232a2a29&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=167&amp;id=u4e91d4e7&amp;name=image.png&amp;originHeight=251&amp;originWidth=1753&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=206560&amp;status=done&amp;style=none&amp;taskId=u8107d152-8bbe-44eb-beb6-bd477c6e492&amp;title=&amp;width=1168.6666666666667\" alt=\"image.png\"><br>接着从地址<code>0x603870</code>处读取两个数字，一个字符串<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414792269-cc61be84-af1a-449f-b88a-efdf5b602450.png#averageHue=%23262626&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=52&amp;id=u54634d3d&amp;name=image.png&amp;originHeight=78&amp;originWidth=676&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=25535&amp;status=done&amp;style=none&amp;taskId=uf1933c57-b4a3-46a2-a583-11eeb6c7623&amp;title=&amp;width=450.6666666666667\" alt=\"image.png\"><br>经过验证，地址<code>0x603870</code>为phase_4阶段输入字符串的开始地址<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414872028-db9b7aa7-d78c-450a-877d-8d643d89022d.png#averageHue=%23272626&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=52&amp;id=u20d9ba63&amp;name=image.png&amp;originHeight=78&amp;originWidth=763&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=32367&amp;status=done&amp;style=none&amp;taskId=uf4f5ab27-77d8-4b6a-9614-34ea9d69b04&amp;title=&amp;width=508.6666666666667\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414887631-8de449af-6eff-4f20-9632-860f0d751f77.png#averageHue=%232b2b2b&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=51&amp;id=u78a64d3f&amp;name=image.png&amp;originHeight=76&amp;originWidth=856&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=31655&amp;status=done&amp;style=none&amp;taskId=u1f45d585-4254-407d-a785-6859f161d5b&amp;title=&amp;width=570.6666666666666\" alt=\"image.png\"><br>根据后续逻辑，只要在phase_4阶段时输入<code>&quot;7 0 DrEvil&quot;</code>即可触发<code>secret_bomb</code><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415081966-c8dd9474-52be-4ca5-b73b-da79cea387f2.png#averageHue=%232b2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=289&amp;id=uff04a21c&amp;name=image.png&amp;originHeight=434&amp;originWidth=1193&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=295794&amp;status=done&amp;style=none&amp;taskId=uc3d47c14-4fd2-4066-8097-d303800fa51&amp;title=&amp;width=795.3333333333334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415023030-75fb6b08-160a-41a7-ac0c-2cd054c806ee.png#averageHue=%23272727&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=53&amp;id=u647b3556&amp;name=image.png&amp;originHeight=79&amp;originWidth=501&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=19252&amp;status=done&amp;style=none&amp;taskId=ubfabe50b-c88f-4d79-8759-413c728c17a&amp;title=&amp;width=334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415142283-f37e926f-a289-4c18-9170-346e631d561e.png#averageHue=%232a2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=361&amp;id=uc5b1fa4e&amp;name=image.png&amp;originHeight=542&amp;originWidth=1158&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=228864&amp;status=done&amp;style=none&amp;taskId=u4bbc5a61-2cb2-48b7-95b7-d8b064cb1ad&amp;title=&amp;width=772\" alt=\"image.png\"></p>\n<ol>\n<li>终章：拆解secret_phase</li>\n</ol>\n<p>1）反编译secret_base<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secret_phase()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> input_2;<span class=\"comment\">// (%rdi)</span></span><br><span class=\"line\">    &amp;input_2 = read_line(); <span class=\"comment\">//  %rdi</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> a1 = <span class=\"number\">0xa</span>; <span class=\"comment\">// %edx</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a2 = <span class=\"number\">0x0</span>; <span class=\"comment\">// %esi</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">int</span> input_num_1 = strtol(input_2); <span class=\"comment\">// %rax</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">int</span> input_num_2 = input_num_1 <span class=\"comment\">// %rbx</span></span><br><span class=\"line\">    input_num_1 -= <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(input_num_1 &gt; <span class=\"number\">0x3e8</span> <span class=\"comment\">/*1000*/</span>) explode();</span><br><span class=\"line\">    <span class=\"comment\">// 输入的数字字符串 值小于 1001</span></span><br><span class=\"line\">    a2 = input_num_2;<span class=\"comment\">// mov %ebx, %esi  </span></span><br><span class=\"line\">    &amp;input_2 = <span class=\"number\">0x6030f0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = fun7(&amp;input_2,a2,input_num_1); <span class=\"comment\">// ret_value: %rax</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ret == <span class=\"number\">0x2</span>)</span><br><span class=\"line\">        defused();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        explode(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fun7</span><span class=\"params\">(&amp;input_2, a2, input_num_1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(&amp;input_2 == <span class=\"number\">0x0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// avoid endless recursion</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a3 = *(&amp;input_2);  <span class=\"comment\">// 9 %edx   initial a3 = 24</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a3 &lt;= a2) <span class=\"keyword\">goto</span> offset_28; <span class=\"comment\">// 13  a2是输入值 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a3 &gt; a2</span></span><br><span class=\"line\">    input_2 = *(&amp;input_2 + <span class=\"number\">0x8</span>); <span class=\"comment\">// +2  turn left</span></span><br><span class=\"line\">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class=\"comment\">// 19</span></span><br><span class=\"line\"></span><br><span class=\"line\">    input_num_1 *= <span class=\"number\">2</span>; <span class=\"comment\">// input_num_q is 1 here</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input_num_1;</span><br><span class=\"line\"></span><br><span class=\"line\">    offset_28:</span><br><span class=\"line\">    input_num_1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a3 == a2) <span class=\"keyword\">return</span> input_num_1;\t</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a3 &lt; a2</span></span><br><span class=\"line\">    input_2 = *(&amp;input_2 + <span class=\"number\">0x10</span>); <span class=\"comment\">// +4   turn right</span></span><br><span class=\"line\">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class=\"comment\">// 0</span></span><br><span class=\"line\">    input_num_1 = <span class=\"number\">2</span>*input_num_1 + <span class=\"number\">1</span>;  <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input_num_1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>2）有了phase_6的经验，我在查看了特殊地址<code>0x6030f0</code>的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址<code>0x6030f0</code>为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合<code>secret_phase</code>的逻辑，在子函数<code>fun7</code>返回值为2时defuse，经过分析，<code>fun7</code>这个递归函数，在最后三次递归时为turn left(<code>&amp;input_2 + 0x8</code>）-&gt;turn right(<code>&amp;input_2 + 0x10</code>) -&gt; return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484445488-99b96bb8-8026-406a-8606-b6ed814389d7.png#averageHue=%232b2b2b&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=565&amp;id=u5030ad8b&amp;name=image.png&amp;originHeight=848&amp;originWidth=1530&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=595091&amp;status=done&amp;style=none&amp;taskId=uf7e602a3-1dfa-4402-88da-6b6d06e26db&amp;title=&amp;width=1020\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484586007-34081aec-ae5a-409a-9270-7503f23d697b.png#averageHue=%23fefefe&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=268&amp;id=u3886e51a&amp;name=image.png&amp;originHeight=321&amp;originWidth=613&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=45328&amp;status=done&amp;style=none&amp;taskId=uc94db6c6-0837-40f5-8324-986eeadfa19&amp;title=&amp;width=511.66668701171875\" alt=\"image.png\"><br>3) 至此，整个bomblab就结束了，花费了我十多个小时完成了这个lab还是很值得的，伴随这一个又一个defuse，成就感是满满的，哈哈哈<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484822762-1f6d54b5-8a8f-405e-ab5b-b3de5c095440.png#averageHue=%232d2d2d&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=309&amp;id=ua22fc755&amp;name=image.png&amp;originHeight=463&amp;originWidth=1657&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=276450&amp;status=done&amp;style=none&amp;taskId=ua2ea40a4-48b8-410d-a36d-c5de36dd026&amp;title=&amp;width=1104.6666666666667\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"SLpu6\"></a></p>\n<h1 id=\"lab3-attacklab\"><a href=\"#lab3-attacklab\" class=\"headerlink\" title=\"lab3 attacklab\"></a>lab3 attacklab</h1><p><a name=\"UbCO7\"></a></p>\n<h2 id=\"前提-1\"><a href=\"#前提-1\" class=\"headerlink\" title=\"前提\"></a>前提</h2><ol>\n<li><p>注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04</p>\n<p>博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题</p>\n</li>\n<li><p>exploit string用工具<code>hex/2raw</code>构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。</p>\n</li>\n</ol>\n<p>writeup的附录A介绍了多种<code>hex/2raw</code>接受输入字符串并传递给ctarget的多种方式，我习惯用：<br><code>./hex2raw &lt; exploit_string.txt | ./ctarget -q</code><br>这条命令将<code>exploit_string.txt</code>作为<code>hex2raw</code>的输入，并建立管道将<code>hex2raw</code>的输出传输到<code>./ctarget</code>中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行<code>./hex2raw</code>那么将无法中止输入<br><a name=\"Kk3w5\"></a></p>\n<h2 id=\"phase-1-1\"><a href=\"#phase-1-1\" class=\"headerlink\" title=\"phase_1\"></a>phase_1</h2><ol>\n<li>反汇编<code>ctarget</code>：可用<code>objdump -d ctarget</code>获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585087533-3d1cfcba-4dd9-41f4-8cc8-bb4c35b8674f.png#averageHue=%231b1b1b&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=40&amp;id=u07c104d6&amp;name=image.png&amp;originHeight=60&amp;originWidth=1223&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=26128&amp;status=done&amp;style=none&amp;taskId=u6e9b8aa5-d406-4587-b032-e270697a03a&amp;title=&amp;width=815.3333333333334\" alt=\"image.png\"><br>这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了</p>\n<ol>\n<li><code>vim dis_ctarget.asm</code>查看<code>getbuf</code>函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者<code>test</code>函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看<code>touch1</code>函数，它的地址在<code>0x004017c0</code>处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585873581-353e1114-4253-4b23-aceb-6ba85c12e660.png#averageHue=%231c1c1c&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=318&amp;id=ub151bf36&amp;name=image.png&amp;originHeight=477&amp;originWidth=1375&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=178834&amp;status=done&amp;style=none&amp;taskId=u661b7e64-355d-4240-a2ac-0d48718019c&amp;title=&amp;width=916.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li><p><code>vim phase_1.txt</code>输入</p>\n<p>$\\begin{matrix}<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\\\<br>&amp;00 &amp;00  &amp; 00 &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\\\<br>&amp;00  &amp;00  &amp;00  &amp;00 &amp;00  &amp;00  &amp;00  &amp;00\\\\<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\\\<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\\\<br>&amp;c0 &amp;17  &amp;40  &amp;00  &amp;00  &amp;00  &amp;00<br>\\end{matrix}$<br>最后留了一个字节以供gets放入’ \\n ‘ (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677586525442-cc13fc97-7de2-4bc6-90c7-bdb9356cc9b4.png#averageHue=%231c1c1c&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=196&amp;id=u93bb9ade&amp;name=image.png&amp;originHeight=294&amp;originWidth=1896&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=129168&amp;status=done&amp;style=none&amp;taskId=u503e0466-2b33-4b30-9a9e-f21980d78e7&amp;title=&amp;width=1264\" alt=\"image.png\"><br><a name=\"xCSRi\"></a></p>\n<h2 id=\"phase-2-1\"><a href=\"#phase-2-1\" class=\"headerlink\" title=\"phase_2\"></a>phase_2</h2></li>\n<li><p>编写汇编代码，转化为字节码：<code>vim asb.s</code>，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637642575-745a9de7-6e49-4ef0-9f44-46dbe3cfb8a0.png#averageHue=%23232323&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=62&amp;id=uc88e8483&amp;name=image.png&amp;originHeight=93&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=15349&amp;status=done&amp;style=none&amp;taskId=u1fe3d97e-2ee2-4e3f-b2f0-921ac53df4e&amp;title=&amp;width=253.33333333333334\" alt=\"image.png\"><br>line1将<code>cookie</code>值赋给<code>%rdi</code>传参给<code>touch2</code>；ine2将2<code>touch2</code>的地址压入栈中，目的在于在<code>ret</code>指令执行后，从栈中弹出并赋值给<code>%rip</code>的返回地址是<code>touch2</code>的地址<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637347348-81a97333-5ab5-4766-b689-e0a40d50a9b1.png#averageHue=%23131313&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=221&amp;id=u494680d1&amp;name=image.png&amp;originHeight=331&amp;originWidth=1165&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=130023&amp;status=done&amp;style=none&amp;taskId=u8d81b4ca-fd2a-4ce9-ba46-d1e09ded02c&amp;title=%E8%8E%B7%E5%8F%96touch2%E7%9A%84%E5%9C%B0%E5%9D%80&amp;width=776.6666666666666\" alt=\"image.png\" title=\"获取touch2的地址\"><br>writeup的附录B提示我们将gcc与objdump结合使用产生指令序列的字节码<br><code>gcc -c asb.s</code><br><code>objdump -d asb.o &gt; asb.d</code><br>这样我们就得到了指令序列的字节码，可用于构造exploit_string<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638192080-ecafc66a-645a-4bf0-a9d2-af3a00412381.png#averageHue=%23191918&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=203&amp;id=u9041b219&amp;name=image.png&amp;originHeight=304&amp;originWidth=962&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=84296&amp;status=done&amp;style=none&amp;taskId=ue5e430b5-0a7a-42c3-8791-f51017acec7&amp;title=&amp;width=641.3333333333334\" alt=\"image.png\"></p>\n<ol>\n<li>构造<code>phase_2.txt</code>，因为<code>asb.o</code>中的代码本身就已经逆序，所以直接输入即可；用于覆盖<code>test</code>栈帧中返回地址的值可由<code>%rsp</code>的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是<code>%rsp</code>的值</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677591555601-28a75db3-4efc-445a-bd75-67d6722d57ee.png#averageHue=%231d1d1d&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=359&amp;id=pvcAu&amp;name=image.png&amp;originHeight=539&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=188389&amp;status=done&amp;style=none&amp;taskId=u8ffbde5e-78e3-433e-a1a6-dfa4742b694&amp;title=%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%80%BC&amp;width=783.3333333333334\" alt=\"image.png\" title=\"获取栈顶值\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638376139-5fb21190-4237-424f-a168-1c204bce6ef7.png#averageHue=%231b1b1b&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=406&amp;id=ud656f730&amp;name=image.png&amp;originHeight=609&amp;originWidth=806&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=117050&amp;status=done&amp;style=none&amp;taskId=u39e09168-0d44-4223-a419-2cad498a46f&amp;title=phase_2_exploit_string&amp;width=537.3333333333334\" alt=\"image.png\" title=\"phase_2_exploit_string\"></p>\n<ol>\n<li>攻击生效</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638454464-852c44b4-14f9-43fe-8e9f-a927c267b260.png#averageHue=%230b0b0b&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=233&amp;id=ua99fc494&amp;name=image.png&amp;originHeight=349&amp;originWidth=1225&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=146341&amp;status=done&amp;style=none&amp;taskId=uba333293-f36a-4b4a-bd6b-7ab4d63bd03&amp;title=&amp;width=816.6666666666666\" alt=\"image.png\"><br><a name=\"TVVPU\"></a></p>\n<h2 id=\"phase-3-1\"><a href=\"#phase-3-1\" class=\"headerlink\" title=\"phase_3\"></a>phase_3</h2><ol>\n<li>与<code>phase_2</code>很像，但这次要传递的参数是字符串形式的<code>cookie</code>。因为<code>getbuf</code>的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串<code>cookie</code>放在<code>test</code>函数的栈帧中，地址<code>0x5561dca8</code>；获取<code>touch3</code>函数的地址，编写攻击代码</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677673769317-083e3c3d-3eb7-4716-8b34-154511f96d34.png#averageHue=%231c1c1c&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=236&amp;id=ufe6c6401&amp;name=image.png&amp;originHeight=354&amp;originWidth=1183&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=123850&amp;status=done&amp;style=none&amp;taskId=ue426e205-3b8c-42f1-a2ca-516774edd68&amp;title=&amp;width=788.6666666666666\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678328785-d2f2582c-e25c-484b-83d8-4a0a2595ab07.png#averageHue=%23060606&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=61&amp;id=u15b6d558&amp;name=image.png&amp;originHeight=91&amp;originWidth=347&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=11449&amp;status=done&amp;style=none&amp;taskId=u1ce98f2a-043c-4c00-b0a0-20b0f14e918&amp;title=&amp;width=231.33333333333334\" alt=\"image.png\"></p>\n<ol>\n<li><code>ascii -ax</code>查看十六进制形式的ascii-table，得出<code>&quot;59b997fa&quot;</code>的ascii形式为<code>35 39 62 39 39 37 66 61</code></li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678551264-8b3b6a28-3390-45cb-bbc6-b20f241eb472.png#averageHue=%231d1d1d&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=247&amp;id=u95244bf5&amp;name=image.png&amp;originHeight=370&amp;originWidth=1204&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=116378&amp;status=done&amp;style=none&amp;taskId=u6e6beaa6-64b0-4c0c-ba41-3a88510ea43&amp;title=&amp;width=802.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>覆盖返回地址和test栈帧，写入攻击代码的地址和字符串<code>cookie</code></li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678755332-3ea51646-6c2b-4212-8f6a-d6fe5551fa9a.png#averageHue=%23202020&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=210&amp;id=u5caf20c9&amp;name=image.png&amp;originHeight=315&amp;originWidth=871&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=61586&amp;status=done&amp;style=none&amp;taskId=uc183fab2-b53c-4109-9912-d5f30dc3d02&amp;title=&amp;width=580.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>攻击生效</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678782689-4f003174-6f36-4200-87cd-d46e586d9907.png#averageHue=%231d1d1d&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=235&amp;id=u145918cd&amp;name=image.png&amp;originHeight=353&amp;originWidth=1184&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=131718&amp;status=done&amp;style=none&amp;taskId=u08615a2d-ec29-45b1-bc0c-7f9a93e2212&amp;title=&amp;width=789.3333333333334\" alt=\"image.png\"><br><a name=\"UnHwd\"></a></p>\n<h2 id=\"phase-4-1\"><a href=\"#phase-4-1\" class=\"headerlink\" title=\"phase_4\"></a>phase_4</h2><p>确定攻击方案：<code>rtarget</code>由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用<code>ctarget</code>自身的代码实现攻击，具体做法是通过地址跳转，截取<code>ctarget</code>的部分代码用作攻击代码；<code>gadget</code>指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串<code>gadget</code>的地址，那么一旦执行其中一个<code>gadget</code>，<code>ret</code>指令就会不断的从栈中弹出新的<code>gadget</code>的地址赋给<code>%rip</code>,由此引发多个<code>gadget</code>的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）</p>\n<ol>\n<li><code>cookie</code>的值不可能从<code>rgadget</code>中找到，需要我们自己放到栈中，如同<code>phase_3</code>一样，放的位置不能是<code>getbuf</code>的缓冲区，因此我们将其放到<code>test</code>的栈帧中；接着要实现<code>mov $0x59b997fa,%rdi</code>，需执行<code>popq %rdi</code>，根据writeup的参照表，先在<code>start_farm</code>和<code>end_farm</code>之间寻找<code>5f</code>，结果没有，但是找到了<code>58 90</code>,地址为<code>0x004019ab</code>，这代表<code>popq %rax  nop</code>，因此我们需要用<code>%rax</code>作介质传递<code>cookie</code>给<code>%rdi</code>，而在farm中我们也确实找到了<code>movq %rax, %rdi：48 89 c7</code>，地址为<code>0x004019c5</code>，一共用到了两个<code>gadget</code></li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748308138-674aa437-9522-414c-afcf-828967ad2c1b.png#averageHue=%231f1f1f&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=82&amp;id=ueb5eeaef&amp;name=image.png&amp;originHeight=123&amp;originWidth=1061&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=44128&amp;status=done&amp;style=none&amp;taskId=u3043295b-c67b-407d-81b2-642907b3b41&amp;title=&amp;width=707.3333333333334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748250489-e3dcf01c-ae26-4997-a969-4efde7d2c835.png#averageHue=%231c1b1b&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=163&amp;id=ube7f5b3e&amp;name=image.png&amp;originHeight=244&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=73997&amp;status=done&amp;style=none&amp;taskId=ub3c3a582-4fc1-4e85-ac8e-de93a3fa7d2&amp;title=&amp;width=706.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750944719-6ccf095c-ffce-4020-8cb6-f5b0f0fde9f8.png#averageHue=%2310222d&amp;clientId=u0689b11d-a2d1-4&amp;from=ui&amp;height=546&amp;id=u0eb7edee&amp;name=yuque_diagram.png&amp;originHeight=1110&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38484&amp;status=done&amp;style=none&amp;taskId=uf668df10-5035-4532-8f4f-6e2ef500940&amp;title=&amp;width=187\" alt=\"yuque_diagram.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677751046005-10305a9e-443a-4de9-9d53-344ef204db84.png#averageHue=%23202020&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=186&amp;id=u3879cf7f&amp;name=image.png&amp;originHeight=279&amp;originWidth=762&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=62095&amp;status=done&amp;style=none&amp;taskId=uef71dd0c-5925-4f87-8c3b-ca049535c44&amp;title=&amp;width=508\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750954828-918501d5-682b-4638-ac25-f66bced64fb7.png#averageHue=%231c1c1c&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=235&amp;id=u61b7152b&amp;name=image.png&amp;originHeight=353&amp;originWidth=1387&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=128770&amp;status=done&amp;style=none&amp;taskId=u3e63c29c-34df-412e-b6ae-c66bfaa71c6&amp;title=&amp;width=924.6666666666666\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"<p><meta name=\"referrer\" content=\"no-referrer\"><br><a name=\"IR5gF\"></a></p>\n<h1 id=\"lab1-dataLab\"><a href=\"#lab1-dataLab\" class=\"headerlink\" title=\"lab1 dataLab\"></a>lab1 dataLab</h1>","more":"<p><a name=\"RKm5i\"></a></p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>确保有一个linux系统，并已经执行过以下两条命令:<br>安装gcc：<code>sudo apt-get install build-essential</code>  <br>安装<a href=\"https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea\">gcc的交叉编译环境</a>.)：<code>sudo apt-get install gcc-multilib</code>，因为实验的程序需要以32位方式编译<br>在<a href=\"http://csapp.cs.cmu.edu/3e/labs.html\">CMU的CSAPP网站</a>上下载实验所需资料，包括<strong>README, Writeup，Self-Study Handout，</strong>这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件<br><a name=\"IOcHR\"></a></p>\n<h2 id=\"1-bitXor-x-y\"><a href=\"#1-bitXor-x-y\" class=\"headerlink\" title=\"1.bitXor(x,y)\"></a>1.bitXor(x,y)</h2><p>要用~和&amp;实现异或^，即将结果中 1-0，0-1对应的位设置为1<br>x&amp;y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br>(~x&amp;~y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br>两个做交集即为结果。（位向量可以表示集合，&amp;，|，~可视为 交，并，补操作）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">bitXor - x^y using only ~ and &amp; </span></span><br><span class=\"line\"><span class=\"comment\">Example: bitXor(4, 5) = 1</span></span><br><span class=\"line\"><span class=\"comment\">Legal ops: ~ &amp;</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 14</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitXor</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  ~(x&amp;y) &amp; ~(~x&amp;~y) ; <span class=\"comment\">// if regardless &#x27;+&#x27; is illegal:(~x&amp;y) + ((x)&amp;(~y)) or ~((x&amp;y) + ((~x)&amp;(~y)))</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"mB5XE\"></a></p>\n<h2 id=\"2-tmin\"><a href=\"#2-tmin\" class=\"headerlink\" title=\"2.tmin\"></a>2.tmin</h2><p>最简单的一题：<code>000...001</code> —&gt; <code>1000...000</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">tmin - return minimum two&#x27;s complement integer </span></span><br><span class=\"line\"><span class=\"comment\">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 4</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tmin</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"pr9MQ\"></a></p>\n<h2 id=\"3-isTmax-x\"><a href=\"#3-isTmax-x\" class=\"headerlink\" title=\"3.isTmax(x)\"></a>3.isTmax(x)</h2><p>这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了<code>!((~x) + (~x))</code>，但<a href=\"https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471\">测试结果出乎意料</a>，加法溢出导致了未知的行为。<br>根据 Tmax +1 = Tmin 的性质可以得出 ,  <code>100...000</code> + <code>011...111</code> = <code>111..1111</code> (-1)，可得出<code>!(~x^(x+1))</code>（^可替换为+）<br>处理特例-1： -1同样会产生结果1，根据 <code>-1+1==0</code>,<code>Tmax+1!=0</code>，进而<code>!(-1+1) !=0</code> ，<code>!(Tmax+1) ==0</code>.<br>所以<code>对Tmax, x+(x+1) = x</code> , <code>对-1,x+(x+1)!=x</code><br>用<code>x+(x+1)</code> 替换原式中的第一项x，最终得出结果：<code>!(~((x+!(x+1))^(x+1)))</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class=\"line\"><span class=\"comment\">and 0 otherwise </span></span><br><span class=\"line\"><span class=\"comment\">egal ops: ! ~ &amp; ^ | +</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 10</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">isTmax</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !(~((x+!(x+<span class=\"number\">1</span>)) ^ (x+<span class=\"number\">1</span>))) ; </span><br><span class=\"line\">   <span class=\"comment\">// !((~x) + (~x));  it should be right, the operator &quot;!&quot; seem to not work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"kHLgK\"></a></p>\n<h2 id=\"4-allOddBits-x\"><a href=\"#4-allOddBits-x\" class=\"headerlink\" title=\"4.allOddBits(x)\"></a>4.allOddBits(x)</h2><p>这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br>用好异或即可解决：构造<code>101...1010</code>，再用该数提取x中的奇数位，最后再与<code>101...1010</code>比较<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class=\"line\"><span class=\"comment\">where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class=\"line\"><span class=\"comment\">Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class=\"line\"><span class=\"comment\">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">Max ops: 12</span></span><br><span class=\"line\"><span class=\"comment\">Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">allOddBits</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> allOdd = (<span class=\"number\">0xAA</span> &lt;&lt; <span class=\"number\">24</span>) + (<span class=\"number\">0xAA</span> &lt;&lt; <span class=\"number\">16</span>) + (<span class=\"number\">0xAA</span> &lt;&lt; <span class=\"number\">8</span>) + <span class=\"number\">0xAA</span>; <span class=\"comment\">// 10101010..101</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ! ((allOdd &amp; x) ^ allOdd);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"sswhY\"></a></p>\n<h2 id=\"5-isAsciiDigit-x\"><a href=\"#5-isAsciiDigit-x\" class=\"headerlink\" title=\"5.isAsciiDigit(x)\"></a>5.isAsciiDigit(x)</h2><p>有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验—-用异或执行比较操作。<br>x的最后四位，3bit 与 1,2bit不能同时为1，因而有<code>!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)))</code>，难点在于怎么处理好式中三部分的逻辑关系<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class=\"line\"><span class=\"comment\"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class=\"line\"><span class=\"comment\"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">isAsciiDigit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> mask1 = <span class=\"number\">0x3</span>;   <span class=\"comment\">// 000...0011</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mask2 = <span class=\"number\">0xA</span>;   <span class=\"comment\">// 1010</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mask3 = <span class=\"number\">0xC</span>;   <span class=\"comment\">// 1100</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>  !( ((x&gt;&gt;<span class=\"number\">4</span>)^mask1) | (!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)) ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"DZZaa\"></a></p>\n<h2 id=\"6-conditional\"><a href=\"#6-conditional\" class=\"headerlink\" title=\"6.conditional\"></a>6.conditional</h2><p>比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br>涉及的操作是把x转化为0与1两个值，再把<code>000...0001</code>转化为<code>111...1111</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * conditional - same as x ? y : z </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: conditional(2,4,5) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; </span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 16</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">conditional</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> z)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>  judge = !(x ^ <span class=\"number\">0x0</span>); <span class=\"comment\">// x=0 -&gt; judge=1,whereas x!=0 -&gt; judge=0</span></span><br><span class=\"line\">  judge = (judge &lt;&lt; <span class=\"number\">31</span>)&gt;&gt;<span class=\"number\">31</span>; <span class=\"comment\">// 000...000 or 111...111</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((~judge)&amp;y) | (judge&amp;z);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"MZZvz\"></a></p>\n<h2 id=\"7-isLessOrEqual-x-y\"><a href=\"#7-isLessOrEqual-x-y\" class=\"headerlink\" title=\"7.isLessOrEqual(x, y)\"></a>7.isLessOrEqual(x, y)</h2><p>可通过减法<code>y-x&gt;=0</code>判断<code>x&lt;=y</code>，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br>那么这题就涉及加法溢出,需要对<code>x+uw  y</code>结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br>更好的想法是<strong>分析式子</strong><code>**y-x**</code><strong>并加入一个conditional操作</strong>：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 24</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">isLessOrEqual</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> Tmin = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>; <span class=\"comment\">// 100...0000</span></span><br><span class=\"line\">  <span class=\"type\">int</span> signY = Tmin &amp; y;</span><br><span class=\"line\">  <span class=\"type\">int</span> signX = Tmin &amp; x;</span><br><span class=\"line\">  <span class=\"type\">int</span> judge = (signY ^ signX)&lt;&lt;<span class=\"number\">31</span>; </span><br><span class=\"line\">  x = (~x)+<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (judge&amp;signX) | (~(judge&gt;&gt;<span class=\"number\">31</span>) &amp; !((y+x)&amp;Tmin)) ; <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"WP1Li\"></a></p>\n<h2 id=\"8-logicalNeg-x\"><a href=\"#8-logicalNeg-x\" class=\"headerlink\" title=\"8.logicalNeg(x)\"></a>8.logicalNeg(x)</h2><p>这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br>于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的<strong>positive overflow</strong>现象，即 Tmax + x ，对任意x&gt;0均会使结果变为负数，符号位由0 —&gt;1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致<a href=\"http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3\">undefined behavior</a>）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class=\"line\"><span class=\"comment\"> *              the legal operators except !</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: logicalNeg(3) = 0, logi&#x27;calNeg(0) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 12</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">logicalNeg</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> Tmin = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> Tmax = ~Tmin;</span><br><span class=\"line\">  <span class=\"type\">int</span> signX = ((x&amp;Tmin)&gt;&gt;<span class=\"number\">31</span>) &amp; <span class=\"number\">0x1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (signX^<span class=\"number\">0x1</span>) &amp; ((((x + Tmax)&gt;&gt;<span class=\"number\">31</span>)&amp;<span class=\"number\">0x1</span>)^<span class=\"number\">0x1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"Y5Acb\"></a></p>\n<h2 id=\"9-howManyBits-x\"><a href=\"#9-howManyBits-x\" class=\"headerlink\" title=\"9.howManyBits(x)\"></a>9.howManyBits(x)</h2><p>这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：<strong>当数的符号位为1时，将数按符号位扩展之后其值不会变</strong>，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br>要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -&gt; 0010)<br>按二分法逐步缩小范围，找到最左边的1<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class=\"line\"><span class=\"comment\"> *             two&#x27;s complement</span></span><br><span class=\"line\"><span class=\"comment\"> *  Examples: howManyBits(12) = 5</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(298) = 10</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(-5) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(0)  = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(-1) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(0x80000000) = 32</span></span><br><span class=\"line\"><span class=\"comment\"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *  Max ops: 90</span></span><br><span class=\"line\"><span class=\"comment\"> *  Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">howManyBits</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class=\"line\">  <span class=\"type\">int</span> signX = x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">  x = ((~signX) &amp; x) | (signX&amp;(~x));<span class=\"comment\">// if x is negative, let sign bit:1-&gt; 0</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  b16 = (!!(x&gt;&gt;<span class=\"number\">16</span>))&lt;&lt;<span class=\"number\">4</span>; <span class=\"comment\">// ensure high 16 bits exist 1 or not</span></span><br><span class=\"line\">  x=x&gt;&gt;b16;</span><br><span class=\"line\">  b8 = (!!(x&gt;&gt;<span class=\"number\">8</span>))&lt;&lt;<span class=\"number\">3</span>; <span class=\"comment\">// ensure high 8 bits </span></span><br><span class=\"line\">  x=x&gt;&gt;b8;</span><br><span class=\"line\">  b4 = (!!(x&gt;&gt;<span class=\"number\">4</span>))&lt;&lt;<span class=\"number\">2</span>; <span class=\"comment\">// ensure high 4 bits </span></span><br><span class=\"line\">  x=x&gt;&gt;b4;  </span><br><span class=\"line\">  b2 = (!!(x&gt;&gt;<span class=\"number\">2</span>))&lt;&lt;<span class=\"number\">1</span>; <span class=\"comment\">// ensure high 2 bits </span></span><br><span class=\"line\">  x=x&gt;&gt;b2; </span><br><span class=\"line\">  b1 = !!(x&gt;&gt;<span class=\"number\">1</span>); <span class=\"comment\">// ensure 31 bits or not </span></span><br><span class=\"line\">  x = x&gt;&gt;b1;</span><br><span class=\"line\">  b0 = x;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> b0+b1+b2+b4+b8+b16+<span class=\"number\">1</span>; <span class=\"comment\">// 1: sign bit</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"glYde\"></a></p>\n<h2 id=\"10-floatScale2-uf\"><a href=\"#10-floatScale2-uf\" class=\"headerlink\" title=\"10.floatScale2(uf)\"></a>10.floatScale2(uf)</h2><p>先对题目做出一点解释：传入一个<code>unsigned</code>类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br><strong>整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论</strong><br>注意点：对normalized，f*2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么<code>frac = frac &lt;&lt;1</code>，这也使得denormalized能转化到normalized (smoothly)<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//float</span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument    // revision: NaN or infinity</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"title\">floatScale2</span><span class=\"params\">(<span class=\"type\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> musk_exp,musk_frac,sign,exp,frac,result;</span><br><span class=\"line\">  musk_exp = <span class=\"number\">0xFF</span> &lt;&lt; <span class=\"number\">23</span>;</span><br><span class=\"line\">  musk_frac = <span class=\"number\">0x7FFFFF</span>;</span><br><span class=\"line\">  exp = (uf &amp; musk_exp)&gt;&gt;<span class=\"number\">23</span>;</span><br><span class=\"line\">  frac = uf &amp; musk_frac;</span><br><span class=\"line\">  sign = <span class=\"number\">0x1</span>&lt;&lt;<span class=\"number\">31</span> &amp; uf;</span><br><span class=\"line\">  result = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(exp == <span class=\"number\">0xFF</span>  ) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">     result = uf;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp == <span class=\"number\">0x0</span>) <span class=\"comment\">// denormalized</span></span><br><span class=\"line\">  &#123;  </span><br><span class=\"line\">     <span class=\"keyword\">if</span>(frac == <span class=\"number\">0x0</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sign)  <span class=\"comment\">// -0.0</span></span><br><span class=\"line\">           result = uf;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>     <span class=\"comment\">// +0.0</span></span><br><span class=\"line\">           result = <span class=\"number\">0</span> ;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        frac = frac &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        result = sign+ (exp&lt;&lt;<span class=\"number\">23</span>) + frac;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp != <span class=\"number\">0x0</span> &amp;&amp; exp != <span class=\"number\">0xFF</span>) <span class=\"comment\">// normalized</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     exp += <span class=\"number\">1</span>;</span><br><span class=\"line\">     result = sign+ (exp&lt;&lt;<span class=\"number\">23</span>) + frac;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"tO8yh\"></a></p>\n<h2 id=\"11-floatFloat2Int-uf\"><a href=\"#11-floatFloat2Int-uf\" class=\"headerlink\" title=\"11.floatFloat2Int(uf)\"></a>11.floatFloat2Int(uf)</h2><p>浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br>对题目的解释：返回浮点数f的int型表示，如输入<code>12345.0 (0x4640E400)</code>, 正确输出为<code>12345 (0x3039)</code><br>注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E&gt;31时，属于out of range<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class=\"line\"><span class=\"comment\"> *   for floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Argument is passed as unsigned int, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point value.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class=\"line\"><span class=\"comment\"> *   0x80000000u.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">floatFloat2Int</span><span class=\"params\">(<span class=\"type\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> musk_exp,musk_frac,exp,frac,sign,E,Bias,result;</span><br><span class=\"line\">  musk_exp = <span class=\"number\">0xFF</span> &lt;&lt; <span class=\"number\">23</span>;</span><br><span class=\"line\">  musk_frac = <span class=\"number\">0x7FFFFF</span>;</span><br><span class=\"line\">  exp = (uf &amp; musk_exp)&gt;&gt;<span class=\"number\">23</span>;</span><br><span class=\"line\">  frac = uf &amp; musk_frac;</span><br><span class=\"line\">  sign = <span class=\"number\">0x1</span>&lt;&lt;<span class=\"number\">31</span> &amp; uf;</span><br><span class=\"line\">  Bias = <span class=\"number\">127</span>;</span><br><span class=\"line\">  result = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(exp == <span class=\"number\">0xFF</span>  ) <span class=\"comment\">// NaN or infinity</span></span><br><span class=\"line\">     result = <span class=\"number\">0x80000000</span>u;</span><br><span class=\"line\">     </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp == <span class=\"number\">0x0</span>)</span><br><span class=\"line\">     result = <span class=\"number\">0</span>;</span><br><span class=\"line\">     </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(exp != <span class=\"number\">0x0</span> &amp;&amp; exp != <span class=\"number\">0xFF</span>) <span class=\"comment\">// normalized</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     E = exp -Bias;  <span class=\"comment\">// bit_num of fraction</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(E &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        result = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (E&gt;<span class=\"number\">31</span>)</span><br><span class=\"line\">        result = <span class=\"number\">0x80000000</span>u;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        frac = frac&gt;&gt;(<span class=\"number\">23</span>-E);</span><br><span class=\"line\">        result = (<span class=\"number\">0x1</span> &lt;&lt; E) + frac ; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sign == <span class=\"number\">0x1</span>&lt;&lt;<span class=\"number\">31</span>)</span><br><span class=\"line\">           result = - result;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"UlJMS\"></a></p>\n<h2 id=\"12-floatPower2-x\"><a href=\"#12-floatPower2-x\" class=\"headerlink\" title=\"12.floatPower2(x)\"></a>12.floatPower2(x)</h2><p>注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class=\"line\"><span class=\"comment\"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class=\"line\"><span class=\"comment\"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class=\"line\"><span class=\"comment\"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class=\"line\"><span class=\"comment\"> *   0. If too large, return +INF.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30 </span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"title\">floatPower2</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> exp,frac,E,Bias,result;</span><br><span class=\"line\">  Bias = <span class=\"number\">127</span>;</span><br><span class=\"line\">  result = <span class=\"number\">5</span>;</span><br><span class=\"line\">  E = x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">1</span> &amp;&amp; x!=<span class=\"number\">0</span>)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x &gt;= <span class=\"number\">0x1</span> || x == <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     frac = <span class=\"number\">0x0</span>;</span><br><span class=\"line\">     exp = E+Bias;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(exp &gt; <span class=\"number\">254</span>)  <span class=\"comment\">// 1111 1110</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           exp = <span class=\"number\">0xFF</span>;</span><br><span class=\"line\">           result = exp &lt;&lt;<span class=\"number\">23</span>+frac;         </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">        result = (exp&lt;&lt;<span class=\"number\">23</span>) + frac; </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a name=\"iHsuB\"></a></p>\n<h2 id=\"consequence\"><a href=\"#consequence\" class=\"headerlink\" title=\"consequence\"></a>consequence</h2><p><code>make</code><br><code>./driver.pl</code><br><a name=\"SLl25\"></a></p>\n<h3 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1669795434321-27bd7778-bde0-4d21-9ae0-425e1e785bd1.png#averageHue=%230d0c0c&amp;clientId=u8b4f2be4-4c9f-4&amp;from=ui&amp;id=ue9c8e7dc&amp;name=data_lab_success.png&amp;originHeight=631&amp;originWidth=1162&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183673&amp;status=done&amp;style=none&amp;taskId=u00d5bd76-a7dc-4107-8697-fafe865d7ec&amp;title=\" alt=\"data_lab_success.png\"></h3><hr>\n<p><a name=\"FsQk5\"></a></p>\n<h1 id=\"lab2-bombLab\"><a href=\"#lab2-bombLab\" class=\"headerlink\" title=\"lab2 bombLab\"></a>lab2 bombLab</h1><p><a name=\"mm3BW\"></a></p>\n<h2 id=\"phase-1\"><a href=\"#phase-1\" class=\"headerlink\" title=\"phase_1\"></a>phase_1</h2><ol>\n<li>反汇编<code>main</code>函数：<code>read_line</code>函数之后寄存器<code>%rax</code>和<code>%rdi</code>存储了我们输入的字符串的首地址(后续的phase都是如此)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677142575501-aadca48e-4054-40dc-977b-4719009de3e3.png#averageHue=%2362372c&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=113&amp;id=u7f5a75e8&amp;name=image.png&amp;originHeight=113&amp;originWidth=1058&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65961&amp;status=done&amp;style=none&amp;taskId=u19a9cc96-f38d-462d-9d4b-fbdd1e6cd16&amp;title=&amp;width=1058\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163430669-16842232-e1ab-4ac7-a90d-8f9a18e1c5d2.png#averageHue=%232d2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=128&amp;id=u1267f1f6&amp;name=image.png&amp;originHeight=128&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=59576&amp;status=done&amp;style=none&amp;taskId=ufdd9544b-0308-49f4-86fd-49a8013d976&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%281%29&amp;width=1060\" alt=\"image.png\" title=\"验证%rdi指向输入字符串(1)\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163457263-f780263b-09ed-4875-bafc-0f00d7e8e894.png#averageHue=%23323232&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=77&amp;id=ubbe401e0&amp;name=image.png&amp;originHeight=77&amp;originWidth=723&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=31472&amp;status=done&amp;style=none&amp;taskId=u152fe82b-0961-427e-bd1e-8a6755f1504&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%282%29&amp;width=723\" alt=\"image.png\" title=\"验证%rdi指向输入字符串(2)\"></p>\n<ol>\n<li>反汇编<code>strings_not_equal</code>函数：该函数在输入字符串与目的字符串相同时，将寄存器<code>%rax</code>（通常用作函数返回值）赋值为0 (1 vice versa)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143001741-9ecdcda9-b9a6-4b31-a450-5d80ed226850.png#averageHue=%23302f2f&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=147&amp;id=u575b769d&amp;name=image.png&amp;originHeight=147&amp;originWidth=1140&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=79269&amp;status=done&amp;style=none&amp;taskId=u9916894f-f032-4f63-b09d-6ce04314c3f&amp;title=&amp;width=1140\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143020716-757eda92-ee3e-4fe0-9c1b-597af2e24eab.png#averageHue=%23323131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=214&amp;id=uca455390&amp;name=image.png&amp;originHeight=214&amp;originWidth=973&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98661&amp;status=done&amp;style=none&amp;taskId=u7c4aadd7-6706-4e4d-8a95-2e31a1df894&amp;title=&amp;width=973\" alt=\"image.png\"></p>\n<ol>\n<li>反汇编<code>phase_1</code>函数：<code>strings_not_equal</code>函数返回值为0时，<code>test %eax, %eax</code>能使<code>je 0x400ef7&lt;phase_1+23&gt;</code>执行，phase_1 defused (explode vice versa)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143312955-e1e9a80c-1730-48ae-84f7-5dfded69d3a9.png#averageHue=%232e2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=361&amp;id=ue40fcfa2&amp;name=image.png&amp;originHeight=361&amp;originWidth=1126&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=206173&amp;status=done&amp;style=none&amp;taskId=u54ecca10-9722-4536-ba3f-f972c656feb&amp;title=&amp;width=1126\" alt=\"image.png\"></p>\n<ol>\n<li>至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用<code>strings_not_equal</code>函数之前赋值的<code>%esi：0x402400</code>寄存器中</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143752561-a0f86e1a-fc9c-4ff2-b386-d8d929f293c5.png#averageHue=%23333333&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=102&amp;id=ua334cc19&amp;name=image.png&amp;originHeight=102&amp;originWidth=1118&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39885&amp;status=done&amp;style=none&amp;taskId=u26286ab1-642e-4f50-9434-8d65b1add7d&amp;title=&amp;width=1118\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143789980-9946be38-59bb-4852-bd3c-72747f67fc16.png#averageHue=%23333333&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=152&amp;id=u0cd1b8f0&amp;name=image.png&amp;originHeight=152&amp;originWidth=1065&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=69532&amp;status=done&amp;style=none&amp;taskId=u1b6e1505-7e71-4000-8504-44c050e2921&amp;title=&amp;width=1065\" alt=\"image.png\"><br><a name=\"aPHyw\"></a></p>\n<h2 id=\"phase-2\"><a href=\"#phase-2\" class=\"headerlink\" title=\"phase_2\"></a>phase_2</h2><ol>\n<li>反汇编<code>read_six_numbers</code>函数：可以推断出其实现了<code>sscanf(input, &quot;%d %d %d %d %d %d&quot;,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6)</code>的功能，其中<code>&amp;a1~&amp;a6</code>分别在1)<code>%rcx:0x4(%rsi)</code>2)<code>%r8:0x8(%rsi)</code>3)<code>%r9:0xc(%rsi)</code>4)<code>%rsp:0x10(%rsi)</code>5)<code>0x8(%rsp):0x14(%rsi), 0x18(%rsi)</code> 前3个指针存储在寄存器中传递给<code>sscanf</code>函数，后三个指针存储在为<code>read_six_numbers</code>函数分配的栈空间中,可以推断出<code>%rsi</code>为一个含有六个元素的数组的首地址</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677148614935-cd29c501-e2a8-4185-9924-0829124ef293.png#averageHue=%232e2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=506&amp;id=ue62a1cc7&amp;name=image.png&amp;originHeight=506&amp;originWidth=1045&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=292132&amp;status=done&amp;style=none&amp;taskId=udf564ea8-5d5d-4db1-9fe7-6784845d360&amp;title=&amp;width=1045\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150202265-dda02d42-7661-48f0-9ec1-5b420d781e9d.png#averageHue=%23313131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=74&amp;id=u5d32cc04&amp;name=image.png&amp;originHeight=74&amp;originWidth=675&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24474&amp;status=done&amp;style=none&amp;taskId=u7f387e07-3b4e-4ad1-bae1-5f9cf213c77&amp;title=&amp;width=675\" alt=\"image.png\"></p>\n<ol>\n<li>反汇编<code>phase_2</code>函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150067118-dd3962a5-1458-4a3e-9399-4cf1699ca7a7.png#averageHue=%23423227&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=656&amp;id=u8a1ec132&amp;name=image.png&amp;originHeight=656&amp;originWidth=885&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=478280&amp;status=done&amp;style=none&amp;taskId=u1da79441-ac63-407b-ab6c-037fd3e1450&amp;title=&amp;width=885\" alt=\"image.png\"></p>\n<ol>\n<li>自此，我们可以判断出这六个数字分别是$2^0,2^1,2^2,2^3,2^4,2^5$</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677149991615-e3f805b9-b4b0-4f49-bfbf-36dc2153557b.png#averageHue=%23313131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=112&amp;id=ua5f4ba93&amp;name=image.png&amp;originHeight=112&amp;originWidth=782&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34849&amp;status=done&amp;style=none&amp;taskId=u43537a4a-415e-4df2-b80d-0601d361576&amp;title=&amp;width=782\" alt=\"image.png\"><br><a name=\"XKRDk\"></a></p>\n<h2 id=\"phase-3\"><a href=\"#phase-3\" class=\"headerlink\" title=\"phase_3\"></a>phase_3</h2><ol>\n<li>反汇编<code>phase_3</code>：从<code>(%esi)</code>的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(<code>cmpl 0x7,0x8(rsp)</code>)，并根据这个值执行间接跳转操作(<code>jmp *0x402470(,rax,8)</code>)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150892423-92750918-b2b5-4aa5-9b0e-e08eec5cffdd.png#averageHue=%23141313&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=150&amp;id=uf4734a85&amp;name=image.png&amp;originHeight=150&amp;originWidth=1074&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61373&amp;status=done&amp;style=none&amp;taskId=u56bba885-3031-4576-9ddd-85ccf2060e9&amp;title=&amp;width=1074\" alt=\"image.png\"></p>\n<ol>\n<li>查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的<code>0x8(%rsp</code>：1 2 3 4 5 6 7</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677072562462-74d53e52-6a59-498d-9186-02f1b43b8be5.png#averageHue=%23131313&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=324&amp;id=u10476384&amp;name=image.png&amp;originHeight=324&amp;originWidth=1067&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80101&amp;status=done&amp;style=none&amp;taskId=u49754a92-19b8-499c-8daf-4c666824406&amp;title=&amp;width=1067\" alt=\"image.png\"></p>\n<ol>\n<li>根据后续的赋值-跳转指令，可以得到对应的7个<code>0xc(%rsp)</code>：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151557789-3726bd23-9a03-48c7-bb2b-1a31a71ae4c0.png#averageHue=%23121212&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=286&amp;id=ud77abcea&amp;name=image.png&amp;originHeight=327&amp;originWidth=347&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72813&amp;status=done&amp;style=none&amp;taskId=uaa3da35e-6e2a-42ba-af96-025e357b784&amp;title=&amp;width=304\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151578594-a2486d66-586a-473a-ba87-8ed30e462b01.png#averageHue=%231e1e1e&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=294&amp;id=ud120ef9a&amp;name=image.png&amp;originHeight=391&amp;originWidth=354&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101567&amp;status=done&amp;style=none&amp;taskId=ub5d0284e-6af4-4113-b8cd-89ebdce0f6d&amp;title=&amp;width=266\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073427546-61c8a627-e902-4132-922f-d9c30d888865.png#averageHue=%23303030&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=50&amp;id=u47146b93&amp;name=image.png&amp;originHeight=75&amp;originWidth=297&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8224&amp;status=done&amp;style=none&amp;taskId=u32d95d06-a5d5-44ea-9c62-17652eea139&amp;title=&amp;width=197\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073446185-f50d15ab-e6e5-4d7f-b87a-7c41585c225e.png#averageHue=%232f2f2f&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=47&amp;id=ue4a4e105&amp;name=image.png&amp;originHeight=70&amp;originWidth=287&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8707&amp;status=done&amp;style=none&amp;taskId=u21abdc4b-34e0-4b23-8ae8-6a213e06389&amp;title=&amp;width=192\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073458555-0aefc97d-f40a-4b0b-8e5e-1c592d1478fb.png#averageHue=%23313131&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=51&amp;id=u12915178&amp;name=image.png&amp;originHeight=74&amp;originWidth=307&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8649&amp;status=done&amp;style=none&amp;taskId=u884bf4d9-3d42-48e3-9d32-a6cc91f0115&amp;title=&amp;width=212\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073483221-c6634274-ca68-4d70-b35d-bcf9c12bc64d.png#averageHue=%23292929&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=48&amp;id=u8a9d1cb9&amp;name=image.png&amp;originHeight=71&amp;originWidth=296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10382&amp;status=done&amp;style=none&amp;taskId=u3d742e48-f459-45a3-abcb-5a2e46a9698&amp;title=&amp;width=201\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073498912-78462783-24d1-48c5-bd9c-dc0efd391d71.png#averageHue=%232a2a29&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=47&amp;id=uc7e8ea56&amp;name=image.png&amp;originHeight=75&amp;originWidth=290&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11606&amp;status=done&amp;style=none&amp;taskId=u579ff7da-06cc-49aa-bbb5-7d665920365&amp;title=&amp;width=183\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073505761-bdd3ef17-0fcd-491a-8c9d-c021bd67b4a8.png#averageHue=%23272727&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=53&amp;id=u656875e3&amp;name=image.png&amp;originHeight=78&amp;originWidth=307&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11833&amp;status=done&amp;style=none&amp;taskId=u1ec87705-b895-47c3-98cb-1da89ebe401&amp;title=&amp;width=208\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073525247-e99ecac4-12c7-4929-ac87-722029dcb4fd.png#averageHue=%23303030&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=49&amp;id=uaaf9dd91&amp;name=image.png&amp;originHeight=74&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8976&amp;status=done&amp;style=none&amp;taskId=u262b648d-9811-41df-9106-07a991aca4a&amp;title=&amp;width=208\" alt=\"image.png\"><br><a name=\"Qae7S\"></a></p>\n<h2 id=\"phase-4\"><a href=\"#phase-4\" class=\"headerlink\" title=\"phase_4\"></a>phase_4</h2><ol>\n<li>反汇编<code>phase_4</code>函数：开头部分具有与<code>phase_3</code>函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(<code>cmpl $0xe, 0x8(%rsp)</code>)，之后函数调用<code>func4</code>函数，传入三个参数<code>%edx</code>, <code>%esi</code>, <code>0x8(%rsp)</code>。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(<code>test %eax, %eax</code>)。后续的<code>cmpl $0x0, 0xc(%rsp)</code>足以确定第2个值为0</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206362623-39fe4977-5cab-4016-9003-2541d41dbe6a.png#averageHue=%232a2823&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=416&amp;id=ubcbcc5b1&amp;name=image.png&amp;originHeight=587&amp;originWidth=1125&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=601648&amp;status=done&amp;style=none&amp;taskId=ucd50703b-cd59-4e1b-b4f1-5fefbaddeb2&amp;title=&amp;width=797\" alt=\"image.png\"></p>\n<ol>\n<li>反汇编<code>func4</code>函数：出现了<code>func4</code>调用自身的情况，所以<code>func4</code>是一个递归函数。第1部分将<code>%rax</code>赋值为<code>%edx</code>-<code>%esi</code>,再加上它的最高位(<code>%rax &gt;&gt; 31</code>)，接着执行算数右移。这里加上最高位的原因在于，当后续<code>%rax</code>在递归中值减少为-1时，最高位是符号位1，两者相加能保证<code>%rax</code>始终大于等于0，结合后续汇编内容，可以推断出第一个值<code>0x8(%rsp)</code>应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果<code>%ecx &gt; %edi</code>，那么就使<code>%ecx</code>变为<code>%esi</code>到<code>%edx</code>的中间值(<code>lea -0x1(%rcx), %edx</code>)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回<code>phase_4</code>的<code>%rax</code>值为1</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677204842268-34841e29-56e5-4d63-9e9f-b1576cec24a4.png#averageHue=%232b2a2a&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=562&amp;id=u81eba999&amp;name=image.png&amp;originHeight=843&amp;originWidth=1305&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=520895&amp;status=done&amp;style=none&amp;taskId=u37b9260f-a9c9-4dd9-abb9-dd995610f26&amp;title=&amp;width=870\" alt=\"image.png\"></p>\n<ol>\n<li>自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206164369-fa35758d-403b-483b-ad52-af80ef73df84.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=u3b0eedfa&amp;name=image.png&amp;originHeight=74&amp;originWidth=649&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17085&amp;status=done&amp;style=none&amp;taskId=ub467ca8a-a273-4b74-b425-f72d9e99ae4&amp;title=&amp;width=432.6666666666667\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206214348-cbc56dfd-faed-4afb-8859-c6bb00e4be62.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=ub80967c2&amp;name=image.png&amp;originHeight=74&amp;originWidth=686&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17880&amp;status=done&amp;style=none&amp;taskId=u78e1925a-de3d-4ff7-a76b-00e4657dd48&amp;title=&amp;width=457.3333333333333\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206249049-10571826-c506-4fdf-bcae-4ca9487bd383.png#averageHue=%232d2d2d&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=46&amp;id=u3c92002a&amp;name=image.png&amp;originHeight=75&amp;originWidth=713&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17666&amp;status=done&amp;style=none&amp;taskId=u81f0177a-9477-484d-bc60-f8009a91d73&amp;title=&amp;width=435.3333435058594\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206271742-0b02d5c9-234f-465e-9fb7-6a9cb6c3b2f3.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=u0a7235e4&amp;name=image.png&amp;originHeight=73&amp;originWidth=674&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17218&amp;status=done&amp;style=none&amp;taskId=u48f4584a-4771-47be-b5b5-5281e909d12&amp;title=&amp;width=449.3333333333333\" alt=\"image.png\"><br><a name=\"Kxq7k\"></a></p>\n<h2 id=\"phase-5\"><a href=\"#phase-5\" class=\"headerlink\" title=\"phase_5\"></a>phase_5</h2><ol>\n<li><p>反汇编<code>phase_5</code>函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> index</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">0</span> <span class=\"comment\">// %rax</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">index = *(input+i);</span><br><span class=\"line\">index = index&amp; <span class=\"number\">0xf</span>; <span class=\"comment\">// take lower four bits</span></span><br><span class=\"line\">dest[<span class=\"number\">0</span>] = source[index]; <span class=\"comment\">// dest: (%rsp+0x10+%rax) source: 0x4024b0</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(string_not_equal(dest, target) == <span class=\"number\">0</span>) <span class=\"comment\">// target: 0x40245e --- &quot;flyers&quot;</span></span><br><span class=\"line\">      <span class=\"comment\">//defuse</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">   explode_bomb();</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(i&gt;<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227102569-50a0daeb-22b8-4911-84ee-83283088ca0d.png#averageHue=%23211710&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=629&amp;id=u029c0758&amp;name=image.png&amp;originHeight=944&amp;originWidth=901&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=467386&amp;status=done&amp;style=none&amp;taskId=uaa2e377e-a27a-4e06-9129-f19ece505a9&amp;title=&amp;width=600.6666666666666\" alt=\"image.png\"></p>\n</li>\n<li><p>分别查看<code>source: 0x4024b0</code>和<code>target: 0x40245e</code>处的字符串，我们要做的就是使输入字符串形成的索引值能够从<code>0x4024b0</code>处的字符集中提取出 “flyers”</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227207876-48a2e806-f23e-49ec-982e-698183c7bc19.png#averageHue=%23151515&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=52&amp;id=u3302b9b7&amp;name=image.png&amp;originHeight=78&amp;originWidth=1766&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=39766&amp;status=done&amp;style=none&amp;taskId=u6f4121a7-1717-4bf8-9d35-1f34adc43a8&amp;title=&amp;width=1177.3333333333333\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227244326-73d2e1d2-8fa8-4452-bb1c-64b132ecd786.png#averageHue=%23131313&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=49&amp;id=u7ad1cd69&amp;name=image.png&amp;originHeight=73&amp;originWidth=906&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=18317&amp;status=done&amp;style=none&amp;taskId=u0a7a9ee0-efaa-4b08-8a9e-6e726ed5958&amp;title=&amp;width=604\" alt=\"image.png\"></p>\n<ol>\n<li>我们的输入字符串每个字符在内存中占一个byte，<code>movzbl (%rbx, %rax, 1), %ecx</code>说明了一次循环提取一个字符，并只取该字符的低四位(<code>and $0xf, %edx</code>)作为索引值</li>\n<li>首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228092474-185f8fde-3015-4a64-ae85-2a4931bb2ca9.png#averageHue=%23191919&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=72&amp;id=u2762ccc0&amp;name=image.png&amp;originHeight=108&amp;originWidth=741&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=24485&amp;status=done&amp;style=none&amp;taskId=u4d7584c2-7474-4bc2-8df3-b7710936568&amp;title=&amp;width=494\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228432835-1ddc8d9b-d067-4d80-82c1-d63b067d6c25.png#averageHue=%23191919&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=71&amp;id=uaf8564a8&amp;name=image.png&amp;originHeight=107&amp;originWidth=705&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=24585&amp;status=done&amp;style=none&amp;taskId=ud201852c-7855-4553-8543-43f2a63028c&amp;title=&amp;width=470\" alt=\"image.png\"><br><a name=\"BuuHr\"></a></p>\n<h2 id=\"phase-6\"><a href=\"#phase-6\" class=\"headerlink\" title=\"phase_6\"></a>phase_6</h2><ol>\n<li><p>thinking process</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">phase_6(input)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> a1 = <span class=\"number\">0</span>;  <span class=\"comment\">// %r12d</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy = input; <span class=\"comment\">// mov %rsp, %r13</span></span><br><span class=\"line\"><span class=\"type\">int</span> val; <span class=\"comment\">// %eax</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    val = *(input_copy); <span class=\"comment\">// 0x0(%r13)</span></span><br><span class=\"line\">    val = val<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(val&gt;<span class=\"number\">5</span>)  explode()  <span class=\"comment\">// 元素值不得大于6</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    ++a1; <span class=\"comment\">// add $0x1, %r12d</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a1 == <span class=\"number\">6</span>) <span class=\"keyword\">break</span>; <span class=\"comment\">// jmp 95</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a2 = a1; <span class=\"comment\">// mov %r12d, %ebx</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;   <span class=\"comment\">// 65</span></span><br><span class=\"line\">        val = *(input+a2);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(val == *input_copy)</span><br><span class=\"line\">            explode();</span><br><span class=\"line\">        ++a2;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(a2&lt;= <span class=\"number\">5</span> ) <span class=\"comment\">// 87</span></span><br><span class=\"line\">    ++input_copy; <span class=\"comment\">// add $0x4, %r13</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 93</span></span><br><span class=\"line\"><span class=\"comment\">/*两个信息：(已验证)</span></span><br><span class=\"line\"><span class=\"comment\">1. 输入字符串中所有元素不大于6</span></span><br><span class=\"line\"><span class=\"comment\">2. 输入字符串中所有元素互不相等 */</span> <span class=\"number\">0</span>~<span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span>* sentry = input+<span class=\"number\">6</span>; <span class=\"comment\">// mov 0x18(%rsp), %rsi   95</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy_2 = input; <span class=\"comment\">// %rax</span></span><br><span class=\"line\"><span class=\"type\">int</span> a3 = <span class=\"number\">7</span>; <span class=\"comment\">// %edx, %ecx</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">    *(input_copy_2) = a3 - *(input_copy_2);</span><br><span class=\"line\">    ++input_copy_2;</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(input_copy_2 != sentry)</span><br><span class=\"line\"><span class=\"comment\">/* 更新输入字符串所有值为：7-初始值(已证实), </span></span><br><span class=\"line\"><span class=\"comment\">结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">int</span> a4 = <span class=\"number\">0</span>; <span class=\"comment\">// 123 %esi  -- index</span></span><br><span class=\"line\"><span class=\"type\">int</span> a5; <span class=\"comment\">// %edx</span></span><br><span class=\"line\"><span class=\"type\">int</span> a6; <span class=\"comment\">// %eax  -- index</span></span><br><span class=\"line\">offset_166:</span><br><span class=\"line\"><span class=\"keyword\">if</span>(input[a4] &lt;= <span class=\"number\">1</span>) <span class=\"comment\">// 166  %ecx</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a5 = <span class=\"number\">0x6032d0</span>; <span class=\"comment\">// 143</span></span><br><span class=\"line\">    offset_148:</span><br><span class=\"line\">    *(input+<span class=\"number\">0x20</span>+<span class=\"number\">2</span>*a4) = a5; <span class=\"comment\">// 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48</span></span><br><span class=\"line\">                             <span class=\"comment\">//   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320   </span></span><br><span class=\"line\">    a4 += <span class=\"number\">4</span>; <span class=\"comment\">// add $0x4, %rsi </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a4 ==  <span class=\"number\">24</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> offset_183; <span class=\"comment\">// 161 </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> offset_166;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>  <span class=\"comment\">// 均要走这个else， 可能有一个不走这个else --&gt;肯定有一个不走</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a6 = <span class=\"number\">1</span>;  <span class=\"comment\">// 171  </span></span><br><span class=\"line\">    &amp;a5 = <span class=\"number\">0x6032d0</span>; <span class=\"comment\">// 176  这个地址+0x8能多次跳转</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123; <span class=\"comment\">// 130</span></span><br><span class=\"line\">        a5 = *(&amp;a5 + <span class=\"number\">0x8</span>) ; <span class=\"comment\">// mov 0x8(%rdx),%rdx  链表?</span></span><br><span class=\"line\">        ++a6; </span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(a6 != *(input+a4) ) <span class=\"comment\">// 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> offset_148;         <span class=\"comment\">// recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 181</span></span><br><span class=\"line\"></span><br><span class=\"line\">offset_183：    function: link node in order</span><br><span class=\"line\"><span class=\"type\">int</span> a7 = input[<span class=\"number\">8</span>]; <span class=\"comment\">//%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy_3 = input+<span class=\"number\">10</span> <span class=\"comment\">// %rax  0x28(%rsp)</span></span><br><span class=\"line\"><span class=\"type\">int</span>* input_copy_4 = input+<span class=\"number\">20</span> <span class=\"comment\">// %rsi  0x50(%rsp)</span></span><br><span class=\"line\">a3 = a7; <span class=\"comment\">// a3:%rcx</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123; <span class=\"comment\">// 201</span></span><br><span class=\"line\">    a5 = *input_copy_3; <span class=\"comment\">//a5:%rdx [10][12]...[18][20] 6</span></span><br><span class=\"line\">    *(a3+<span class=\"number\">0x8</span>) = a5; <span class=\"comment\">// 0x8(%rcx)</span></span><br><span class=\"line\">    input_copy_3 += <span class=\"number\">2</span>; <span class=\"comment\">// 0x8 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(input_copy_3 == input_copy_4) <span class=\"keyword\">break</span>; <span class=\"comment\">// 215 </span></span><br><span class=\"line\">    a3 = a5; <span class=\"comment\">// mov %rdx, %rcx</span></span><br><span class=\"line\">&#125;    <span class=\"comment\">//   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)</span></span><br><span class=\"line\"><span class=\"comment\">// 结束时 %rdx = * (input + 18)</span></span><br><span class=\"line\"></span><br><span class=\"line\">*(*(input+<span class=\"number\">18</span>) + <span class=\"number\">2</span> ) = <span class=\"number\">0</span>; <span class=\"comment\">// 222   set last node&#x27;s pointer to nullptr</span></span><br><span class=\"line\"><span class=\"type\">int</span> a8 = <span class=\"number\">5</span>; <span class=\"comment\">// %ebp</span></span><br><span class=\"line\"><span class=\"type\">int</span> a9 <span class=\"comment\">// %rax </span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> &amp;a9 = *(a7+<span class=\"number\">2</span>); <span class=\"comment\">// %rax   initial a7 = input[8]</span></span><br><span class=\"line\">  a9 = *a9; <span class=\"comment\">// mov (%rax), %eax</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(*(*(input+<span class=\"number\">8</span>)) &lt; a9) <span class=\"comment\">// cmp %eax, (%rbx) </span></span><br><span class=\"line\">    explode();   <span class=\"comment\">// 验证是否降序</span></span><br><span class=\"line\">a7 = *(*(input+<span class=\"number\">8</span>)+<span class=\"number\">2</span>); <span class=\"comment\">// mov 0x8(%rbx), %rbx 更新%rbx  </span></span><br><span class=\"line\">--a8;</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(a8&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// over</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/*inital:</span></span><br><span class=\"line\"><span class=\"comment\">0x14c(0): 332;</span></span><br><span class=\"line\"><span class=\"comment\">0x0a8(1): 168;</span></span><br><span class=\"line\"><span class=\"comment\">0x39c(2): 924;</span></span><br><span class=\"line\"><span class=\"comment\">0x2b3(3): 691</span></span><br><span class=\"line\"><span class=\"comment\">0x1dd(4): 477</span></span><br><span class=\"line\"><span class=\"comment\">0x1bb(5): 443</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">2-&gt;3-&gt;4-&gt;5-&gt;0-&gt;1 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是<code>0x6032d0</code>这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使<code>0x6032d0</code>这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677403752602-71565a7a-ae83-4e0e-a0d7-cdd2e3df1fd5.png#averageHue=%23232222&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=165&amp;id=u5a9db9de&amp;name=image.png&amp;originHeight=248&amp;originWidth=1501&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=164901&amp;status=done&amp;style=none&amp;taskId=u365af322-15ad-46fb-9cfc-245887947ea&amp;title=list%20after%20sort&amp;width=1000.6666666666666\" alt=\"image.png\" title=\"list after sort\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677402131273-de3ea8a9-669e-4bf2-8194-cccb235cd58b.png#averageHue=%23282828&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=217&amp;id=ucd4dd2ed&amp;name=image.png&amp;originHeight=325&amp;originWidth=1104&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=146781&amp;status=done&amp;style=none&amp;taskId=u67c0a4b5-d060-40b2-9b3c-921a69962c7&amp;title=&amp;width=736\" alt=\"image.png\"><br><a name=\"QjpMp\"></a></p>\n<h2 id=\"secret-phase\"><a href=\"#secret-phase\" class=\"headerlink\" title=\"secret_phase\"></a>secret_phase</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404056138-294107ed-6f1c-4477-83c9-44b00041ef4b.png#averageHue=%232a2929&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=152&amp;id=u674c8aa7&amp;name=image.png&amp;originHeight=228&amp;originWidth=1213&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=42994&amp;status=done&amp;style=none&amp;taskId=u89aa5f1c-7b78-46bb-b51c-a2062f218dc&amp;title=&amp;width=808.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>发现彩蛋</li>\n</ol>\n<p>以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用<code>objdump -t bomb</code>查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404753141-3d41a656-d41d-476c-aae5-e51421f24d6e.png#averageHue=%230b0b0a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=338&amp;id=u59b20a1e&amp;name=image.png&amp;originHeight=507&amp;originWidth=1706&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=217929&amp;status=done&amp;style=none&amp;taskId=ub07a14e6-ebf4-4769-b55c-e586658a966&amp;title=&amp;width=1137.3333333333333\" alt=\"image.png\"></p>\n<ol>\n<li>怎么触发</li>\n</ol>\n<p>1)谁调用了secret_phase：<code>secret_phase</code>既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在<code>main</code>函数中寻找可能调用<code>secret_base</code>的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在<code>phase_defused</code>函数中，反汇编<code>phase_defused</code>函数，果然发现了调用<code>secret_phase</code>的指令<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404954528-c0e39bd3-077e-49cd-a460-d820f2047ce8.png#averageHue=%232b2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=488&amp;id=u9e4e339a&amp;name=image.png&amp;originHeight=732&amp;originWidth=1266&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=459111&amp;status=done&amp;style=none&amp;taskId=u6d1b7d59-0bf7-4df3-9948-00a20fc914f&amp;title=&amp;width=844\" alt=\"image.png\"><br>2）在phase_defused中如何触发：从<code>main</code>函数可以看出，bomb文件在每次未触发炸弹而执行完一个phase的时候都会调用一次<code>phase_defused</code>。分析phase_defused，该函数当输入字符串表示分隔的数字值时，如果数字个数小于6个，直接返回，对应phase1~phase5；如果数字等于6个，继续执行，对应phase6<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414713624-83322f4b-2b99-42ce-9152-3c094464743d.png#averageHue=%232a2a29&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=167&amp;id=u4e91d4e7&amp;name=image.png&amp;originHeight=251&amp;originWidth=1753&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=206560&amp;status=done&amp;style=none&amp;taskId=u8107d152-8bbe-44eb-beb6-bd477c6e492&amp;title=&amp;width=1168.6666666666667\" alt=\"image.png\"><br>接着从地址<code>0x603870</code>处读取两个数字，一个字符串<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414792269-cc61be84-af1a-449f-b88a-efdf5b602450.png#averageHue=%23262626&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=52&amp;id=u54634d3d&amp;name=image.png&amp;originHeight=78&amp;originWidth=676&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=25535&amp;status=done&amp;style=none&amp;taskId=uf1933c57-b4a3-46a2-a583-11eeb6c7623&amp;title=&amp;width=450.6666666666667\" alt=\"image.png\"><br>经过验证，地址<code>0x603870</code>为phase_4阶段输入字符串的开始地址<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414872028-db9b7aa7-d78c-450a-877d-8d643d89022d.png#averageHue=%23272626&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=52&amp;id=u20d9ba63&amp;name=image.png&amp;originHeight=78&amp;originWidth=763&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=32367&amp;status=done&amp;style=none&amp;taskId=uf4f5ab27-77d8-4b6a-9614-34ea9d69b04&amp;title=&amp;width=508.6666666666667\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414887631-8de449af-6eff-4f20-9632-860f0d751f77.png#averageHue=%232b2b2b&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=51&amp;id=u78a64d3f&amp;name=image.png&amp;originHeight=76&amp;originWidth=856&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=31655&amp;status=done&amp;style=none&amp;taskId=u1f45d585-4254-407d-a785-6859f161d5b&amp;title=&amp;width=570.6666666666666\" alt=\"image.png\"><br>根据后续逻辑，只要在phase_4阶段时输入<code>&quot;7 0 DrEvil&quot;</code>即可触发<code>secret_bomb</code><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415081966-c8dd9474-52be-4ca5-b73b-da79cea387f2.png#averageHue=%232b2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=289&amp;id=uff04a21c&amp;name=image.png&amp;originHeight=434&amp;originWidth=1193&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=295794&amp;status=done&amp;style=none&amp;taskId=uc3d47c14-4fd2-4066-8097-d303800fa51&amp;title=&amp;width=795.3333333333334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415023030-75fb6b08-160a-41a7-ac0c-2cd054c806ee.png#averageHue=%23272727&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=53&amp;id=u647b3556&amp;name=image.png&amp;originHeight=79&amp;originWidth=501&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=19252&amp;status=done&amp;style=none&amp;taskId=ubfabe50b-c88f-4d79-8759-413c728c17a&amp;title=&amp;width=334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415142283-f37e926f-a289-4c18-9170-346e631d561e.png#averageHue=%232a2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=361&amp;id=uc5b1fa4e&amp;name=image.png&amp;originHeight=542&amp;originWidth=1158&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=228864&amp;status=done&amp;style=none&amp;taskId=u4bbc5a61-2cb2-48b7-95b7-d8b064cb1ad&amp;title=&amp;width=772\" alt=\"image.png\"></p>\n<ol>\n<li>终章：拆解secret_phase</li>\n</ol>\n<p>1）反编译secret_base<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secret_phase()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> input_2;<span class=\"comment\">// (%rdi)</span></span><br><span class=\"line\">    &amp;input_2 = read_line(); <span class=\"comment\">//  %rdi</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> a1 = <span class=\"number\">0xa</span>; <span class=\"comment\">// %edx</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a2 = <span class=\"number\">0x0</span>; <span class=\"comment\">// %esi</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">int</span> input_num_1 = strtol(input_2); <span class=\"comment\">// %rax</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">int</span> input_num_2 = input_num_1 <span class=\"comment\">// %rbx</span></span><br><span class=\"line\">    input_num_1 -= <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(input_num_1 &gt; <span class=\"number\">0x3e8</span> <span class=\"comment\">/*1000*/</span>) explode();</span><br><span class=\"line\">    <span class=\"comment\">// 输入的数字字符串 值小于 1001</span></span><br><span class=\"line\">    a2 = input_num_2;<span class=\"comment\">// mov %ebx, %esi  </span></span><br><span class=\"line\">    &amp;input_2 = <span class=\"number\">0x6030f0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = fun7(&amp;input_2,a2,input_num_1); <span class=\"comment\">// ret_value: %rax</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ret == <span class=\"number\">0x2</span>)</span><br><span class=\"line\">        defused();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        explode(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fun7</span><span class=\"params\">(&amp;input_2, a2, input_num_1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(&amp;input_2 == <span class=\"number\">0x0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// avoid endless recursion</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a3 = *(&amp;input_2);  <span class=\"comment\">// 9 %edx   initial a3 = 24</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a3 &lt;= a2) <span class=\"keyword\">goto</span> offset_28; <span class=\"comment\">// 13  a2是输入值 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a3 &gt; a2</span></span><br><span class=\"line\">    input_2 = *(&amp;input_2 + <span class=\"number\">0x8</span>); <span class=\"comment\">// +2  turn left</span></span><br><span class=\"line\">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class=\"comment\">// 19</span></span><br><span class=\"line\"></span><br><span class=\"line\">    input_num_1 *= <span class=\"number\">2</span>; <span class=\"comment\">// input_num_q is 1 here</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input_num_1;</span><br><span class=\"line\"></span><br><span class=\"line\">    offset_28:</span><br><span class=\"line\">    input_num_1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a3 == a2) <span class=\"keyword\">return</span> input_num_1;\t</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a3 &lt; a2</span></span><br><span class=\"line\">    input_2 = *(&amp;input_2 + <span class=\"number\">0x10</span>); <span class=\"comment\">// +4   turn right</span></span><br><span class=\"line\">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class=\"comment\">// 0</span></span><br><span class=\"line\">    input_num_1 = <span class=\"number\">2</span>*input_num_1 + <span class=\"number\">1</span>;  <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input_num_1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>2）有了phase_6的经验，我在查看了特殊地址<code>0x6030f0</code>的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址<code>0x6030f0</code>为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合<code>secret_phase</code>的逻辑，在子函数<code>fun7</code>返回值为2时defuse，经过分析，<code>fun7</code>这个递归函数，在最后三次递归时为turn left(<code>&amp;input_2 + 0x8</code>）-&gt;turn right(<code>&amp;input_2 + 0x10</code>) -&gt; return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484445488-99b96bb8-8026-406a-8606-b6ed814389d7.png#averageHue=%232b2b2b&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=565&amp;id=u5030ad8b&amp;name=image.png&amp;originHeight=848&amp;originWidth=1530&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=595091&amp;status=done&amp;style=none&amp;taskId=uf7e602a3-1dfa-4402-88da-6b6d06e26db&amp;title=&amp;width=1020\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484586007-34081aec-ae5a-409a-9270-7503f23d697b.png#averageHue=%23fefefe&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=268&amp;id=u3886e51a&amp;name=image.png&amp;originHeight=321&amp;originWidth=613&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=45328&amp;status=done&amp;style=none&amp;taskId=uc94db6c6-0837-40f5-8324-986eeadfa19&amp;title=&amp;width=511.66668701171875\" alt=\"image.png\"><br>3) 至此，整个bomblab就结束了，花费了我十多个小时完成了这个lab还是很值得的，伴随这一个又一个defuse，成就感是满满的，哈哈哈<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484822762-1f6d54b5-8a8f-405e-ab5b-b3de5c095440.png#averageHue=%232d2d2d&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=309&amp;id=ua22fc755&amp;name=image.png&amp;originHeight=463&amp;originWidth=1657&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=276450&amp;status=done&amp;style=none&amp;taskId=ua2ea40a4-48b8-410d-a36d-c5de36dd026&amp;title=&amp;width=1104.6666666666667\" alt=\"image.png\"></p>\n<hr>\n<p><a name=\"SLpu6\"></a></p>\n<h1 id=\"lab3-attacklab\"><a href=\"#lab3-attacklab\" class=\"headerlink\" title=\"lab3 attacklab\"></a>lab3 attacklab</h1><p><a name=\"UbCO7\"></a></p>\n<h2 id=\"前提-1\"><a href=\"#前提-1\" class=\"headerlink\" title=\"前提\"></a>前提</h2><ol>\n<li><p>注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04</p>\n<p>博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题</p>\n</li>\n<li><p>exploit string用工具<code>hex/2raw</code>构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。</p>\n</li>\n</ol>\n<p>writeup的附录A介绍了多种<code>hex/2raw</code>接受输入字符串并传递给ctarget的多种方式，我习惯用：<br><code>./hex2raw &lt; exploit_string.txt | ./ctarget -q</code><br>这条命令将<code>exploit_string.txt</code>作为<code>hex2raw</code>的输入，并建立管道将<code>hex2raw</code>的输出传输到<code>./ctarget</code>中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行<code>./hex2raw</code>那么将无法中止输入<br><a name=\"Kk3w5\"></a></p>\n<h2 id=\"phase-1-1\"><a href=\"#phase-1-1\" class=\"headerlink\" title=\"phase_1\"></a>phase_1</h2><ol>\n<li>反汇编<code>ctarget</code>：可用<code>objdump -d ctarget</code>获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585087533-3d1cfcba-4dd9-41f4-8cc8-bb4c35b8674f.png#averageHue=%231b1b1b&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=40&amp;id=u07c104d6&amp;name=image.png&amp;originHeight=60&amp;originWidth=1223&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=26128&amp;status=done&amp;style=none&amp;taskId=u6e9b8aa5-d406-4587-b032-e270697a03a&amp;title=&amp;width=815.3333333333334\" alt=\"image.png\"><br>这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了</p>\n<ol>\n<li><code>vim dis_ctarget.asm</code>查看<code>getbuf</code>函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者<code>test</code>函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看<code>touch1</code>函数，它的地址在<code>0x004017c0</code>处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585873581-353e1114-4253-4b23-aceb-6ba85c12e660.png#averageHue=%231c1c1c&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=318&amp;id=ub151bf36&amp;name=image.png&amp;originHeight=477&amp;originWidth=1375&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=178834&amp;status=done&amp;style=none&amp;taskId=u661b7e64-355d-4240-a2ac-0d48718019c&amp;title=&amp;width=916.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li><p><code>vim phase_1.txt</code>输入</p>\n<p>$\\begin{matrix}<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\\\<br>&amp;00 &amp;00  &amp; 00 &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\\\<br>&amp;00  &amp;00  &amp;00  &amp;00 &amp;00  &amp;00  &amp;00  &amp;00\\\\<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\\\<br>&amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\\\<br>&amp;c0 &amp;17  &amp;40  &amp;00  &amp;00  &amp;00  &amp;00<br>\\end{matrix}$<br>最后留了一个字节以供gets放入’ \\n ‘ (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677586525442-cc13fc97-7de2-4bc6-90c7-bdb9356cc9b4.png#averageHue=%231c1c1c&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=196&amp;id=u93bb9ade&amp;name=image.png&amp;originHeight=294&amp;originWidth=1896&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=129168&amp;status=done&amp;style=none&amp;taskId=u503e0466-2b33-4b30-9a9e-f21980d78e7&amp;title=&amp;width=1264\" alt=\"image.png\"><br><a name=\"xCSRi\"></a></p>\n<h2 id=\"phase-2-1\"><a href=\"#phase-2-1\" class=\"headerlink\" title=\"phase_2\"></a>phase_2</h2></li>\n<li><p>编写汇编代码，转化为字节码：<code>vim asb.s</code>，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637642575-745a9de7-6e49-4ef0-9f44-46dbe3cfb8a0.png#averageHue=%23232323&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=62&amp;id=uc88e8483&amp;name=image.png&amp;originHeight=93&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=15349&amp;status=done&amp;style=none&amp;taskId=u1fe3d97e-2ee2-4e3f-b2f0-921ac53df4e&amp;title=&amp;width=253.33333333333334\" alt=\"image.png\"><br>line1将<code>cookie</code>值赋给<code>%rdi</code>传参给<code>touch2</code>；ine2将2<code>touch2</code>的地址压入栈中，目的在于在<code>ret</code>指令执行后，从栈中弹出并赋值给<code>%rip</code>的返回地址是<code>touch2</code>的地址<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637347348-81a97333-5ab5-4766-b689-e0a40d50a9b1.png#averageHue=%23131313&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=221&amp;id=u494680d1&amp;name=image.png&amp;originHeight=331&amp;originWidth=1165&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=130023&amp;status=done&amp;style=none&amp;taskId=u8d81b4ca-fd2a-4ce9-ba46-d1e09ded02c&amp;title=%E8%8E%B7%E5%8F%96touch2%E7%9A%84%E5%9C%B0%E5%9D%80&amp;width=776.6666666666666\" alt=\"image.png\" title=\"获取touch2的地址\"><br>writeup的附录B提示我们将gcc与objdump结合使用产生指令序列的字节码<br><code>gcc -c asb.s</code><br><code>objdump -d asb.o &gt; asb.d</code><br>这样我们就得到了指令序列的字节码，可用于构造exploit_string<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638192080-ecafc66a-645a-4bf0-a9d2-af3a00412381.png#averageHue=%23191918&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=203&amp;id=u9041b219&amp;name=image.png&amp;originHeight=304&amp;originWidth=962&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=84296&amp;status=done&amp;style=none&amp;taskId=ue5e430b5-0a7a-42c3-8791-f51017acec7&amp;title=&amp;width=641.3333333333334\" alt=\"image.png\"></p>\n<ol>\n<li>构造<code>phase_2.txt</code>，因为<code>asb.o</code>中的代码本身就已经逆序，所以直接输入即可；用于覆盖<code>test</code>栈帧中返回地址的值可由<code>%rsp</code>的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是<code>%rsp</code>的值</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677591555601-28a75db3-4efc-445a-bd75-67d6722d57ee.png#averageHue=%231d1d1d&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=359&amp;id=pvcAu&amp;name=image.png&amp;originHeight=539&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=188389&amp;status=done&amp;style=none&amp;taskId=u8ffbde5e-78e3-433e-a1a6-dfa4742b694&amp;title=%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%80%BC&amp;width=783.3333333333334\" alt=\"image.png\" title=\"获取栈顶值\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638376139-5fb21190-4237-424f-a168-1c204bce6ef7.png#averageHue=%231b1b1b&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=406&amp;id=ud656f730&amp;name=image.png&amp;originHeight=609&amp;originWidth=806&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=117050&amp;status=done&amp;style=none&amp;taskId=u39e09168-0d44-4223-a419-2cad498a46f&amp;title=phase_2_exploit_string&amp;width=537.3333333333334\" alt=\"image.png\" title=\"phase_2_exploit_string\"></p>\n<ol>\n<li>攻击生效</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638454464-852c44b4-14f9-43fe-8e9f-a927c267b260.png#averageHue=%230b0b0b&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=233&amp;id=ua99fc494&amp;name=image.png&amp;originHeight=349&amp;originWidth=1225&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=146341&amp;status=done&amp;style=none&amp;taskId=uba333293-f36a-4b4a-bd6b-7ab4d63bd03&amp;title=&amp;width=816.6666666666666\" alt=\"image.png\"><br><a name=\"TVVPU\"></a></p>\n<h2 id=\"phase-3-1\"><a href=\"#phase-3-1\" class=\"headerlink\" title=\"phase_3\"></a>phase_3</h2><ol>\n<li>与<code>phase_2</code>很像，但这次要传递的参数是字符串形式的<code>cookie</code>。因为<code>getbuf</code>的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串<code>cookie</code>放在<code>test</code>函数的栈帧中，地址<code>0x5561dca8</code>；获取<code>touch3</code>函数的地址，编写攻击代码</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677673769317-083e3c3d-3eb7-4716-8b34-154511f96d34.png#averageHue=%231c1c1c&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=236&amp;id=ufe6c6401&amp;name=image.png&amp;originHeight=354&amp;originWidth=1183&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=123850&amp;status=done&amp;style=none&amp;taskId=ue426e205-3b8c-42f1-a2ca-516774edd68&amp;title=&amp;width=788.6666666666666\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678328785-d2f2582c-e25c-484b-83d8-4a0a2595ab07.png#averageHue=%23060606&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=61&amp;id=u15b6d558&amp;name=image.png&amp;originHeight=91&amp;originWidth=347&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=11449&amp;status=done&amp;style=none&amp;taskId=u1ce98f2a-043c-4c00-b0a0-20b0f14e918&amp;title=&amp;width=231.33333333333334\" alt=\"image.png\"></p>\n<ol>\n<li><code>ascii -ax</code>查看十六进制形式的ascii-table，得出<code>&quot;59b997fa&quot;</code>的ascii形式为<code>35 39 62 39 39 37 66 61</code></li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678551264-8b3b6a28-3390-45cb-bbc6-b20f241eb472.png#averageHue=%231d1d1d&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=247&amp;id=u95244bf5&amp;name=image.png&amp;originHeight=370&amp;originWidth=1204&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=116378&amp;status=done&amp;style=none&amp;taskId=u6e6beaa6-64b0-4c0c-ba41-3a88510ea43&amp;title=&amp;width=802.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>覆盖返回地址和test栈帧，写入攻击代码的地址和字符串<code>cookie</code></li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678755332-3ea51646-6c2b-4212-8f6a-d6fe5551fa9a.png#averageHue=%23202020&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=210&amp;id=u5caf20c9&amp;name=image.png&amp;originHeight=315&amp;originWidth=871&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=61586&amp;status=done&amp;style=none&amp;taskId=uc183fab2-b53c-4109-9912-d5f30dc3d02&amp;title=&amp;width=580.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>攻击生效</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678782689-4f003174-6f36-4200-87cd-d46e586d9907.png#averageHue=%231d1d1d&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=235&amp;id=u145918cd&amp;name=image.png&amp;originHeight=353&amp;originWidth=1184&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=131718&amp;status=done&amp;style=none&amp;taskId=u08615a2d-ec29-45b1-bc0c-7f9a93e2212&amp;title=&amp;width=789.3333333333334\" alt=\"image.png\"><br><a name=\"UnHwd\"></a></p>\n<h2 id=\"phase-4-1\"><a href=\"#phase-4-1\" class=\"headerlink\" title=\"phase_4\"></a>phase_4</h2><p>确定攻击方案：<code>rtarget</code>由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用<code>ctarget</code>自身的代码实现攻击，具体做法是通过地址跳转，截取<code>ctarget</code>的部分代码用作攻击代码；<code>gadget</code>指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串<code>gadget</code>的地址，那么一旦执行其中一个<code>gadget</code>，<code>ret</code>指令就会不断的从栈中弹出新的<code>gadget</code>的地址赋给<code>%rip</code>,由此引发多个<code>gadget</code>的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）</p>\n<ol>\n<li><code>cookie</code>的值不可能从<code>rgadget</code>中找到，需要我们自己放到栈中，如同<code>phase_3</code>一样，放的位置不能是<code>getbuf</code>的缓冲区，因此我们将其放到<code>test</code>的栈帧中；接着要实现<code>mov $0x59b997fa,%rdi</code>，需执行<code>popq %rdi</code>，根据writeup的参照表，先在<code>start_farm</code>和<code>end_farm</code>之间寻找<code>5f</code>，结果没有，但是找到了<code>58 90</code>,地址为<code>0x004019ab</code>，这代表<code>popq %rax  nop</code>，因此我们需要用<code>%rax</code>作介质传递<code>cookie</code>给<code>%rdi</code>，而在farm中我们也确实找到了<code>movq %rax, %rdi：48 89 c7</code>，地址为<code>0x004019c5</code>，一共用到了两个<code>gadget</code></li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748308138-674aa437-9522-414c-afcf-828967ad2c1b.png#averageHue=%231f1f1f&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=82&amp;id=ueb5eeaef&amp;name=image.png&amp;originHeight=123&amp;originWidth=1061&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=44128&amp;status=done&amp;style=none&amp;taskId=u3043295b-c67b-407d-81b2-642907b3b41&amp;title=&amp;width=707.3333333333334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748250489-e3dcf01c-ae26-4997-a969-4efde7d2c835.png#averageHue=%231c1b1b&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=163&amp;id=ube7f5b3e&amp;name=image.png&amp;originHeight=244&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=73997&amp;status=done&amp;style=none&amp;taskId=ub3c3a582-4fc1-4e85-ac8e-de93a3fa7d2&amp;title=&amp;width=706.6666666666666\" alt=\"image.png\"></p>\n<ol>\n<li>按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750944719-6ccf095c-ffce-4020-8cb6-f5b0f0fde9f8.png#averageHue=%2310222d&amp;clientId=u0689b11d-a2d1-4&amp;from=ui&amp;height=546&amp;id=u0eb7edee&amp;name=yuque_diagram.png&amp;originHeight=1110&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38484&amp;status=done&amp;style=none&amp;taskId=uf668df10-5035-4532-8f4f-6e2ef500940&amp;title=&amp;width=187\" alt=\"yuque_diagram.png\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677751046005-10305a9e-443a-4de9-9d53-344ef204db84.png#averageHue=%23202020&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=186&amp;id=u3879cf7f&amp;name=image.png&amp;originHeight=279&amp;originWidth=762&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=62095&amp;status=done&amp;style=none&amp;taskId=uef71dd0c-5925-4f87-8c3b-ca049535c44&amp;title=&amp;width=508\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750954828-918501d5-682b-4638-ac25-f66bced64fb7.png#averageHue=%231c1c1c&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=235&amp;id=u61b7152b&amp;name=image.png&amp;originHeight=353&amp;originWidth=1387&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=128770&amp;status=done&amp;style=none&amp;taskId=u3e63c29c-34df-412e-b6ae-c66bfaa71c6&amp;title=&amp;width=924.6666666666666\" alt=\"image.png\"></p>"},{"title":"Cachelab: cache simulator","date":"2023-03-16T04:00:00.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"HHpvX\"></a>\n\n# lab4 cachelab\n<!--more-->\n\n## 1. 要做什么\n\n1. 组索引位数 -s  （$S = 2^s$为高速缓存组的组数）\n2. 高速缓存行数 -E \n3. 块偏移位数 -b （$B = 2^b$为高速缓存块的大小）\n\n根据内存访问记录，输出每条访问的结果（hit/miss/evict)，输出操作通过调用`printSummary(hit_count, miss_count, eviction_count)`函数完成，输出结果应当与作者提供给我们的`reference cache simulator`相同，运行`make`+`./test-csim`获取评分\n<a name=\"i3aH1\"></a>\n## 2. getopt函数的用法\n由于三个参数通过命令行输入，因此我们需要通过C语言库中的`getopt`函数，结合switch语句从命令行中获取参数值 <br />C语言中的`main`函数是程序的入口函数，它包含两个参数：`argc`和`argv`。它们的作用如下：\n\n1. argc参数\n\nargc参数表示程序运行时命令行参数的个数（argument count），包括程序名本身。因此，argc的值至少为1，即第一个参数是程序名本身。如果程序没有接受任何命令行参数，则argc的值为1。\n\n2. argv参数\n\nargv参数是一个字符串指针数组（argument vector），每个元素指向一个命令行参数。其中，argv[0]指向程序名本身，argv[1]、argv[2]等等依次指向后续的命令行参数。<br />通过argc和argv参数，程序可以接收命令行传递的参数，从而实现更加灵活和可配置的功能。例如，可以通过命令行参数指定程序要处理的文件名、程序要使用的配置文件、程序要输出的日志级别等等。程序可以根据不同的命令行参数采取不同的行为，从而实现更加灵活和可配置的功能。<br />C语言中的`getopt`函数可以帮助程序解析命令行参数。`getopt`函数通常与`argc`和`argv`参数一起使用，可以从命令行中提取选项和参数，并根据需要执行相应的操作。以下是`getopt`函数的一般用法：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[])\n{\n    int opt;\n    while ((opt = getopt(argc, argv, \"abc:d\")) != -1) {\n        switch (opt) {\n            case 'a':\n                printf(\"Option -a\\n\");\n                break;\n            case 'b':\n                printf(\"Option -b\\n\");\n                break;\n            case 'c':\n                printf(\"Option -c with value '%s'\\n\", optarg);\n                break;\n            case 'd':\n                printf(\"Option -d\\n\");\n                break;\n            case '?':\n                printf(\"Unknown option: %c\\n\", optopt);\n                break;\n        }\n    }\n    return 0;\n}\n\n```\n在上面的例子中，`getopt`函数的第一个参数是`argc`，第二个参数是`argv`，第三个参数是一个字符串，它包含可接受的选项和参数信息。在这个字符串中，每个字符表示一个选项，如果这个选项需要接受一个参数，则在后面加上一个冒号。例如，`\"abc:d\"`表示可接受的选项有`-a`、`-b`、`-c`和`-d`，其中`-c`选项需要接受一个参数。<br />`getopt`函数会循环遍历命令行中的所有选项，每次返回一个选项和其参数（如果有）。在循环中，使用`switch`语句根据选项进行相应的操作。如果`getopt`函数发现了一个未知的选项，它会返回`?`,并将这个选项保存在`optopt`变量中。<br />以下是一些示例命令行及其对应的输出：\n```bash\n$ ./a.out -a -b -c filename -d\nOption -a\nOption -b\nOption -c with value 'filename'\nOption -d\n```\n```bash\n$ ./a.out -a -b -c\nOption -a\nOption -b\nUnknown option: c\n```\n在使用`getopt`函数时，需要注意以下几点：\n\n1. 在循环中，`optarg`变量保存当前选项的参数（如果有），可以通过这个变量获取参数的值。变量类型为字符串，可通过`atoi`函数转化为整型。\n2. 如果一个选项需要接受一个参数，但是没有给出参数，或者参数不合法，`getopt`函数会返回`?`，并将这个选项保存在`optopt`变量\n3. 如果一个选项在可接受的选项字符串中没有指定，`getopt`函数会返回`-1`，并结束循环\n\n`getopt`函数的第三个参数是一个字符串，用于指定程序支持的命令行选项和参数。<br />虽然`getopt`函数可以遍历所有命令行参数，但是在不指定可接受选项字符串的情况下，`getopt`函数不知道哪些参数是选项，哪些是参数，也不知道选项是否需要参数。指定<br />可接受选项字符串可以告诉`getopt`函数哪些选项是合法的，以及它们是否需要参数，从而使`getopt`函数能够正确地解析命令行参数。接受选项字符串的格式为一个字符串，由选项和参数组成，每个选项用一个字符表示，如果选项需要参数，则在选项字符后面跟一个冒号。例如，字符串`\"ab:c\"`表示程序支持三个选项`-a`、`-b`和`-c`, 其中`-c`选项需要一个参数。\n<a name=\"kBmQw\"></a>\n## 3. fscanf的用法\n`fscanf`是C语言标准库中的一个函数，它可以从一个文件中读取格式化数据，并将读取的结果存储到指定的变量中，该函数返回成功填充参数列表的项目数。`fscanf`函数的基本格式如下：\n```c\nint fscanf(FILE *stream, const char *format, ...);\n```\n其中，第一个参数`stream`是指向要读取数据的文件的指针；第二个参数`format`是一个字符串，用于指定读取数据的格式；第三个及之后的参数是要读取数据的变量名。<br />例如，如果你有一个文件`data.txt`，里面包含了三个整数，每个整数之间用空格分隔，你可以使用下面的代码将这些整数读取到三个变量`a`、`b`、`c`中\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp = fopen(\"data.txt\", \"r\");\n    int a, b, c;\n    fscanf(fp, \"%d %d %d\", &a, &b, &c);\n    printf(\"a = %d, b = %d, c = %d\\n\", a, b, c);\n    fclose(fp);\n    return 0;\n}\n```\n在上面的例子中，`fscanf`函数的第一个参数是文件指针`fp`，第二个参数是格式化字符串`\"%d %d %d\"`，它表示要读取三个整数，每个整数之间用空格分隔。第三个、第四个和第五个参数分别是三个整数变量`a`、`b`、`c`的地址，`fscanf`函数将读取到的整数存储到这些变量中。最后，我们打印出这些变量的值，以检查是否正确读取了文件中的数据。\n<a name=\"dKoHs\"></a>\n## 4. 编写程序\n这个实验不是真的让你去实现一个cache，而是让你编写一个能对访问记录进行应答的程序，这也是为什么writeup里强调所有的内存访问操作所需的块都不会超过行的容量<br />![yuque_diagram.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1678952903754-2052873c-6eb8-47c2-84e6-48ae84c0df8f.png)\n\n1. cache结构声明\n\ncache本质上是一个2D array，因此我们在结构体中声明一个指向二维数组的指针\n```cpp\ntypedef struct cache_line\n{\n\tint valid_bit;\n\tint tag;\n    int time_stamp;\n}cache_line;\n\ntypedef struct cache\n{\n\tint S;\n\tint E;\n\tint B;\n\tcache_line** Cache; \n}cache;\n```\n\n2. main\n\n主要在于正确解析命令行参数，会用`getopt`就行\n```cpp\nint main(int argc, char* argv[])\n{ \t\n    int\thit_count = 0, miss_count = 0, eviction_count = 0;\n    int s, E, b,opt;\n    char* trace_name = (char*)malloc(sizeof(char)*30);\n    cache* my_cache;\n    while((opt = getopt(argc, argv, \"s:E:b:t:\"))!= -1){\n\t\tswitch(opt){\n\t\tcase 's':\n\t\t   s = atoi(optarg);\n\t\t   break;\n\t\tcase 'E':\n\t\t   E = atoi(optarg);\n\t\t   break;\n\t\tcase 'b':\n\t\t   b = atoi(optarg);\n\t\t   break;\n\t\tcase 't':\n\t\t   strcpy(trace_name,optarg);\n\t\t   break;\n\t\tcase '?':\n\t\t   printf(\"unknown option: %c\\n\",optopt);\n\t\t   break;\n\t\t   }\n     }\n     my_cache = construct_cache(s,E,b);\n     access_cache(my_cache, s, b, trace_name, &hit_count, &miss_count, &eviction_count);\n     free_cache(my_cache);\n     printSummary(hit_count, miss_count, eviction_count);\n     return 0;\n }\n```\n\n3. construct_cache\n\n根据输入的命令行参数`s`,`E`,`b`构造cache，并初始化每一个高速缓存行\n```cpp\n cache* construct_cache(int s, int E, int b)\n {\n     cache* my_cache =(cache*) malloc(sizeof(cache));  // construct Cache\n\t my_cache->S = 1 << s;\n\t my_cache->B = 1 << b;\n\t my_cache->E = E;\n\t my_cache->Cache = (cache_line**)malloc(my_cache->S * sizeof(cache_line*) );\n\t for(int i=0; i<my_cache->S;++i)\n\t {\n\t\tmy_cache->Cache[i] = (cache_line*)malloc(my_cache->E * sizeof(cache_line));\n\t\tfor(int j=0; j<my_cache->E; ++j) // initialize\n\t\t{\n\t\t\tmy_cache->Cache[i][j].valid_bit = 0;\n\t\t\tmy_cache->Cache[i][j].tag = -1;\n\t\t\tmy_cache->Cache[i][j].time_stamp = 0;\n\t\t}\n\n\t}\n\treturn my_cache;\n }\n```\n\n4. update_LRU\n\n我是通过对每个高速缓冲行维护一个time_stamp实现的LRU，因此更新Cache中各行的LRU操作很重要。对访问的行，time_stamp置0，有效位和tag位也要做更新，其余行的time_stamp加1\n```cpp\nvoid update_LRU(cache* my_cache, int ad_set, int ad_tag, int line_index)\n{\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t\tif(my_cache->Cache[ad_set][i].valid_bit) ++(my_cache->Cache[ad_set][i].time_stamp);\n\n\tmy_cache->Cache[ad_set][line_index].time_stamp = 0;\n\tmy_cache->Cache[ad_set][line_index].valid_bit = 1;\n\tmy_cache->Cache[ad_set][line_index].tag = ad_tag;\n}\n```\n\n5. get_line_index\n\n每次访问cache，要得知hit，miss，eviction等信息，通过该函数实现：查找cache中所有行，如果找到有效位为1且tag位符合的行，则命中，否则miss\n```cpp\nint get_line_index(cache* my_cache, int ad_set, int ad_tag)\n{\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t{\n\t\tif(my_cache->Cache[ad_set][i].valid_bit && my_cache->Cache[ad_set][i].tag == ad_tag)\n\t\t\treturn i;  // hit\n\t}\n\treturn -1; // miss\n}\n```\n\n6. is_not_full\n\n。进一步对miss，遍历cache所有行，如果找不到有效位为0的行，则说明cache is full，那么就额外涉及有eviction操作\n```cpp\nint is_not_full(cache* my_cache, int ad_set)\n{\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t\tif(!my_cache->Cache[ad_set][i].valid_bit) return i;\n\n\treturn -1;\n}\n```\n\n7. find_LRU\n\n对eviction操作，执行我们的LRU替换策略，先找到时间戳最大的行，再进行覆盖操作\n```cpp\nint find_LRU(cache* my_cache, int ad_set)\n{\n\tint max_stamp = 0;\n\tint evict_line = 0;\n\tint temp = 0;\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t{\n\t\ttemp = my_cache->Cache[ad_set][i].time_stamp;\n\t\tif(temp > max_stamp)\n\t\t\t{\n\t\t\t\tmax_stamp = temp;\n\t\t\t\tevict_line = i;\n\t\t\t}\n\t}\n\treturn evict_line;\n}\n```\n\n8. access_cache\n\n我们需要用`fscanf`对数据访问操作进行解析，注意此处的`\" %c %x,%d\"`,`%c`前有一个whitespace，目的在于忽略对指令访问操作。由于不同数据访问指令执行的cache操作次数不同，因此我将对cache进行操作的部分分割成一个独立的函数`real_access_cache`。M等于L+S，因此需要两次更新。\n```cpp\nvoid access_cache(cache* my_cache, int s, int b, char* trace_name, int* hit_count_ptr, int* miss_count_ptr, int* eviction_count_ptr)\n {\n \t FILE* pFile;   // receive access\n     pFile = fopen(trace_name,\"r\");\n     if(!pFile) exit(-1);\n     char identifier;\n     unsigned address;\n     int size;\n     while(fscanf(pFile,\" %c %x,%d\",&identifier,&address,&size)>0)\n     {     \n\t\tint mask =(unsigned)(-1)>>(64-s);\n\t\tint ad_set = (address >> b) & mask;\n\t\tint ad_tag = address >> (s+b);\n\t\tswitch(identifier)\n\t\t{\n\t\tcase 'M':\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(pFile);\n }\n\n void real_access_cache(cache* my_cache, int ad_set, int ad_tag, int* hit_count_ptr, int* miss_count_ptr, int* eviction_count_ptr)\n {\n    int line_index,free_line, evict_line;\n\tline_index = get_line_index(my_cache, ad_set, ad_tag);\n\tif(line_index != -1)\n\t{\n\t\t++(*hit_count_ptr);\n\t\tupdate_LRU(my_cache, ad_set, ad_tag, line_index);\n\t}\n\n\telse \n\t{\n\t\tfree_line = is_not_full(my_cache, ad_set);\n\t\tif(free_line != -1)\n\t\t{\n\t\t\t++(*miss_count_ptr);\n\t\t\tupdate_LRU(my_cache, ad_set, ad_tag, free_line);\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\t++(*miss_count_ptr);\n\t\t\t++(*eviction_count_ptr);\n\t\t\tevict_line = find_LRU(my_cache,ad_set);\n\t\t\tupdate_LRU(my_cache, ad_set, ad_tag, evict_line);\n\t\t}\n\t\t\n\t}\t\n}\n```\n<a name=\"XOedv\"></a>\n## 5. 结果\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1678885115012-43a6dad1-7672-42f8-b302-42c04af83585.png)\n\n","source":"_posts/cache.md","raw":"---\ntitle: \"Cachelab: cache simulator\"\ndate: 2023/03/16\ncategories:\n- CSAPP\ntags: \n- Foundation\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"HHpvX\"></a>\n\n# lab4 cachelab\n<!--more-->\n\n## 1. 要做什么\n\n1. 组索引位数 -s  （$S = 2^s$为高速缓存组的组数）\n2. 高速缓存行数 -E \n3. 块偏移位数 -b （$B = 2^b$为高速缓存块的大小）\n\n根据内存访问记录，输出每条访问的结果（hit/miss/evict)，输出操作通过调用`printSummary(hit_count, miss_count, eviction_count)`函数完成，输出结果应当与作者提供给我们的`reference cache simulator`相同，运行`make`+`./test-csim`获取评分\n<a name=\"i3aH1\"></a>\n## 2. getopt函数的用法\n由于三个参数通过命令行输入，因此我们需要通过C语言库中的`getopt`函数，结合switch语句从命令行中获取参数值 <br />C语言中的`main`函数是程序的入口函数，它包含两个参数：`argc`和`argv`。它们的作用如下：\n\n1. argc参数\n\nargc参数表示程序运行时命令行参数的个数（argument count），包括程序名本身。因此，argc的值至少为1，即第一个参数是程序名本身。如果程序没有接受任何命令行参数，则argc的值为1。\n\n2. argv参数\n\nargv参数是一个字符串指针数组（argument vector），每个元素指向一个命令行参数。其中，argv[0]指向程序名本身，argv[1]、argv[2]等等依次指向后续的命令行参数。<br />通过argc和argv参数，程序可以接收命令行传递的参数，从而实现更加灵活和可配置的功能。例如，可以通过命令行参数指定程序要处理的文件名、程序要使用的配置文件、程序要输出的日志级别等等。程序可以根据不同的命令行参数采取不同的行为，从而实现更加灵活和可配置的功能。<br />C语言中的`getopt`函数可以帮助程序解析命令行参数。`getopt`函数通常与`argc`和`argv`参数一起使用，可以从命令行中提取选项和参数，并根据需要执行相应的操作。以下是`getopt`函数的一般用法：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[])\n{\n    int opt;\n    while ((opt = getopt(argc, argv, \"abc:d\")) != -1) {\n        switch (opt) {\n            case 'a':\n                printf(\"Option -a\\n\");\n                break;\n            case 'b':\n                printf(\"Option -b\\n\");\n                break;\n            case 'c':\n                printf(\"Option -c with value '%s'\\n\", optarg);\n                break;\n            case 'd':\n                printf(\"Option -d\\n\");\n                break;\n            case '?':\n                printf(\"Unknown option: %c\\n\", optopt);\n                break;\n        }\n    }\n    return 0;\n}\n\n```\n在上面的例子中，`getopt`函数的第一个参数是`argc`，第二个参数是`argv`，第三个参数是一个字符串，它包含可接受的选项和参数信息。在这个字符串中，每个字符表示一个选项，如果这个选项需要接受一个参数，则在后面加上一个冒号。例如，`\"abc:d\"`表示可接受的选项有`-a`、`-b`、`-c`和`-d`，其中`-c`选项需要接受一个参数。<br />`getopt`函数会循环遍历命令行中的所有选项，每次返回一个选项和其参数（如果有）。在循环中，使用`switch`语句根据选项进行相应的操作。如果`getopt`函数发现了一个未知的选项，它会返回`?`,并将这个选项保存在`optopt`变量中。<br />以下是一些示例命令行及其对应的输出：\n```bash\n$ ./a.out -a -b -c filename -d\nOption -a\nOption -b\nOption -c with value 'filename'\nOption -d\n```\n```bash\n$ ./a.out -a -b -c\nOption -a\nOption -b\nUnknown option: c\n```\n在使用`getopt`函数时，需要注意以下几点：\n\n1. 在循环中，`optarg`变量保存当前选项的参数（如果有），可以通过这个变量获取参数的值。变量类型为字符串，可通过`atoi`函数转化为整型。\n2. 如果一个选项需要接受一个参数，但是没有给出参数，或者参数不合法，`getopt`函数会返回`?`，并将这个选项保存在`optopt`变量\n3. 如果一个选项在可接受的选项字符串中没有指定，`getopt`函数会返回`-1`，并结束循环\n\n`getopt`函数的第三个参数是一个字符串，用于指定程序支持的命令行选项和参数。<br />虽然`getopt`函数可以遍历所有命令行参数，但是在不指定可接受选项字符串的情况下，`getopt`函数不知道哪些参数是选项，哪些是参数，也不知道选项是否需要参数。指定<br />可接受选项字符串可以告诉`getopt`函数哪些选项是合法的，以及它们是否需要参数，从而使`getopt`函数能够正确地解析命令行参数。接受选项字符串的格式为一个字符串，由选项和参数组成，每个选项用一个字符表示，如果选项需要参数，则在选项字符后面跟一个冒号。例如，字符串`\"ab:c\"`表示程序支持三个选项`-a`、`-b`和`-c`, 其中`-c`选项需要一个参数。\n<a name=\"kBmQw\"></a>\n## 3. fscanf的用法\n`fscanf`是C语言标准库中的一个函数，它可以从一个文件中读取格式化数据，并将读取的结果存储到指定的变量中，该函数返回成功填充参数列表的项目数。`fscanf`函数的基本格式如下：\n```c\nint fscanf(FILE *stream, const char *format, ...);\n```\n其中，第一个参数`stream`是指向要读取数据的文件的指针；第二个参数`format`是一个字符串，用于指定读取数据的格式；第三个及之后的参数是要读取数据的变量名。<br />例如，如果你有一个文件`data.txt`，里面包含了三个整数，每个整数之间用空格分隔，你可以使用下面的代码将这些整数读取到三个变量`a`、`b`、`c`中\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp = fopen(\"data.txt\", \"r\");\n    int a, b, c;\n    fscanf(fp, \"%d %d %d\", &a, &b, &c);\n    printf(\"a = %d, b = %d, c = %d\\n\", a, b, c);\n    fclose(fp);\n    return 0;\n}\n```\n在上面的例子中，`fscanf`函数的第一个参数是文件指针`fp`，第二个参数是格式化字符串`\"%d %d %d\"`，它表示要读取三个整数，每个整数之间用空格分隔。第三个、第四个和第五个参数分别是三个整数变量`a`、`b`、`c`的地址，`fscanf`函数将读取到的整数存储到这些变量中。最后，我们打印出这些变量的值，以检查是否正确读取了文件中的数据。\n<a name=\"dKoHs\"></a>\n## 4. 编写程序\n这个实验不是真的让你去实现一个cache，而是让你编写一个能对访问记录进行应答的程序，这也是为什么writeup里强调所有的内存访问操作所需的块都不会超过行的容量<br />![yuque_diagram.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1678952903754-2052873c-6eb8-47c2-84e6-48ae84c0df8f.png)\n\n1. cache结构声明\n\ncache本质上是一个2D array，因此我们在结构体中声明一个指向二维数组的指针\n```cpp\ntypedef struct cache_line\n{\n\tint valid_bit;\n\tint tag;\n    int time_stamp;\n}cache_line;\n\ntypedef struct cache\n{\n\tint S;\n\tint E;\n\tint B;\n\tcache_line** Cache; \n}cache;\n```\n\n2. main\n\n主要在于正确解析命令行参数，会用`getopt`就行\n```cpp\nint main(int argc, char* argv[])\n{ \t\n    int\thit_count = 0, miss_count = 0, eviction_count = 0;\n    int s, E, b,opt;\n    char* trace_name = (char*)malloc(sizeof(char)*30);\n    cache* my_cache;\n    while((opt = getopt(argc, argv, \"s:E:b:t:\"))!= -1){\n\t\tswitch(opt){\n\t\tcase 's':\n\t\t   s = atoi(optarg);\n\t\t   break;\n\t\tcase 'E':\n\t\t   E = atoi(optarg);\n\t\t   break;\n\t\tcase 'b':\n\t\t   b = atoi(optarg);\n\t\t   break;\n\t\tcase 't':\n\t\t   strcpy(trace_name,optarg);\n\t\t   break;\n\t\tcase '?':\n\t\t   printf(\"unknown option: %c\\n\",optopt);\n\t\t   break;\n\t\t   }\n     }\n     my_cache = construct_cache(s,E,b);\n     access_cache(my_cache, s, b, trace_name, &hit_count, &miss_count, &eviction_count);\n     free_cache(my_cache);\n     printSummary(hit_count, miss_count, eviction_count);\n     return 0;\n }\n```\n\n3. construct_cache\n\n根据输入的命令行参数`s`,`E`,`b`构造cache，并初始化每一个高速缓存行\n```cpp\n cache* construct_cache(int s, int E, int b)\n {\n     cache* my_cache =(cache*) malloc(sizeof(cache));  // construct Cache\n\t my_cache->S = 1 << s;\n\t my_cache->B = 1 << b;\n\t my_cache->E = E;\n\t my_cache->Cache = (cache_line**)malloc(my_cache->S * sizeof(cache_line*) );\n\t for(int i=0; i<my_cache->S;++i)\n\t {\n\t\tmy_cache->Cache[i] = (cache_line*)malloc(my_cache->E * sizeof(cache_line));\n\t\tfor(int j=0; j<my_cache->E; ++j) // initialize\n\t\t{\n\t\t\tmy_cache->Cache[i][j].valid_bit = 0;\n\t\t\tmy_cache->Cache[i][j].tag = -1;\n\t\t\tmy_cache->Cache[i][j].time_stamp = 0;\n\t\t}\n\n\t}\n\treturn my_cache;\n }\n```\n\n4. update_LRU\n\n我是通过对每个高速缓冲行维护一个time_stamp实现的LRU，因此更新Cache中各行的LRU操作很重要。对访问的行，time_stamp置0，有效位和tag位也要做更新，其余行的time_stamp加1\n```cpp\nvoid update_LRU(cache* my_cache, int ad_set, int ad_tag, int line_index)\n{\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t\tif(my_cache->Cache[ad_set][i].valid_bit) ++(my_cache->Cache[ad_set][i].time_stamp);\n\n\tmy_cache->Cache[ad_set][line_index].time_stamp = 0;\n\tmy_cache->Cache[ad_set][line_index].valid_bit = 1;\n\tmy_cache->Cache[ad_set][line_index].tag = ad_tag;\n}\n```\n\n5. get_line_index\n\n每次访问cache，要得知hit，miss，eviction等信息，通过该函数实现：查找cache中所有行，如果找到有效位为1且tag位符合的行，则命中，否则miss\n```cpp\nint get_line_index(cache* my_cache, int ad_set, int ad_tag)\n{\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t{\n\t\tif(my_cache->Cache[ad_set][i].valid_bit && my_cache->Cache[ad_set][i].tag == ad_tag)\n\t\t\treturn i;  // hit\n\t}\n\treturn -1; // miss\n}\n```\n\n6. is_not_full\n\n。进一步对miss，遍历cache所有行，如果找不到有效位为0的行，则说明cache is full，那么就额外涉及有eviction操作\n```cpp\nint is_not_full(cache* my_cache, int ad_set)\n{\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t\tif(!my_cache->Cache[ad_set][i].valid_bit) return i;\n\n\treturn -1;\n}\n```\n\n7. find_LRU\n\n对eviction操作，执行我们的LRU替换策略，先找到时间戳最大的行，再进行覆盖操作\n```cpp\nint find_LRU(cache* my_cache, int ad_set)\n{\n\tint max_stamp = 0;\n\tint evict_line = 0;\n\tint temp = 0;\n\tfor (int i = 0; i < my_cache->E; ++i)\n\t{\n\t\ttemp = my_cache->Cache[ad_set][i].time_stamp;\n\t\tif(temp > max_stamp)\n\t\t\t{\n\t\t\t\tmax_stamp = temp;\n\t\t\t\tevict_line = i;\n\t\t\t}\n\t}\n\treturn evict_line;\n}\n```\n\n8. access_cache\n\n我们需要用`fscanf`对数据访问操作进行解析，注意此处的`\" %c %x,%d\"`,`%c`前有一个whitespace，目的在于忽略对指令访问操作。由于不同数据访问指令执行的cache操作次数不同，因此我将对cache进行操作的部分分割成一个独立的函数`real_access_cache`。M等于L+S，因此需要两次更新。\n```cpp\nvoid access_cache(cache* my_cache, int s, int b, char* trace_name, int* hit_count_ptr, int* miss_count_ptr, int* eviction_count_ptr)\n {\n \t FILE* pFile;   // receive access\n     pFile = fopen(trace_name,\"r\");\n     if(!pFile) exit(-1);\n     char identifier;\n     unsigned address;\n     int size;\n     while(fscanf(pFile,\" %c %x,%d\",&identifier,&address,&size)>0)\n     {     \n\t\tint mask =(unsigned)(-1)>>(64-s);\n\t\tint ad_set = (address >> b) & mask;\n\t\tint ad_tag = address >> (s+b);\n\t\tswitch(identifier)\n\t\t{\n\t\tcase 'M':\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\treal_access_cache(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(pFile);\n }\n\n void real_access_cache(cache* my_cache, int ad_set, int ad_tag, int* hit_count_ptr, int* miss_count_ptr, int* eviction_count_ptr)\n {\n    int line_index,free_line, evict_line;\n\tline_index = get_line_index(my_cache, ad_set, ad_tag);\n\tif(line_index != -1)\n\t{\n\t\t++(*hit_count_ptr);\n\t\tupdate_LRU(my_cache, ad_set, ad_tag, line_index);\n\t}\n\n\telse \n\t{\n\t\tfree_line = is_not_full(my_cache, ad_set);\n\t\tif(free_line != -1)\n\t\t{\n\t\t\t++(*miss_count_ptr);\n\t\t\tupdate_LRU(my_cache, ad_set, ad_tag, free_line);\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\t++(*miss_count_ptr);\n\t\t\t++(*eviction_count_ptr);\n\t\t\tevict_line = find_LRU(my_cache,ad_set);\n\t\t\tupdate_LRU(my_cache, ad_set, ad_tag, evict_line);\n\t\t}\n\t\t\n\t}\t\n}\n```\n<a name=\"XOedv\"></a>\n## 5. 结果\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1678885115012-43a6dad1-7672-42f8-b302-42c04af83585.png)\n\n","slug":"cache","published":1,"updated":"2023-03-28T00:59:55.991Z","_id":"clfqu81go0000vymo267cfg4d","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n<a name=\"HHpvX\"></a>\n<h1 id=\"lab4-cachelab\"><a class=\"markdownIt-Anchor\" href=\"#lab4-cachelab\"></a> lab4 cachelab</h1>\n<span id=\"more\"></span>\n<h2 id=\"1-要做什么\"><a class=\"markdownIt-Anchor\" href=\"#1-要做什么\"></a> 1. 要做什么</h2>\n<ol>\n<li>组索引位数 -s  （<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding=\"application/x-tex\">S = 2^s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span></span></span></span></span></span></span></span>为高速缓存组的组数）</li>\n<li>高速缓存行数 -E</li>\n<li>块偏移位数 -b （<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding=\"application/x-tex\">B = 2^b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span></span></span></span>为高速缓存块的大小）</li>\n</ol>\n<p>根据内存访问记录，输出每条访问的结果（hit/miss/evict)，输出操作通过调用<code>printSummary(hit_count, miss_count, eviction_count)</code>函数完成，输出结果应当与作者提供给我们的<code>reference cache simulator</code>相同，运行<code>make</code>+<code>./test-csim</code>获取评分<br>\n<a name=\"i3aH1\"></a></p>\n<h2 id=\"2-getopt函数的用法\"><a class=\"markdownIt-Anchor\" href=\"#2-getopt函数的用法\"></a> 2. getopt函数的用法</h2>\n<p>由于三个参数通过命令行输入，因此我们需要通过C语言库中的<code>getopt</code>函数，结合switch语句从命令行中获取参数值 <br>C语言中的<code>main</code>函数是程序的入口函数，它包含两个参数：<code>argc</code>和<code>argv</code>。它们的作用如下：</p>\n<ol>\n<li>argc参数</li>\n</ol>\n<p>argc参数表示程序运行时命令行参数的个数（argument count），包括程序名本身。因此，argc的值至少为1，即第一个参数是程序名本身。如果程序没有接受任何命令行参数，则argc的值为1。</p>\n<ol start=\"2\">\n<li>argv参数</li>\n</ol>\n<p>argv参数是一个字符串指针数组（argument vector），每个元素指向一个命令行参数。其中，argv[0]指向程序名本身，argv[1]、argv[2]等等依次指向后续的命令行参数。<br>通过argc和argv参数，程序可以接收命令行传递的参数，从而实现更加灵活和可配置的功能。例如，可以通过命令行参数指定程序要处理的文件名、程序要使用的配置文件、程序要输出的日志级别等等。程序可以根据不同的命令行参数采取不同的行为，从而实现更加灵活和可配置的功能。<br>C语言中的<code>getopt</code>函数可以帮助程序解析命令行参数。<code>getopt</code>函数通常与<code>argc</code>和<code>argv</code>参数一起使用，可以从命令行中提取选项和参数，并根据需要执行相应的操作。以下是<code>getopt</code>函数的一般用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> opt;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((opt = getopt(argc, argv, <span class=\"string\">&quot;abc:d&quot;</span>)) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (opt) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -a\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -b\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -c with value &#x27;%s&#x27;\\n&quot;</span>, optarg);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -d\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;?&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Unknown option: %c\\n&quot;</span>, optopt);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，<code>getopt</code>函数的第一个参数是<code>argc</code>，第二个参数是<code>argv</code>，第三个参数是一个字符串，它包含可接受的选项和参数信息。在这个字符串中，每个字符表示一个选项，如果这个选项需要接受一个参数，则在后面加上一个冒号。例如，<code>&quot;abc:d&quot;</code>表示可接受的选项有<code>-a</code>、<code>-b</code>、<code>-c</code>和<code>-d</code>，其中<code>-c</code>选项需要接受一个参数。<br><code>getopt</code>函数会循环遍历命令行中的所有选项，每次返回一个选项和其参数（如果有）。在循环中，使用<code>switch</code>语句根据选项进行相应的操作。如果<code>getopt</code>函数发现了一个未知的选项，它会返回<code>?</code>,并将这个选项保存在<code>optopt</code>变量中。<br>以下是一些示例命令行及其对应的输出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.out -a -b -c filename -d</span><br><span class=\"line\">Option -a</span><br><span class=\"line\">Option -b</span><br><span class=\"line\">Option -c with value <span class=\"string\">&#x27;filename&#x27;</span></span><br><span class=\"line\">Option -d</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.out -a -b -c</span><br><span class=\"line\">Option -a</span><br><span class=\"line\">Option -b</span><br><span class=\"line\">Unknown option: c</span><br></pre></td></tr></table></figure>\n<p>在使用<code>getopt</code>函数时，需要注意以下几点：</p>\n<ol>\n<li>在循环中，<code>optarg</code>变量保存当前选项的参数（如果有），可以通过这个变量获取参数的值。变量类型为字符串，可通过<code>atoi</code>函数转化为整型。</li>\n<li>如果一个选项需要接受一个参数，但是没有给出参数，或者参数不合法，<code>getopt</code>函数会返回<code>?</code>，并将这个选项保存在<code>optopt</code>变量</li>\n<li>如果一个选项在可接受的选项字符串中没有指定，<code>getopt</code>函数会返回<code>-1</code>，并结束循环</li>\n</ol>\n<p><code>getopt</code>函数的第三个参数是一个字符串，用于指定程序支持的命令行选项和参数。<br>虽然<code>getopt</code>函数可以遍历所有命令行参数，但是在不指定可接受选项字符串的情况下，<code>getopt</code>函数不知道哪些参数是选项，哪些是参数，也不知道选项是否需要参数。指定<br>可接受选项字符串可以告诉<code>getopt</code>函数哪些选项是合法的，以及它们是否需要参数，从而使<code>getopt</code>函数能够正确地解析命令行参数。接受选项字符串的格式为一个字符串，由选项和参数组成，每个选项用一个字符表示，如果选项需要参数，则在选项字符后面跟一个冒号。例如，字符串<code>&quot;ab:c&quot;</code>表示程序支持三个选项<code>-a</code>、<code>-b</code>和<code>-c</code>, 其中<code>-c</code>选项需要一个参数。<br>\n<a name=\"kBmQw\"></a></p>\n<h2 id=\"3-fscanf的用法\"><a class=\"markdownIt-Anchor\" href=\"#3-fscanf的用法\"></a> 3. fscanf的用法</h2>\n<p><code>fscanf</code>是C语言标准库中的一个函数，它可以从一个文件中读取格式化数据，并将读取的结果存储到指定的变量中，该函数返回成功填充参数列表的项目数。<code>fscanf</code>函数的基本格式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fscanf</span><span class=\"params\">(FILE *stream, <span class=\"type\">const</span> <span class=\"type\">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>\n<p>其中，第一个参数<code>stream</code>是指向要读取数据的文件的指针；第二个参数<code>format</code>是一个字符串，用于指定读取数据的格式；第三个及之后的参数是要读取数据的变量名。<br>例如，如果你有一个文件<code>data.txt</code>，里面包含了三个整数，每个整数之间用空格分隔，你可以使用下面的代码将这些整数读取到三个变量<code>a</code>、<code>b</code>、<code>c</code>中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    FILE *fp = fopen(<span class=\"string\">&quot;data.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> a, b, c;</span><br><span class=\"line\">    <span class=\"built_in\">fscanf</span>(fp, <span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a = %d, b = %d, c = %d\\n&quot;</span>, a, b, c);</span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，<code>fscanf</code>函数的第一个参数是文件指针<code>fp</code>，第二个参数是格式化字符串<code>&quot;%d %d %d&quot;</code>，它表示要读取三个整数，每个整数之间用空格分隔。第三个、第四个和第五个参数分别是三个整数变量<code>a</code>、<code>b</code>、<code>c</code>的地址，<code>fscanf</code>函数将读取到的整数存储到这些变量中。最后，我们打印出这些变量的值，以检查是否正确读取了文件中的数据。<br>\n<a name=\"dKoHs\"></a></p>\n<h2 id=\"4-编写程序\"><a class=\"markdownIt-Anchor\" href=\"#4-编写程序\"></a> 4. 编写程序</h2>\n<p>这个实验不是真的让你去实现一个cache，而是让你编写一个能对访问记录进行应答的程序，这也是为什么writeup里强调所有的内存访问操作所需的块都不会超过行的容量<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1678952903754-2052873c-6eb8-47c2-84e6-48ae84c0df8f.png\" alt=\"yuque_diagram.png\"></p>\n<ol>\n<li>cache结构声明</li>\n</ol>\n<p>cache本质上是一个2D array，因此我们在结构体中声明一个指向二维数组的指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cache_line</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> valid_bit;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tag;</span><br><span class=\"line\">    <span class=\"type\">int</span> time_stamp;</span><br><span class=\"line\">&#125;cache_line;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> S;</span><br><span class=\"line\">\t<span class=\"type\">int</span> E;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B;</span><br><span class=\"line\">\tcache_line** Cache; </span><br><span class=\"line\">&#125;cache;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>main</li>\n</ol>\n<p>主要在于正确解析命令行参数，会用<code>getopt</code>就行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; \t</span><br><span class=\"line\">    <span class=\"type\">int</span>\thit_count = <span class=\"number\">0</span>, miss_count = <span class=\"number\">0</span>, eviction_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> s, E, b,opt;</span><br><span class=\"line\">    <span class=\"type\">char</span>* trace_name = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(<span class=\"type\">char</span>)*<span class=\"number\">30</span>);</span><br><span class=\"line\">    cache* my_cache;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((opt = <span class=\"built_in\">getopt</span>(argc, argv, <span class=\"string\">&quot;s:E:b:t:&quot;</span>))!= <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(opt)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;s&#x27;</span>:</span><br><span class=\"line\">\t\t   s = <span class=\"built_in\">atoi</span>(optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;E&#x27;</span>:</span><br><span class=\"line\">\t\t   E = <span class=\"built_in\">atoi</span>(optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">\t\t   b = <span class=\"built_in\">atoi</span>(optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;t&#x27;</span>:</span><br><span class=\"line\">\t\t   <span class=\"built_in\">strcpy</span>(trace_name,optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;?&#x27;</span>:</span><br><span class=\"line\">\t\t   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;unknown option: %c\\n&quot;</span>,optopt);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     my_cache = <span class=\"built_in\">construct_cache</span>(s,E,b);</span><br><span class=\"line\">     <span class=\"built_in\">access_cache</span>(my_cache, s, b, trace_name, &amp;hit_count, &amp;miss_count, &amp;eviction_count);</span><br><span class=\"line\">     <span class=\"built_in\">free_cache</span>(my_cache);</span><br><span class=\"line\">     <span class=\"built_in\">printSummary</span>(hit_count, miss_count, eviction_count);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>construct_cache</li>\n</ol>\n<p>根据输入的命令行参数<code>s</code>,<code>E</code>,<code>b</code>构造cache，并初始化每一个高速缓存行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">cache* <span class=\"title\">construct_cache</span><span class=\"params\">(<span class=\"type\">int</span> s, <span class=\"type\">int</span> E, <span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cache* my_cache =(cache*) <span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(cache));  <span class=\"comment\">// construct Cache</span></span><br><span class=\"line\"> my_cache-&gt;S = <span class=\"number\">1</span> &lt;&lt; s;</span><br><span class=\"line\"> my_cache-&gt;B = <span class=\"number\">1</span> &lt;&lt; b;</span><br><span class=\"line\"> my_cache-&gt;E = E;</span><br><span class=\"line\"> my_cache-&gt;Cache = (cache_line**)<span class=\"built_in\">malloc</span>(my_cache-&gt;S * <span class=\"built_in\">sizeof</span>(cache_line*) );</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;my_cache-&gt;S;++i)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\tmy_cache-&gt;Cache[i] = (cache_line*)<span class=\"built_in\">malloc</span>(my_cache-&gt;E * <span class=\"built_in\">sizeof</span>(cache_line));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;my_cache-&gt;E; ++j) <span class=\"comment\">// initialize</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmy_cache-&gt;Cache[i][j].valid_bit = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tmy_cache-&gt;Cache[i][j].tag = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tmy_cache-&gt;Cache[i][j].time_stamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> my_cache;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>update_LRU</li>\n</ol>\n<p>我是通过对每个高速缓冲行维护一个time_stamp实现的LRU，因此更新Cache中各行的LRU操作很重要。对访问的行，time_stamp置0，有效位和tag位也要做更新，其余行的time_stamp加1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update_LRU</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set, <span class=\"type\">int</span> ad_tag, <span class=\"type\">int</span> line_index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(my_cache-&gt;Cache[ad_set][i].valid_bit) ++(my_cache-&gt;Cache[ad_set][i].time_stamp);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmy_cache-&gt;Cache[ad_set][line_index].time_stamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tmy_cache-&gt;Cache[ad_set][line_index].valid_bit = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tmy_cache-&gt;Cache[ad_set][line_index].tag = ad_tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>get_line_index</li>\n</ol>\n<p>每次访问cache，要得知hit，miss，eviction等信息，通过该函数实现：查找cache中所有行，如果找到有效位为1且tag位符合的行，则命中，否则miss</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_line_index</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set, <span class=\"type\">int</span> ad_tag)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(my_cache-&gt;Cache[ad_set][i].valid_bit &amp;&amp; my_cache-&gt;Cache[ad_set][i].tag == ad_tag)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;  <span class=\"comment\">// hit</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// miss</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>is_not_full</li>\n</ol>\n<p>。进一步对miss，遍历cache所有行，如果找不到有效位为0的行，则说明cache is full，那么就额外涉及有eviction操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">is_not_full</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!my_cache-&gt;Cache[ad_set][i].valid_bit) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>find_LRU</li>\n</ol>\n<p>对eviction操作，执行我们的LRU替换策略，先找到时间戳最大的行，再进行覆盖操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find_LRU</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> max_stamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> evict_line = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttemp = my_cache-&gt;Cache[ad_set][i].time_stamp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(temp &gt; max_stamp)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmax_stamp = temp;</span><br><span class=\"line\">\t\t\t\tevict_line = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> evict_line;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>access_cache</li>\n</ol>\n<p>我们需要用<code>fscanf</code>对数据访问操作进行解析，注意此处的<code>&quot; %c %x,%d&quot;</code>,<code>%c</code>前有一个whitespace，目的在于忽略对指令访问操作。由于不同数据访问指令执行的cache操作次数不同，因此我将对cache进行操作的部分分割成一个独立的函数<code>real_access_cache</code>。M等于L+S，因此需要两次更新。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">access_cache</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> s, <span class=\"type\">int</span> b, <span class=\"type\">char</span>* trace_name, <span class=\"type\">int</span>* hit_count_ptr, <span class=\"type\">int</span>* miss_count_ptr, <span class=\"type\">int</span>* eviction_count_ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\"> \t FILE* pFile;   <span class=\"comment\">// receive access</span></span><br><span class=\"line\">     pFile = <span class=\"built_in\">fopen</span>(trace_name,<span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(!pFile) <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">     <span class=\"type\">char</span> identifier;</span><br><span class=\"line\">     <span class=\"type\">unsigned</span> address;</span><br><span class=\"line\">     <span class=\"type\">int</span> size;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(<span class=\"built_in\">fscanf</span>(pFile,<span class=\"string\">&quot; %c %x,%d&quot;</span>,&amp;identifier,&amp;address,&amp;size)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">     &#123;     </span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mask =(<span class=\"type\">unsigned</span>)(<span class=\"number\">-1</span>)&gt;&gt;(<span class=\"number\">64</span>-s);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ad_set = (address &gt;&gt; b) &amp; mask;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ad_tag = address &gt;&gt; (s+b);</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(identifier)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;M&#x27;</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;S&#x27;</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">fclose</span>(pFile);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">real_access_cache</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set, <span class=\"type\">int</span> ad_tag, <span class=\"type\">int</span>* hit_count_ptr, <span class=\"type\">int</span>* miss_count_ptr, <span class=\"type\">int</span>* eviction_count_ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> line_index,free_line, evict_line;</span><br><span class=\"line\">\tline_index = <span class=\"built_in\">get_line_index</span>(my_cache, ad_set, ad_tag);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(line_index != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t++(*hit_count_ptr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update_LRU</span>(my_cache, ad_set, ad_tag, line_index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfree_line = <span class=\"built_in\">is_not_full</span>(my_cache, ad_set);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(free_line != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t++(*miss_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">update_LRU</span>(my_cache, ad_set, ad_tag, free_line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t++(*miss_count_ptr);</span><br><span class=\"line\">\t\t\t++(*eviction_count_ptr);</span><br><span class=\"line\">\t\t\tevict_line = <span class=\"built_in\">find_LRU</span>(my_cache,ad_set);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">update_LRU</span>(my_cache, ad_set, ad_tag, evict_line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"XOedv\"></a></p>\n<h2 id=\"5-结果\"><a class=\"markdownIt-Anchor\" href=\"#5-结果\"></a> 5. 结果</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1678885115012-43a6dad1-7672-42f8-b302-42c04af83585.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n<a name=\"HHpvX\"></a>\n<h1 id=\"lab4-cachelab\"><a class=\"markdownIt-Anchor\" href=\"#lab4-cachelab\"></a> lab4 cachelab</h1>","more":"<h2 id=\"1-要做什么\"><a class=\"markdownIt-Anchor\" href=\"#1-要做什么\"></a> 1. 要做什么</h2>\n<ol>\n<li>组索引位数 -s  （<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding=\"application/x-tex\">S = 2^s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span></span></span></span></span></span></span></span>为高速缓存组的组数）</li>\n<li>高速缓存行数 -E</li>\n<li>块偏移位数 -b （<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding=\"application/x-tex\">B = 2^b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span></span></span></span>为高速缓存块的大小）</li>\n</ol>\n<p>根据内存访问记录，输出每条访问的结果（hit/miss/evict)，输出操作通过调用<code>printSummary(hit_count, miss_count, eviction_count)</code>函数完成，输出结果应当与作者提供给我们的<code>reference cache simulator</code>相同，运行<code>make</code>+<code>./test-csim</code>获取评分<br>\n<a name=\"i3aH1\"></a></p>\n<h2 id=\"2-getopt函数的用法\"><a class=\"markdownIt-Anchor\" href=\"#2-getopt函数的用法\"></a> 2. getopt函数的用法</h2>\n<p>由于三个参数通过命令行输入，因此我们需要通过C语言库中的<code>getopt</code>函数，结合switch语句从命令行中获取参数值 <br>C语言中的<code>main</code>函数是程序的入口函数，它包含两个参数：<code>argc</code>和<code>argv</code>。它们的作用如下：</p>\n<ol>\n<li>argc参数</li>\n</ol>\n<p>argc参数表示程序运行时命令行参数的个数（argument count），包括程序名本身。因此，argc的值至少为1，即第一个参数是程序名本身。如果程序没有接受任何命令行参数，则argc的值为1。</p>\n<ol start=\"2\">\n<li>argv参数</li>\n</ol>\n<p>argv参数是一个字符串指针数组（argument vector），每个元素指向一个命令行参数。其中，argv[0]指向程序名本身，argv[1]、argv[2]等等依次指向后续的命令行参数。<br>通过argc和argv参数，程序可以接收命令行传递的参数，从而实现更加灵活和可配置的功能。例如，可以通过命令行参数指定程序要处理的文件名、程序要使用的配置文件、程序要输出的日志级别等等。程序可以根据不同的命令行参数采取不同的行为，从而实现更加灵活和可配置的功能。<br>C语言中的<code>getopt</code>函数可以帮助程序解析命令行参数。<code>getopt</code>函数通常与<code>argc</code>和<code>argv</code>参数一起使用，可以从命令行中提取选项和参数，并根据需要执行相应的操作。以下是<code>getopt</code>函数的一般用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> opt;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((opt = getopt(argc, argv, <span class=\"string\">&quot;abc:d&quot;</span>)) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (opt) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -a\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -b\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -c with value &#x27;%s&#x27;\\n&quot;</span>, optarg);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Option -d\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;?&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Unknown option: %c\\n&quot;</span>, optopt);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，<code>getopt</code>函数的第一个参数是<code>argc</code>，第二个参数是<code>argv</code>，第三个参数是一个字符串，它包含可接受的选项和参数信息。在这个字符串中，每个字符表示一个选项，如果这个选项需要接受一个参数，则在后面加上一个冒号。例如，<code>&quot;abc:d&quot;</code>表示可接受的选项有<code>-a</code>、<code>-b</code>、<code>-c</code>和<code>-d</code>，其中<code>-c</code>选项需要接受一个参数。<br><code>getopt</code>函数会循环遍历命令行中的所有选项，每次返回一个选项和其参数（如果有）。在循环中，使用<code>switch</code>语句根据选项进行相应的操作。如果<code>getopt</code>函数发现了一个未知的选项，它会返回<code>?</code>,并将这个选项保存在<code>optopt</code>变量中。<br>以下是一些示例命令行及其对应的输出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.out -a -b -c filename -d</span><br><span class=\"line\">Option -a</span><br><span class=\"line\">Option -b</span><br><span class=\"line\">Option -c with value <span class=\"string\">&#x27;filename&#x27;</span></span><br><span class=\"line\">Option -d</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.out -a -b -c</span><br><span class=\"line\">Option -a</span><br><span class=\"line\">Option -b</span><br><span class=\"line\">Unknown option: c</span><br></pre></td></tr></table></figure>\n<p>在使用<code>getopt</code>函数时，需要注意以下几点：</p>\n<ol>\n<li>在循环中，<code>optarg</code>变量保存当前选项的参数（如果有），可以通过这个变量获取参数的值。变量类型为字符串，可通过<code>atoi</code>函数转化为整型。</li>\n<li>如果一个选项需要接受一个参数，但是没有给出参数，或者参数不合法，<code>getopt</code>函数会返回<code>?</code>，并将这个选项保存在<code>optopt</code>变量</li>\n<li>如果一个选项在可接受的选项字符串中没有指定，<code>getopt</code>函数会返回<code>-1</code>，并结束循环</li>\n</ol>\n<p><code>getopt</code>函数的第三个参数是一个字符串，用于指定程序支持的命令行选项和参数。<br>虽然<code>getopt</code>函数可以遍历所有命令行参数，但是在不指定可接受选项字符串的情况下，<code>getopt</code>函数不知道哪些参数是选项，哪些是参数，也不知道选项是否需要参数。指定<br>可接受选项字符串可以告诉<code>getopt</code>函数哪些选项是合法的，以及它们是否需要参数，从而使<code>getopt</code>函数能够正确地解析命令行参数。接受选项字符串的格式为一个字符串，由选项和参数组成，每个选项用一个字符表示，如果选项需要参数，则在选项字符后面跟一个冒号。例如，字符串<code>&quot;ab:c&quot;</code>表示程序支持三个选项<code>-a</code>、<code>-b</code>和<code>-c</code>, 其中<code>-c</code>选项需要一个参数。<br>\n<a name=\"kBmQw\"></a></p>\n<h2 id=\"3-fscanf的用法\"><a class=\"markdownIt-Anchor\" href=\"#3-fscanf的用法\"></a> 3. fscanf的用法</h2>\n<p><code>fscanf</code>是C语言标准库中的一个函数，它可以从一个文件中读取格式化数据，并将读取的结果存储到指定的变量中，该函数返回成功填充参数列表的项目数。<code>fscanf</code>函数的基本格式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fscanf</span><span class=\"params\">(FILE *stream, <span class=\"type\">const</span> <span class=\"type\">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>\n<p>其中，第一个参数<code>stream</code>是指向要读取数据的文件的指针；第二个参数<code>format</code>是一个字符串，用于指定读取数据的格式；第三个及之后的参数是要读取数据的变量名。<br>例如，如果你有一个文件<code>data.txt</code>，里面包含了三个整数，每个整数之间用空格分隔，你可以使用下面的代码将这些整数读取到三个变量<code>a</code>、<code>b</code>、<code>c</code>中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    FILE *fp = fopen(<span class=\"string\">&quot;data.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> a, b, c;</span><br><span class=\"line\">    <span class=\"built_in\">fscanf</span>(fp, <span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a = %d, b = %d, c = %d\\n&quot;</span>, a, b, c);</span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，<code>fscanf</code>函数的第一个参数是文件指针<code>fp</code>，第二个参数是格式化字符串<code>&quot;%d %d %d&quot;</code>，它表示要读取三个整数，每个整数之间用空格分隔。第三个、第四个和第五个参数分别是三个整数变量<code>a</code>、<code>b</code>、<code>c</code>的地址，<code>fscanf</code>函数将读取到的整数存储到这些变量中。最后，我们打印出这些变量的值，以检查是否正确读取了文件中的数据。<br>\n<a name=\"dKoHs\"></a></p>\n<h2 id=\"4-编写程序\"><a class=\"markdownIt-Anchor\" href=\"#4-编写程序\"></a> 4. 编写程序</h2>\n<p>这个实验不是真的让你去实现一个cache，而是让你编写一个能对访问记录进行应答的程序，这也是为什么writeup里强调所有的内存访问操作所需的块都不会超过行的容量<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1678952903754-2052873c-6eb8-47c2-84e6-48ae84c0df8f.png\" alt=\"yuque_diagram.png\"></p>\n<ol>\n<li>cache结构声明</li>\n</ol>\n<p>cache本质上是一个2D array，因此我们在结构体中声明一个指向二维数组的指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cache_line</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> valid_bit;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tag;</span><br><span class=\"line\">    <span class=\"type\">int</span> time_stamp;</span><br><span class=\"line\">&#125;cache_line;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> S;</span><br><span class=\"line\">\t<span class=\"type\">int</span> E;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B;</span><br><span class=\"line\">\tcache_line** Cache; </span><br><span class=\"line\">&#125;cache;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>main</li>\n</ol>\n<p>主要在于正确解析命令行参数，会用<code>getopt</code>就行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; \t</span><br><span class=\"line\">    <span class=\"type\">int</span>\thit_count = <span class=\"number\">0</span>, miss_count = <span class=\"number\">0</span>, eviction_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> s, E, b,opt;</span><br><span class=\"line\">    <span class=\"type\">char</span>* trace_name = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(<span class=\"type\">char</span>)*<span class=\"number\">30</span>);</span><br><span class=\"line\">    cache* my_cache;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((opt = <span class=\"built_in\">getopt</span>(argc, argv, <span class=\"string\">&quot;s:E:b:t:&quot;</span>))!= <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(opt)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;s&#x27;</span>:</span><br><span class=\"line\">\t\t   s = <span class=\"built_in\">atoi</span>(optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;E&#x27;</span>:</span><br><span class=\"line\">\t\t   E = <span class=\"built_in\">atoi</span>(optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">\t\t   b = <span class=\"built_in\">atoi</span>(optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;t&#x27;</span>:</span><br><span class=\"line\">\t\t   <span class=\"built_in\">strcpy</span>(trace_name,optarg);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;?&#x27;</span>:</span><br><span class=\"line\">\t\t   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;unknown option: %c\\n&quot;</span>,optopt);</span><br><span class=\"line\">\t\t   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     my_cache = <span class=\"built_in\">construct_cache</span>(s,E,b);</span><br><span class=\"line\">     <span class=\"built_in\">access_cache</span>(my_cache, s, b, trace_name, &amp;hit_count, &amp;miss_count, &amp;eviction_count);</span><br><span class=\"line\">     <span class=\"built_in\">free_cache</span>(my_cache);</span><br><span class=\"line\">     <span class=\"built_in\">printSummary</span>(hit_count, miss_count, eviction_count);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>construct_cache</li>\n</ol>\n<p>根据输入的命令行参数<code>s</code>,<code>E</code>,<code>b</code>构造cache，并初始化每一个高速缓存行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">cache* <span class=\"title\">construct_cache</span><span class=\"params\">(<span class=\"type\">int</span> s, <span class=\"type\">int</span> E, <span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cache* my_cache =(cache*) <span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(cache));  <span class=\"comment\">// construct Cache</span></span><br><span class=\"line\"> my_cache-&gt;S = <span class=\"number\">1</span> &lt;&lt; s;</span><br><span class=\"line\"> my_cache-&gt;B = <span class=\"number\">1</span> &lt;&lt; b;</span><br><span class=\"line\"> my_cache-&gt;E = E;</span><br><span class=\"line\"> my_cache-&gt;Cache = (cache_line**)<span class=\"built_in\">malloc</span>(my_cache-&gt;S * <span class=\"built_in\">sizeof</span>(cache_line*) );</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;my_cache-&gt;S;++i)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\tmy_cache-&gt;Cache[i] = (cache_line*)<span class=\"built_in\">malloc</span>(my_cache-&gt;E * <span class=\"built_in\">sizeof</span>(cache_line));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;my_cache-&gt;E; ++j) <span class=\"comment\">// initialize</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmy_cache-&gt;Cache[i][j].valid_bit = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tmy_cache-&gt;Cache[i][j].tag = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tmy_cache-&gt;Cache[i][j].time_stamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> my_cache;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>update_LRU</li>\n</ol>\n<p>我是通过对每个高速缓冲行维护一个time_stamp实现的LRU，因此更新Cache中各行的LRU操作很重要。对访问的行，time_stamp置0，有效位和tag位也要做更新，其余行的time_stamp加1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update_LRU</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set, <span class=\"type\">int</span> ad_tag, <span class=\"type\">int</span> line_index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(my_cache-&gt;Cache[ad_set][i].valid_bit) ++(my_cache-&gt;Cache[ad_set][i].time_stamp);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmy_cache-&gt;Cache[ad_set][line_index].time_stamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tmy_cache-&gt;Cache[ad_set][line_index].valid_bit = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tmy_cache-&gt;Cache[ad_set][line_index].tag = ad_tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>get_line_index</li>\n</ol>\n<p>每次访问cache，要得知hit，miss，eviction等信息，通过该函数实现：查找cache中所有行，如果找到有效位为1且tag位符合的行，则命中，否则miss</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_line_index</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set, <span class=\"type\">int</span> ad_tag)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(my_cache-&gt;Cache[ad_set][i].valid_bit &amp;&amp; my_cache-&gt;Cache[ad_set][i].tag == ad_tag)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;  <span class=\"comment\">// hit</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// miss</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>is_not_full</li>\n</ol>\n<p>。进一步对miss，遍历cache所有行，如果找不到有效位为0的行，则说明cache is full，那么就额外涉及有eviction操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">is_not_full</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!my_cache-&gt;Cache[ad_set][i].valid_bit) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>find_LRU</li>\n</ol>\n<p>对eviction操作，执行我们的LRU替换策略，先找到时间戳最大的行，再进行覆盖操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find_LRU</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> max_stamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> evict_line = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttemp = my_cache-&gt;Cache[ad_set][i].time_stamp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(temp &gt; max_stamp)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmax_stamp = temp;</span><br><span class=\"line\">\t\t\t\tevict_line = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> evict_line;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>access_cache</li>\n</ol>\n<p>我们需要用<code>fscanf</code>对数据访问操作进行解析，注意此处的<code>&quot; %c %x,%d&quot;</code>,<code>%c</code>前有一个whitespace，目的在于忽略对指令访问操作。由于不同数据访问指令执行的cache操作次数不同，因此我将对cache进行操作的部分分割成一个独立的函数<code>real_access_cache</code>。M等于L+S，因此需要两次更新。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">access_cache</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> s, <span class=\"type\">int</span> b, <span class=\"type\">char</span>* trace_name, <span class=\"type\">int</span>* hit_count_ptr, <span class=\"type\">int</span>* miss_count_ptr, <span class=\"type\">int</span>* eviction_count_ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\"> \t FILE* pFile;   <span class=\"comment\">// receive access</span></span><br><span class=\"line\">     pFile = <span class=\"built_in\">fopen</span>(trace_name,<span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(!pFile) <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">     <span class=\"type\">char</span> identifier;</span><br><span class=\"line\">     <span class=\"type\">unsigned</span> address;</span><br><span class=\"line\">     <span class=\"type\">int</span> size;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(<span class=\"built_in\">fscanf</span>(pFile,<span class=\"string\">&quot; %c %x,%d&quot;</span>,&amp;identifier,&amp;address,&amp;size)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">     &#123;     </span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mask =(<span class=\"type\">unsigned</span>)(<span class=\"number\">-1</span>)&gt;&gt;(<span class=\"number\">64</span>-s);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ad_set = (address &gt;&gt; b) &amp; mask;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ad_tag = address &gt;&gt; (s+b);</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(identifier)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;M&#x27;</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;S&#x27;</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">fclose</span>(pFile);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">real_access_cache</span><span class=\"params\">(cache* my_cache, <span class=\"type\">int</span> ad_set, <span class=\"type\">int</span> ad_tag, <span class=\"type\">int</span>* hit_count_ptr, <span class=\"type\">int</span>* miss_count_ptr, <span class=\"type\">int</span>* eviction_count_ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> line_index,free_line, evict_line;</span><br><span class=\"line\">\tline_index = <span class=\"built_in\">get_line_index</span>(my_cache, ad_set, ad_tag);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(line_index != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t++(*hit_count_ptr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update_LRU</span>(my_cache, ad_set, ad_tag, line_index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfree_line = <span class=\"built_in\">is_not_full</span>(my_cache, ad_set);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(free_line != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t++(*miss_count_ptr);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">update_LRU</span>(my_cache, ad_set, ad_tag, free_line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t++(*miss_count_ptr);</span><br><span class=\"line\">\t\t\t++(*eviction_count_ptr);</span><br><span class=\"line\">\t\t\tevict_line = <span class=\"built_in\">find_LRU</span>(my_cache,ad_set);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">update_LRU</span>(my_cache, ad_set, ad_tag, evict_line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"XOedv\"></a></p>\n<h2 id=\"5-结果\"><a class=\"markdownIt-Anchor\" href=\"#5-结果\"></a> 5. 结果</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1678885115012-43a6dad1-7672-42f8-b302-42c04af83585.png\" alt=\"image.png\"></p>"},{"title":"《数据结构与算法C++》学习历程","date":"2022-10-25T04:00:00.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"qIfKY\"></a>\n\n# 前言\n\n以下记录了我2022年暑假开始学习数据结构的历程。从哈希表到图论，有着详细的思考过程。\n\n<!--more-->\n\n---\n\n<a name=\"Aq9ue\"></a>\n# Chapter 1 Lists,Stacks and Queues\n<a name=\"csZFb\"></a>\n### 1. 对自制vector容器添加错误检查能力\n> 访问vector容器，可能会出现的错误的迭代器操作主要有两种\n> 1. 错误的访存操作：迭代器未初始化，执行`*`操作\n> 2. 迭代器超出容器边界：迭代器在末尾执行`++iter/iter++`操作\n> \n另外，迭代器还会出现如`7`所述的失效的情况\n\n<a name=\"kxJtb\"></a>\n#### 1.处理错误操作：在重载运算符`*`和`++`时检查current的值\n```cpp\nObject operator *()\n{\n\tif (const_iterator::current == NULL)  // Check boundary\n    {\n        cout << \"Error: iterator is NULL!\" << endl;\n\t\tabort();\n\t}\n\treturn *(const_iterator::current);\n}\n\niterator& operator ++ ()\n{\n    if (const_iterator::current == objects[theSize-1]) // Error:Cannot access objects\n\t{\n\t\tcout << \"Error: iterator is end!\" << endl;\n\t    abort();\n\t}\n\tconst_iterator::current++;\n\treturn *this;\n}\n```\niterator类与const_iterator类作为vector模板类的嵌套类，访问外部类的私有成员`objects`与`theSize`是一件比较困难的事情 [StackOverFlow：Can inner classes access private variables?](https://stackoverflow.com/questions/486099/can-inner-classes-access-private-variables)\n> 嵌套类与外部类之间没有访问特权\n\n<a name=\"hHyA9\"></a>\n#### 2.处理失效的迭代器：给迭代器添加一个数据成员用于指向当前表，用一个函数用于判断迭代器是否指向正确的表。当发生扩容时，原有的theVector指向的空间被释放。（`theVector == NULL`感觉有点问题）\n```cpp\nclass const_iterator\n{\n    ...\nprotected:\n    Object* current;\n    const vector<Object>* theVector;\n    \n    void assertIsValid()const\n\t{\n\t\tif(current == NULL || theVector == NULL)\n            throw \"IteratorOutOfbounds\";\n    }\n    ...\n}\n```\n<a name=\"fgUkk\"></a>\n### 2. 搜寻链表的注意点\n在链表搜寻值为x的节点时，显然需要保存两个节点的信息：当前节点`current`和上一个节点`foreCurrent`,要注意对这两个值不同的初始化，搜寻的条件也不同。有以下两种模式：\n```cpp\ncurrent = head->next\nforeCurrent = head;\nwhile (current && current->data != x)\n{\n    foreCurrent = current;\n    current = current->next;\n}\n```\n```cpp\nNode* current = head; // Initially nullptr\nNode* foreCurrent = nullptr;\nwhile (current->next!= nullptr && current->data != x )\n{\n\tforeCurrent = current;\n\tcurrent = current->next;\n}\n```\n注意：混淆这两种模式将出现访存错误，如以下情况\n```cpp\nNode* current = head->next;\nNode* foreCurrent = head;\nwhile (current->next!= nullptr && current->data != x )\n{\n\tforeCurrent = current;\n\tcurrent = current->next;\n}\n```\n这样会出现的问题是：当链表中仅有一个头节点时，初始`current=head->next`值为`nullptr`，第3行的`current->next`将执行失败（实现iterator类后，尽可能的使用该类，该类不存在以上问题）\n<a name=\"hF7j1\"></a>\n### 3.平衡符号\n创建一个空栈后读取文件，当读取到开放字符`(,{,[,/*`时压入栈，当读取到封闭字符`),},],*/`时从栈顶弹出字符。\n> 1. 读取到封闭字符时，栈为空，则封闭字符不匹配，报错\n> 2. 弹出的字符与封闭字符不匹配，报错\n> 3. 读取到文件尾后，栈不为空，则开放字符不匹配，报错\n\n```cpp\nvoid balSymbol()\n{\n\tchar current, prev;\n\tstring left(\"{[(*\");\n\tstring right(\"}])\");\n\tifstream iFile(\"3_21Sample.txt\");\n\tstack<char> check;\n\tif (!iFile.is_open())\n\t\tabort();\n\tiFile >> current;\n\tprev = '\\0';\n\twhile (!iFile.eof())\n\t{ \n\t\t// push open symbol in stack\n\t\tif (left.find(current) != string::npos) \n\t\t{\n\t\t\tif(current !='*')\n\t\t\t\tcheck.push(current);\n\t\t\telse if (current == '*' && prev == '/') // push in '/*'\n\t\t\t{\n\t\t\t\tcheck.push(prev);\n\t\t\t}\n\t\t\t// no push action for current =='*' prev !='/'\n\t\t}\n\t\t// If it is a closed symbol and stack is not empty, the corresponding symbol will pop up\n\n\t\tif (current == '/' && prev == '*') // special for '/','/' can be left or right\n\t\t{ // for '*/',no action for current =='/' and stack is empty (/*....),\n\t\t\tif(check.empty())\n\t\t\t{\n\t\t\t\t//last mismatch closed symbol is a speical situation, which can not belong to error:eof()\n\t\t\t\tcout << \"closed symbol mismatch!\" << endl;\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\telse if(check.top() == '/')\n\t\t\t\tcheck.pop();\n\t\t}\n\t\telse if (right.find(current) != string::npos)   // for (]}\n\t\t{\n\t\t\tif (check.empty()) // prevent top() error\n\t\t\t{\n\t\t\t\t//last mismatch closed symbol is a speical situation, which can not belong to error:eof()\n\t\t\t\tcout << \"closed symbol mismatch!\" << endl;\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\telse if (current == '}' && check.top() == '{')\n\t\t\t\tcheck.pop();\n\t\t\telse if (current == ']' && check.top() == '[')\n\t\t\t\tcheck.pop();\n\t\t\telse if (current == ')' && check.top() == '(')\n\t\t\t\tcheck.pop();\n\t\t\telse\n\t\t\t\tbreak; // error: top stack symbol mismatch → eof() is false\n\t\t}\n\t\tprev = current;\n\t\tiFile >> current; // read next character in buffer\n\t}\n\t// judge\n\tif (!iFile.eof() )\n\t\tcout << \"closed symbol mismatch!\" << endl;\n\telse if (!check.empty())\n\t\tcout << \"open symbol mismatch!\" << endl;\n\telse\n\t\tcout << \"Successful!\" << endl;\n}\n```\n<a name=\"JdH6s\"></a>\n### 4. 中缀表达式转后缀表达式\n1.为什么在向栈中压入运算符时，要先弹出优先级更高的运算符\n> 运算符的出栈顺序代表了运算符的执行顺序。显然的，优先级更高的运算符最先打印并出栈，即在后缀表达式中代表最早参与运算\n\n2.为什么直到碰到右括号`)`之前，不弹出左括号`(`，遇到右括号`)`后,弹出栈元素直到遇到`(`\n> 该操作的意思是弹出括号内的所有运算符，显然的，括号内的各运算符优先级高于括号外的运算符\n\n```cpp\nvoid infixToPostFix()\n{\n\tifstream iFile(\"3_23Sample.txt\");\n\tif (!iFile.is_open())\n\t\tabort();\n\tstring operators = \"()+-/*\";\n\tstack<char>keepOptors;\n\tchar current;\n\tiFile >> current;\n\twhile (!iFile.eof())\n\t{\n\t\tif (operators.find(current) != string::npos)\n\t\t{\n\t\t\tif (keepOptors.empty()) // initial\n\t\t\t\tkeepOptors.push(current);\n\t\t\telse if (current == '+')\n\t\t\t{\n\t\t\t\twhile (operators.find(keepOptors.top(), 2)!= string::npos) //top item is +, -,* or /\n\t\t\t\t{\n\t\t\t\t\tcout << keepOptors.top()<<' ';\n\t\t\t\t\tkeepOptors.pop();\n\t\t\t\t\tif (keepOptors.empty())\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tkeepOptors.push(current);\n\t\t\t}\n\t\t\telse if(current =='-')\n\t\t\t{\n\t\t\t\twhile (operators.find(keepOptors.top(), 3)) //top item is -,* or /\n\t\t\t\t{\n\t\t\t\t\tcout << keepOptors.top()<<' ';\n\t\t\t\t\tkeepOptors.pop();\n\t\t\t\t\tif (keepOptors.empty())\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tkeepOptors.push(current);\n\t\t\t}\n\t\t\telse if (current == '*' || current == '(')\n\t\t\t\tkeepOptors.push(current);\n\t\t\telse if (current == ')')\n\t\t\t{\n\t\t\t\twhile (keepOptors.top() != '(')\n\t\t\t\t{\n\t\t\t\t\tcout << keepOptors.top()<<' ';\n\t\t\t\t\tkeepOptors.pop();\n\t\t\t\t}\n\t\t\t\tkeepOptors.pop(); // pop up '('\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tcout << current << ' ';\n\t\tiFile >> current;\n\t}\n\twhile (!keepOptors.empty())\n\t{\n\t\tcout << keepOptors.top() << ' ';\n\t\tkeepOptors.pop();\n\t}\n}\n```\n<a name=\"Kvu8h\"></a>\n### 5. 后缀表达式转中缀表达式\n想法与计算后缀表达式差不多，注意两个地方\n> 1.优先参与运算的运算符的运算结果是下一个运算符的操作数，想想怎么把表达式连接成一个整体\n> 2.为每个计算式加上括号，确保在最终的中缀表达式中能清晰的表达计算顺序，如 8*5+3 与 (8*(5+3))\n\n```cpp\nvoid postfixToInfix()\n{\n\tstack<string> expr;\n\tifstream iFile(\"3_22Sample.txt\");\n\tif (!iFile.is_open())\n\t\tabort();\n\tstring first, second;\n\tchar current;\n\tiFile >> current;\n\twhile (!iFile.eof())\n\t{\n\t\tif (48 <= current && current <= 57)\n\t\t\texpr.push(string(1,current));\n\t\telse\n\t\t{\n\t\t\tfirst = expr.top();\n\t\t\texpr.pop();\n\t\t\tsecond = expr.top();\n\t\t\texpr.pop();\n\t\t\tif (current == '*')\n\t\t\t\texpr.push('('+first + '*'+second+')');\n\t\t\telse if (current == '/')\n\t\t\t\texpr.push('('+first +'/'+ second + ')');\n\t\t\telse if (current == '+')\n\t\t\t\texpr.push('(' + first + '+' + second + ')');\n\t\t\telse\n\t\t\t\texpr.push('(' + first + '-' + second + ')');\n\t\t}\n\t\tiFile >> current;\n\t}\n\tcout << expr.top() << endl;\n}\n```\n<a name=\"OSFAk\"></a>\n### 6. 逆向打印链表的两个方法\n<a name=\"UuJnf\"></a>\n#### 1.链表反转\n改变单向链表的结构，反转其方向。需要用到三个结点的信息`prev、current、next`\n```cpp\nvoid Reverse_List()  // O(1)\n\t{\n\t\tNode* prev, *current, *cNext;\n\t\tprev = nullptr;\n\t\tcurrent = head->next;\n\t\tcNext = current->next;\n\n\t\twhile (cNext != nullptr)\n\t\t{\n\t\t\tcurrent->next = prev; // reverse direction\n\t\t\tprev = current;\n\t\t\tcurrent = cNext;\n\t\t\tcNext = current->next; \n\t\t}\n\t\tcurrent->next = prev;\n\t\thead->next = current; // head to tail\n\n\t\twhile (current != nullptr)\n\t\t{\n\t\t\tcout << current->value << ' ';\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tcout << endl;\n\t}\n```\n> 注意同时声明多个指针时，不能写成`Node* prev, current, cNext`，这种声明下`current、cNext`是int型，只有一个`prev`是指针类型。应改为`Node* prev, *current, *cNext;`\n\n<a name=\"aAKjU\"></a>\n#### 2.利用栈\n逆向打印可以利用栈先进后出的性质实现\n```cpp\nvoid Reverse_Print_With_Stack() //  O(N)\n{\n    stack<T> storage;\n    Node* p = head->next;\n    while (p != nullptr)\n    {\n        storage.push(p->value);\n        p = p->next;\n    }\n    while (!storage.empty())\n    {\n        cout << storage.top() << ' ';\n        storage.pop();\n    }\n    cout << endl;\n\t}\n```\n<a name=\"QwIKh\"></a>\n### 7. 环形缓冲区的满vs空问题\n用**数组**实现队列通常有两种方式\n\n1. head 指向队列头，即第一个元素，tail 指向新元素即将插入的位置，即最后一个元素的下一个位置，enque后tail+1 (初始状态：head = tail = 0)   \n2. head 指向队列头，tail指向最后一个元素，enque前tail+1 （初始状态：front = 0 , tail = -1）\n\n两种情况下，均要保持队列最后一个元素不能使用，(n-1) 长度队列可以用长度为 n 的数组创建\n\n1. <br />\n\nempty：`head = tail  `<br />full：`head = (tail+1) % maxSize`  <br />如果完全填充数组，那么会导致full和empty情况下，均满足`head = tail `\n\n2. <br />\n\nempty : `head = (tail+1) % maxSize`  <br />full：`head = (tail+2) % maxSize` ？<br />如果完全填充数组，那么会导致full和empty情况下,均满足`head = (tail+1) % maxSize`![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1660033289402-7374663e-99df-4e23-8d39-2bcb71e5622a.png)\n<a name=\"mDKbV\"></a>\n### 8. 判断链表是否有环的两个方法\n> 1. 用`hashset`存储遍历过的节点，用新节点对比，有重复则存在环\n> 2. 双指针遍历，速度不同，相遇则存在环\n\n```cpp\ntemplate<typename T>\nclass Solution\n{\npublic:\n\tvoid detectloop(Node<T>* head)\n\t{\n\t\tNode<T>* first, * second;\n\t\tfirst = second = head;\n\t\t/*A walks faster than B, so only A is judged.\n\t\tIf A is the last node, you need to judge A->next*/\n\t\twhile (first != nullptr && first->next != nullptr)\n\t\t{\n\t\t\tfirst = first->next->next; // two step\n\t\t\tsecond = second->next; // one step\n\t\t\tif (first == second)\n\t\t\t{\n\t\t\t\tcout << \"exist loop\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcout << \"no loop\" << endl;\n\t\treturn;\n\t}\n};\n```\n> 涉及的算法：[Floyd's Cycle Finding Algorithm](https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/)\n\n[知乎：如何判断链表有环](https://zhuanlan.zhihu.com/p/31401474)<br />[LeetCode：Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/discuss/1829489/C%2B%2B-oror-Easy-To-Understand-oror-2-Pointer-oror-Fast-and-Slow)\n<a name=\"qdbBD\"></a>\n## other questions：\n\n1. **stackoverflow示例中总是出现的foo ，bar 是什么意思**\n\nfoo：File or Object，文件或对象。它用于代替对象变量或文件名，用于代码演示<br />bar：与foo的作用一样，表示变量或文件，用于代码演示2.VS2019调出监视窗口的办法\n\n2. **vs2019中调式调出监视窗口**\n\n设置断点，运行程序<br />![屏幕截图 2022-07-20 175431.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1658310883417-a80aaf32-ea48-40bb-b554-2c6d8960689b.png)\n\n3. **git上传项目到github**\n\n[知乎：github基础教学](https://zhuanlan.zhihu.com/p/369486197)\n<a name=\"IthCG\"></a>\n## remaining problem\n\n1. **在vector中实现erase(iterator pos)**\n\n涉及萃取\n\n2. **实现能够指定容器的stack类**\n3. **STL stack: emplace() vs push()**\n\n涉及右值引用，移动构造(?)\n\n4. **判断链表是否有环，为什么不直接判断最后一个节点指向是否为nullptr**\n\n我认为可能的原因：当最后一个节点指向本身时，其next也不为nullptr，而此时单链表中不存在环，所以该方法不适用。\n\n---\n\n<a name=\"oX3jS\"></a>\n# Chapter 2 Trees\n<a name=\"JBUuP\"></a>\n## record:\n<a name=\"oEiO6\"></a>\n### 1. 二叉查找树类中为什么要额外添加功能与公有函数相同，但参数不同的同名私有函数\n在类外调用公有函数，而公有函数内部需要递归处理左右子树，需要传入新的根节点，所以需要有额外的能传入根节点参数的函数，因为这类函数只被公有函数所使用，所以设置为私有（辅助函数）<br />[stackoverflow：When/why to make function private in class?](https://stackoverflow.com/questions/4505938/when-why-to-make-function-private-in-class)\n<a name=\"DpaEu\"></a>\n### 2.搜索二叉树的insert成员函数结点指针t必须引用传递的原因\n如果采用值传递，那么函数insert中的指针将是实参的副本，在函数insert中修改该副本，不能达到修改结点p的成员变量left or right的目的, remove函数同理<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1661568230165-1e7336ea-23dc-443d-afa4-e35e7a5a4058.jpeg)\n<a name=\"WEgNR\"></a>\n### 3. 平衡二叉树\n\n对BST的find操作，其运行时间为$O(d)$,$d$为结点的深度。给定一系列值，不同的插入序列对应不同的树结构，有着不同的平均结点深度，进而有不同的查找效率。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1661156478689-efe3aeff-b060-4bc9-80ee-099b96f5aa02.png)<br />创建高度为h的AVL树所需的最少结点数为斐波那契数列第h+2项的值减1（高度和项数均从0计数）\n<a name=\"FZLgt\"></a>\n## remaining problem\n<a name=\"Le4pv\"></a>\n### 1. 给定一系列值，确定构造BST的方法个数\n[stackoverflow：How many ways can you insert a series of values into a BST to form a specific tree?](https://stackoverflow.com/questions/17119116/how-many-ways-can-you-insert-a-series-of-values-into-a-bst-to-form-a-specific-tr)\n\n---\n\n<a name=\"Cieup\"></a>\n# Chapter 3 Hashing\n<a name=\"RQFF9\"></a>\n## 1. 为什么哈希表只能惰性删除(lazy deletion)\n答：在插入其它元素A时，A可能与待删除元素B发生过冲突(collision),即可能有`myhash(A) == myhash(B)`,也可能是A在向前探测的过程中与B发生过冲突。 如果删除元素B，那么在寻找A就会失败，因为此时B所在的位置是EMPTY，那么findPos(A)在B的位置上会返回currentPos,查找结束，但currentPos是EMPTY而不是A所在的值。\n<a name=\"mwjke\"></a>\n## 2. 为什么要有哈希表？是怎么达到高效性的？\n为了在**常数时间**内高效实现对数据的插入，删除，查找操作。 通过**哈希函数**（通常是 `hash(x) % tableSize`,`hash(x)`的作用是将x转化为数字，由key类提供，如果x本身就是数字，那么hash(x) = x），让待插入数据**直接定位**到哈希表中的一个位置（哈希表是什么？ 一个固定大小的存储项的数组， 哈希 = 散列）<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1664794253808-1aee7326-a1c4-44c2-986e-5ca40efa4d87.jpeg)\n<a name=\"Hcjq3\"></a>\n## 3. 冲突(collision)是什么？怎么解决冲突的？\n不同的数据可能会被哈希函数映射到相同的位置，而一个位置只能属于一个数据，因此产生了冲突。为解决冲突，很简单是想法就是：**既然原本属于它的位置被占用了，那就将数据移到可以存放的空位置**<br />如何找到这个空位置呢？有两种方法\n\n1. **分离链接法（separate chaining）:**\n\n既然冲突是因为一个位置只能存放一个数据，那么引入链表以实现一个位置能够存放多个数据，冲突便解决了。哈希表中的一个位置对应一条链表，显然的，在某个位置发生的冲突越多，那么这条链表就越长。无论是执行查找还是删除操作，都要先找到链表（由哈希函数得到），再在链表里面找到数据。\n\n2. **开放定址法（open addressing）：**\n\n往前探测（probe），形式化为公式就是`hashi(x) = (hash(x) + f(i))`,**i表示向前探测的次数**，f(i)称为冲突解决策略（collision resolution strategy）,显然`f(0)=0`。根据f(i)形式的不同，分为线性(Linear)探测:`f(i)=i`、平方(quadratic)探测:`f(i) = i2`、双(double)散列:`f(i) = i*hash2(x)`<br />**线性探测会引起一次聚集（**primary cluster**），平方探测会引起二次聚集（**Secondary Clustering**），**关于这一点：[stackoverflow：What is primary and secondary clustering in hash?](https://stackoverflow.com/questions/27742285/what-is-primary-and-secondary-clustering-in-hash) 说的很清楚<br />为什么一次聚集对性能的影响会比二次聚集更大呢？首先要知道，聚集之所以会影响性能，是因为聚集导致hashPos之后的位置大部分被占用，进而导致探测次数增加。一次聚集是无间隔的聚集，那么只要在这堆聚集的项中发生了冲突，就基本上要一步一步的探测完所有聚集项才能找到空位置。而二次聚集是有间隔的，一次两步的探测会减少探测的发生。这个具体的描述比较困难，但是很好想。<br />双散列，消除了聚集问题，它应用了另一个哈希函数`hash2(x)`（**哈希结果不能为0，则f(i)将失去意义**），使得探测更趋于随机化，而不是集中在哈希位置附近。<br />注意点：\n\n-  哈希表的**大小(tableSize)为素数(Prime)**能更好的减少冲突的发生 \n- **tableSize为素数且λ<0.5**（有一半以上空项）时平方探测能保证插入成功。否则甚至不如线性探测，因为插入可能会失败（书上有证明）\n- 当计算哈希值代价较高时，性能角度上，双散列较之平方探测不是一个更好的选择\n\n**两个方法的对比：** 前者不如后者，因为分离链表法会因为插入而分配新内存，这将降低执行效率；其次，分离链表法等于是哈希表与链表的结合，等于要求实现了另一种数据结构(而不是哈希表)，提高了程序的复杂性\n```cpp\nint findPos(const hashedObj& x) const\n\t{\n\t\tint currentPos = myhash(x);\n\t\tint offset = 1;\n\n\t\twhile (array[currentPos].info != Empty && array[currentPos].element != x)\n\t\t{\n\t\t\tcurrentPos += offset;\n\t\t\toffset = pow(offset,2);\n\t\t\tif (currentPos >= array.size())\n\t\t\t\tcurrentPos -= array.size();\n\t\t}\n\t\treturn currentPos;\n\t}\n```\n<a name=\"vpuOb\"></a>\n## 4. 为什么要再散列(rehashing)？再散列要怎么做？\n当哈希表过于满(too full，λ too big)，查找操作将会变得非常缓慢（如之前所说，探测次数会非常多），进而影响插入和删除操作。解决这个困境的办法就是扩大哈希表以降低λ。<br />做法是：创建一个表长为大于2倍当前长度的第一个素数的新表（如当前长度是7，扩大后为17），相应的也产生了新的哈希函数，接着把原表中的所有数据通过新的哈希函数映射到新表中。<br />怎么界定哈希表是否需要再散列，一个好的方法是：当λ到达某个界定值时\n\n---\n\n<a name=\"OulqF\"></a>\n# Chapter 4 Heap\n<a name=\"KirP0\"></a>\n## 1. 为什么要有二叉堆(Binary Heap)? 是怎么达到高效的？\n为了实现**优先级队列(priority queue)**，即根据不同对象间的优先级排列而形成的队列，如操作系统中进程的优先级队列。相比于用队列(Queue)实现的根据对象到来的时间属性而确定优先级队列(即First Come First Served), 我们希望有一种数据结构，它有着更加灵活的优先级批判标准，而不是只看任务的到达时间。不仅如此，为了高效性，我们希望这个数据结构能够快速的找出队列中优先级最大的那一个。<br />由此我们引出二叉堆，二叉堆是一个**底层为数组的完全二叉树(complete binary tree)，**有结构性质和堆序性质<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1665135196819-0f05c687-059e-4b79-9c73-9c31e16de204.png)\n```cpp\nvoid insert(const Comparable& x)\n\t{\n\t\tif (heapSize == array.size() - 1)\n\t\t\tarray.resize(array.size() * 2);\n\n\t\tint hole = ++heapSize;\n\t\tComparable copy = x;\n\t\tarray[0] = std::move(copy);\n\t\tfor (; x < array[hole / 2]; hole /= 2)  // percolate up\n\t\t{\n\t\t\tarray[hole] = std::move(array[hole / 2);\n\t\t}\n\t\tarray[hole] = std::move(array[0]);\n\t} \n\nvoid deleteMin()\n\t{\n\t\thole = 1;\n\t\tComparable x = std::move(array[heapSize--]);\n\t\tfor (; hole <= heapSize; hole*=2) // percolate down\n\t\t{\n\t\t\tchild = 2 * hole;\n\t\t\tif (child != heapSize && array[child] < array[child + 1])\n\t\t\t\t++child;\n\t\t\tif (x > array[child])\n\t\t\t\tarray[hole] = std::move(array[child]);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tarray[hole] = std::move(x);\n\t}\n\nvoid heapify()\n\t{\n\t\tfor (int i = heapSize / 2; i > 0; --i)\n\t\t\tpercolateDown(i);\n\t}\n```\n\n---\n\n<a name=\"eHZpk\"></a>\n# Chapter 5 Sorting\n<a name=\"SWGCy\"></a>\n## Insertion_Sort\n<a name=\"Hw7N9\"></a>\n### 1. 怎么插入的？为什么结果能有序？\n对序列(Comparable)，假定第一个数据(array[0])是有序的，把从第二项到末尾的数据逐个插入到开头的有序序列中。<br />怎么插入的？将待插入项`tmp`与有序序列中的项逐个比较，遇到`array[i]>tmp`(升序序列)，则将有序序列中的元素右移，为`tmp`提供插入位，接着插入`tmp`。等价于将位置为p的项放入前p+1项(从0开始索引)的正确位置(从小到大)。如果数组本身就比较有序，那么可以省去不少插入操作<br />为什么能有序？ straightforward，我觉得有些许减治法的感觉，先解决小问题，逐步解决大问题。\n```cpp\ntemplate<typename Comparable>\nvoid insertionSort(std::vector<Comparable>& array)\n{\n\tint N = array.size();\n\tfor (int p = 1; p < N; ++p)\n\t{\n\t\tComparable tmp = std::move(array[p]);\n\t\tint j = p - 1;\n\t\tfor (; j >= 0 && tmp < array[j]; --j)\n\t\t{\n\t\t\tarray[j + 1] = std::move(array[j]); // j move right, p move left\n\t\t}\n\t\tarray[j + 1] = std::move(tmp);\n\t}\n};\n```\n<a name=\"AXqXN\"></a>\n## Shell_Sort\n<a name=\"NvzxL\"></a>\n### 1. 为什么说希尔排序涉及了插入排序？\n因为希尔排序先将序列分组，然后在组内进行插入排序\n<a name=\"rqY4s\"></a>\n### 2. 希尔排序是如何分组的？\n使用一组增量h1，h2，h3， . . . , ht(就是代表了不同的跨度，h1 =1)。第一阶段，对任意位置i，把array[i]，array[i+ht]，array[i+2ht]...分为一组执行插入排序；第二阶段，对任意位置i，把array[i]，array[i+ht-1]，array[i+2ht-1]...分为一组执行插入排序。显然的，在最后阶段，使用增量h1=1时就是对整个序列执行插入排序。<br />选择合适的增量能使插入排序的时间复杂度低于插入排序，如 Hibbard增量： 1, 3, 7, . . . , 2k − 1。<br />**执行一个增量为h****k****的排序(hk-Sort)，等价于对h****k****个子数组(subarray)执行插入排序(见下图)**。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1665481444552-78d1a034-c95c-462b-b080-475d22f10d1c.jpeg)\n<a name=\"yUWsx\"></a>\n### 3. 希尔排序是如何改进插入排序的? 执行名副其实的插入排序前(h1)，分组的作用是什么？\n分组的作用是对数组执行[预排序](https://zhuanlan.zhihu.com/p/87781731)，即在执行真正的插入排序前先使数组比较有序，以减少执行插入操作的次数。显然插入排序在1.元素个数少 2. 数组比较有序 的情况下执行效率高。分组营造了前一个条件以高效排序子数组，并为逐步减少分组的增量(跨度)以排序数组中的更多元素提供了第二个条件。所以显然的，希尔排序优于插入排序。\n```cpp\ntemplate<typename Comparable>\nvoid shell_Sort(std::vector<Comparable> array)\n{\n\tint N = array.size();\n\tfor (int gap = N/2; gap > 0; gap /= 2)\n\t{ \n\t\t// insertion Sort\n\t\tfor (int p = gap; p < N; ++p)   // point: ++p here\n\t\t{\n\t\t\tint j = p - gap;\n\t\t\tComparable tmp = std::move(array[p]);\n\t\t\tfor (; j >= 0 &&  array[j] > tmp; j-=gap)\n\t\t\t\tarray[j + gap] = std::move(array[j]);\n\t\t\tarray[j + gap] = std::move(tmp);\n\t\t}\n\t}\n};\n```\n<a name=\"ZZpJ6\"></a>\n## Heap_Sort\n<a name=\"mMQHg\"></a>\n### 1. 如何利用堆实现排序\n要利用堆(heap)将一个乱序的数组变成有序的数组，显然的，要首先构造一个堆(build heap)，即利用heapify的方法将N个元素组成堆的结构(本质还是数组)；接着，对这个堆执行N-1次`deleteMax`(或`deleteMin`)操作，在每次执行删除操作时，将删除的元素填入刚刚空出来的最后一个元素的位置上；最后能得到一个递增序列(最大堆)或递减序列(最小堆)。<br />关键是要认识到，在本质上，对堆执行deleteMax操作，是将堆的最后一个元素(`array[HeapSize]`)填在根(`array[0]`)的位置(覆盖原有的根值),接着把这个结点通过下滤(percolate down)放在合适位置。较之堆删除，堆排序只改变了一个操作，那就是把这个覆盖的过程，变成一个交换(swap)的过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1665664167534-eee32f0c-0cba-487b-a1aa-b684f3f02866.png)\n```cpp\ntemplate<typename Comparable>\nvoid heapSort(vector<Comparable> & objects)\n{\n\t// bulid heap\n\tfor (int j = objects.size()/2-1; j >= 0; --j)\n\t\tpercDown(objects, j, objects.size());\n\t//make a decreasing array\n\tfor (int i = objects.size()-1; i>0; --i)\n\t{\n\t\tswap(objects[0], objects[i]);\n\t\tpercDown(objects, 0, i);\n\t}\n}\n\ninline int  leftChild(int i)\n{\n\treturn 2 * i + 1;\n}\n\ntemplate<typename Comparable>\nvoid percDown(vector<Comparable> &objects , int i, int n)\n{\n\tComparable tmp = move(objects[i]);\n\tint child;// left child \n\tfor(;leftChild(i) < n; i = child)\n\t{\n\t\tchild = leftChild(i);\n\t\tif (child != n-1 && objects[child] < objects[child + 1])\n\t\t\t++child;\n\t\tif (tmp < objects[child])\n\t\t\tobjects[i] = move(objects[child]);\n\t\telse\n\t\t\tbreak;\n\t}\n\tobjects[i] = move(tmp);\n}\n```\n<a name=\"pNLGn\"></a>\n## Merge_Sort\n<a name=\"cBdMT\"></a>\n### 1. 归并排序是如何排序的，为什么说体现了分而治之( divide-and-conquer)的思想？\n归并排序，最重要的基本操作就是**将两个已排序的数组整合为一个**，也就是Merge(合并)操作。要获取两个已排序的数组，首先将待排序的数组一分为二，然后对这两个子数组递归的调用归并排序（递归返回条件：子数组只剩一个元素` left >= right`)。 <br />归并排序本质上是对**逐步完成对子数组的排序进而完成大数组的排序**。<br />**divide：将数组一分为二    conquer：Merge**\n```cpp\ntemplate<typename Comparable>\nvoid mergeSort(vector<Comparable>& objects, vector<Comparable>& tmpA, int left, int right)\n{\n\tif (left >= right) // recursive call's end condition : only one element \n\t\treturn;  \n\tint center = (left + right) / 2;\n\tmergeSort(objects, tmpA, left, center); // merge first half \n\tmergeSort(objects, tmpA, center + 1, right);  // merge second half\n\tmerge(objects, tmpA, left, center + 1, right); // patch\n}\n\ntemplate<typename Comparable>\nvoid mergeSort(vector<Comparable>& objects)  // driver\n{\n\tvector<Comparable> tmpA(objects.size());\n\tmergeSort(objects, tmpA, 0, objects.size() - 1);\n}\n\ntemplate<typename Comparable> // merge two sorted array into one\nvoid merge(vector<Comparable>& objects, vector<Comparable>& tmpA, int leftBegin, int rightBegin, int rightEnd)\n{\n\tint leftEnd = rightBegin - 1;\n\tint tmpAIndex = leftBegin;\n\tint N = rightEnd - leftBegin + 1;\n\n\twhile (leftBegin <= leftEnd && rightBegin <= rightEnd) // comparison between two halves\n\t{\n\t\tif (objects[leftBegin] <= objects[rightBegin])\n\t\t\ttmpA[tmpAIndex++] = move(objects[leftBegin++]);\n\t\telse\n\t\t\ttmpA[tmpAIndex++] = move(objects[rightBegin++]);\n\t}\n\n\twhile (leftBegin <= leftEnd) // copy the remainder\n\t{\n\t\ttmpA[tmpAIndex++] = move(objects[leftBegin++]);\n\t}\n\n\twhile (rightBegin <= rightEnd)\n\t{\n\t\ttmpA[tmpAIndex++] = move(objects[rightBegin++]);\n\t}\n\n\t// how to write back to objects\n\tfor (int i = 0; i < N; ++i,--rightEnd )\n\t{\n\t\tobjects[rightEnd] = move(tmpA[rightEnd]);\n\t}\n\n}\n```\n![](https://cdn.nlark.com/yuque/0/2023/jpeg/29536731/1672988373854-be3e4874-5705-410b-8800-ad92faa15a40.jpeg)\n<a name=\"dIPOD\"></a>\n## Quick_Sort \n<a name=\"SkElc\"></a>\n### 1. 快速排序是如何排序的\n与归并排序类似，快速排序也有分割数组的操作，但不同于归并排序一分为二的做法**，快速排序会先在数组中选取一个枢纽元(pivot)，然后把剩下的元素根据大于/小于pivot分为两组(group)，**产生两个子数组，放在pivot前后，接着递归的对子数组调用快速排序。\n<a name=\"Tfhnl\"></a>\n### 2. 为什么选择三数中值(Median-of-Three )作为pivot的效率最高\n这里的三数中值，指的是数组最左边`array[0]`，最右边`array[size-1]`，和中间`array[(left+right)/2]`这三个值中大小排中间的那个。<br />**选取pivot的原则是取尽可能靠近数组的中值(第 ⌈N/2⌉大的值)，这样做的目的是让分组(partition)后产生了两个子数组如归并排序般尽可能均匀，进而减少递归的层次。**不随机选取三个数取中值的原因在于random函数的代价较高，会影响性能(不随机去一个pivot的原因也是如此)。直接选取第一个元素作为pivot是一个欠妥的做法，这样会导致算法在数组有预排序的情况下做无用功。<br />**为什么将三者的最小值放在**`**array[left]**`**？** 因为最小值必然小于pivot，避免了一次多余的交换，同时这个left还能作为partition过程中`j`的哨兵(sentinel)，避免j越界。<br />**为什么将三者的最大值放在**`**array[right]**`**？**同理，避免了交换，但此处没有起到做哨兵的作用，因为我们会在选取pivot时就将pivot放在`array[right-1]`的位置,而i与j遇到equal to pivot的值都会停止，所以pivot也作为了`i`的哨兵。\n<a name=\"XXNbN\"></a>\n### 3. 如何分组？\n我们的目标是把小于pivot的值放在数组左边，大于pivot的值放在数组右边。**采取的策略时**`**i**`**从数组左边开始遍历，遇到大于pivot的值就停止(该值不属于左边)；**`**j**`**从数组右边开始遍历，遇到小于pivot的值就停止。接着交换**`**i**`**和**`**j**`**所在位置的元素。当i和j交叉时，把**`**pivot**`**与**`**i**`**所在位置的值交换**(为什么是`i`而不是`j`？因为pivot预先被放在数组右边right-1的位置，如果被放在右边那pivot就是和`j`交换位置)<br />**如何处理等于pivot的元素？**先说结论，`**i**`**和**`**j**`**遇到这样的元素都要停下**。<br />接着在极端情况(所有元素都一样)情况下讨论其它做法的低效性<br />**为什么不一个停下而另一个继续前进？**如果`i`停下而`j`不停下，则`i``j`交叉的位置会偏向左侧，而pivot要与i最后在的位置交换值，这样显然会导致子数组的大小不平衡。<br />**为什么不两个都不停下？**首先`i`，`j`显然可能会出界，即使存在`i``j`出界的代码，这样做会导致i最后所处的位置在靠近最右边的位置(取决于具体实现)，而pivot要与`i`交换位置，进而导致产生的子数组很不平衡，降低了算法效率\n<a name=\"mt8ir\"></a>\n### 4. 递归结束条件是什么？什么是cutoff？为什么要结合插入排序？\n快速排序或许应该像归并排序那样，当子数组仅剩一个元素时递归返回。但是实际上并不这样设置递归返回条件，因为存在这样一个事实：**当数组元素个数很少(5~20)时，快速排序的效率还不如插入排序。因此在partition之后如果子数组的大小小于某一界限(cutoff)，就停止递归调用，转而对子数组调用插入排序,进而提升算法的整体效率**<br />这里提到了[快速排序与归并排序的区别](https://stackoverflow.com/questions/70402/why-is-quicksort-better-than-mergesort)，还有的区别点是快速排序不占用额外的内存，快速排序使用的是[尾递归](https://stackoverflow.com/questions/33923/what-is-tail-recursion)等\n```cpp\ntemplate<typename Comparable>\nconst Comparable Median(vector<Comparable> & array,int left,int right)\n{\n\tint center = (left + right) / 2;\n\tif (array[left] > array[right])\n\t\tswap(array[left], array[right]);\n\tif (array[center] > array[right])\n\t\tswap(array[center], array[right]); // keep left is min among three values\n\tif (array[left] > array[center])\n\t\tswap(array[left], array[center]); // keep right is max among three values\n\tswap(array[center], array[right - 1]); // put pivot into position right-1 \n\treturn array[right - 1];\n}\n\ntemplate<typename Comparable>\nvoid quickSort(vector<Comparable>& array, int left, int right)\n{\n\tint range = right - left + 1;\n\tif (range > 10) // cutoff = 10\n\t{\n\t\tComparable pivot = Median(array, left, right);\n\t\t// partition\n\t\tint i = left; int j = right - 1;\n\t\twhile (i < j)\n\t\t{\n\t\t\twhile (array[++i] < pivot); // increase before check , details see stackoverflow \n\t\t\twhile (array[--j] > pivot);\n\t\t\tswap(array[i], array[j]);\n\t\t}\n\t\tswap(array[i], array[right - 1]);\n\t\t// recursion\n\t\tquickSort(array, left, i - 1);\n\t\tquickSort(array, i + 1, right);\n\t}\n\n\telse\n\t\tinsertionSort(array, left, right);\n};\n\n//Driver\ntemplate<typename Comparable>\nvoid quickSort(vector<Comparable>& array)\n{\n\tquickSort(array, 0, array.size() - 1);\n}\n```\n<a name=\"wPOyJ\"></a>\n# Chapter 6 Disjoint Sets\n<a name=\"AHMCd\"></a>\n## 1. 什么是不相交集？什么是union/find操作？\n对于一个集合S，由一个关系R可将S划分为多个[等价类](https://www.zhihu.com/question/276100093/answer/388155191)(equivalence class)，在一个等价类中的所有元素之间均存在关系R(即任意a，b ∈ S, a~b)。显然的，要判断任意给定的S中的元素a，b是否有关系，只需判断a,b是否属于同一个等价类，这也说明了**等价类概念的提出是为了给出一个快速判断a,b是否存在关系的方法(我的理解)**。显然的，等价类是S的一个子集(set)，一个元素也只属于一个等价类，**不同的等价类们就是本章要讨论的不相交集(disjoint sets）**<br />什么是union/find操作？先查找元素a和b所在的等价类(find操作)，然后判断是不是同一个等价类(find(a) == find(b) ？ ),that is，**判断a,b是否有关系。如果没有，就将a,b联系起来，也就是变得有关系**，即将a,b的等价类合并为一个新的等价类(注意关系的传递性(Transitive)，a,b如果有关系，那么两者原来所在集合的所有元素间也存在了关系)，合并的过程就是union操作。如果本身就有关系，就不用操作了。\n<a name=\"x95GB\"></a>\n## 2. 如何表示不相交集？\n初始状态，对于N个元素的集合S，假设N个元素间均不存在关系，因此有N个不相交集(每个集合仅有一个元素)。因为不存在comparison操作，所以我们并不在意元素的值是多少，因此我们**把N个元素以0~N-1编号**。<br />我们**用树来表示一个集合，并把树的根作为集合的名字**(某个元素编号)。初始状态时，每个集合名统一表示为-1。<br />**树形态的不相交集不具备完全二叉树(堆)那样的规整性，为什么可以用数组来实现？**因为对于每个元素我们只关心它所在的集合是哪个，即它所在的树的根是哪个，因此**对于每个元素，我们仅需知道它所在的树的根值**即可。不仅如此，数组的从0开始下标也与我们的编号符合，因此可以**用大小为N的数组存储0~N-1个元素的父节点（即对第i个数组项，array[i]存储了编号i的父结点），提供了一个由任意结点开始向上遍历即可获取根结点（that is ，任意结点所在集合名）的途径。**\n<a name=\"XuWqo\"></a>\n## 3. Union/find 如何执行 ？ \nfind操作要找到元素A所在树的根，即对A结点沿根节点方向向上遍历，直到数组值为 -1(`sets[i] < 0`)，说明此数组编号为根节点(`return x`)。这其实就是一个不断获取父节点的过程，可使用递归。\n```cpp\nint find(int x) const  \n\t{\n\t\tif (sets[x] < 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn find(sets[x]); // recursive\n\t}\n\n```\nUnion操作**要合并两个集合，只需要将一个集合的根结点，链接到另一个集合的根节点上**，因为在我们的方法中，根节点才是集合的唯一标识。具体来说，假设root1(同样的，是一个编号)是某个集合的根结点(即，集合名)，root2是另一个集合的根节点，执行Union，就是执行array[root1] = root2 (执行前：array[root1] == array[root2] == -1 ; 执行后：array[root1] == root2 , array[root2] == -1)<br />如果实参不是根，而是元素编号，则需额外执行两次find\n```cpp\nvoid unions(int root1, int root2)\n\t{\n\t\tsets[root2] = root1;\n\t}\n```\n显然的，因为数组是一个支持随机存取的数据结构，则获取set[x]的值是常数时间(that is O(1) )，find操作真正耗时的是向上探索的过程，也就是说**影响find操作的主要是结点所在的深度**。\n<a name=\"xnSpG\"></a>\n## 4. 如何改进Union\n上述合并是有问题的，把两颗相同高度的树合并，或通过把一颗高树(larger height)根节点链接到一颗矮树的根节点以实现两颗不同高度树的合并，均**会使新树的高度比原来最大的那颗还要多一，即增加了各结点的深度，这样会极大影响find的效率(根节点最大高度为N-1)**。因此我们需要改进合并的方法。<br />很自然的想法就是**把矮树的根节点链接到高树的根节点**(注意本章所用的树不是二叉树，而是一颗多路树)，这样新树的高度还会保持与原来高树的一致；如果两棵树高度相同，那么谁链接到谁都可以，结果都会使新树高度增1(所以根节点最大高度为log2N)<br />如何确定高树和矮树？显然的，**我们需要跟踪每棵树的高度，可以用现有的数组存储，原先根节点的数组值为-1，现在将其改写为其所代表集合的高度的负数**(为什么是负数？或许是为了方便find函数的判断语句更好编写:`if (sets[x] < 0 return x;`注意之前提到设置各集合初始值为-1，也与这里符合)<br />也可以根据数的大小(size)决定谁链接到谁，但显然由高度做决定更好\n```cpp\nvoid unionSets(int root1, int root2)\n\t{\n\t\tif (sets[root2] < sets[root1]) // set[root] keep track of height(negative)\n\t\t\tsets[root1] = root2; // root2 is deeper\n\t\telse\n\t\t{\n\t\t\tif (sets[root2] == sets[root1])\n\t\t\t\t--sets[root1];\n\t\t\tsets[root2] = root1;\n\t\t}\n\t}\n```\n<a name=\"unJoe\"></a>\n## 5. 如何改进find\n在寻找编号为x的元素的根的过程中，我们使用**路径压缩(Path Compression)**的方法(自调整)，即**把从x到root之间所有结点的父节点均改为根节点。**<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1666421236514-c4f89687-71a5-42a4-b5fe-19f8f379487a.png)<br />具体做法是**递归的将根节点的编号赋值给路径上的结点**\n```cpp\n\tint find(int x) \n\t{\n\t\tif (sets[x] < 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn sets[x] = find(sets[x]);\n\t}\n```\n<a name=\"fO0SW\"></a>\n# Chapter 7 Graph Algorithms\n<a name=\"TOgKc\"></a>\n## [Graph implement](https://stackoverflow.com/questions/5493474/graph-implementation-c)\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1666956918039-3ebc54cf-6c4e-4feb-8f90-6473899dc634.jpeg)\n```cpp\n#pragma once\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct vertex\n{\n\ttypedef pair<int, vertex* > ve;\n\tint name; \n\tint seq;// serial number\n\tint ind; // indegree\n    int addition // additional Message \n\tvector<ve> adj; // adjacent list:cost of edge, destination vertex\n\n\tvertex(int n) :name(n),seq(0),ind(0){}\n};\n\nclass Graph\n{\npublic:\n\ttypedef map<int, vertex*> vmap;\n\tvmap graph;\n\tvoid addEdge(const int from, const int to,const int weight);\n\tvoid addVertex(int newSeq);\n};\n\nvoid Graph::addEdge(const int from, const int to, const int weight)\n{\n\tvertex* f = graph.find(from)->second;\n\tvertex* t = graph.find(to)->second; \n\tpair<int, vertex*> edge = make_pair(weight, t);\n\tf->adj.push_back(edge);\n    ++(t->ind);\n}\n\nvoid Graph::addVertex(int newSeq)\n{\n\tauto iter = graph.find(newSeq);\n\tif (iter != graph.end())\n\t{\n\t\tvertex * v;\n\t\tv = new vertex(newSeq);\n\t\tgraph[newSeq] = v;\n\t\treturn;\n\t}\n}\n\nint Graph::size()\n{\n\treturn graph.size();\n}\n\nvoid InitialGraph(Graph& myGraph)  // a instance\n{\n\tmyGraph.addVertex(0);\n\tmyGraph.addVertex(1);\n\tmyGraph.addVertex(2); \n\tmyGraph.addVertex(3);\n\tmyGraph.addVertex(4);\n\tmyGraph.addVertex(5);\n\tmyGraph.addEdge(0, 1, 1);// as unweighted graph , weight = 1\n\tmyGraph.addEdge(0, 2, 1);\n\tmyGraph.addEdge(3, 2, 1);\n\tmyGraph.addEdge(3, 0, 1);\n\tmyGraph.addEdge(4, 3, 1); \n\tmyGraph.addEdge(4, 1, 1);\n\tmyGraph.addEdge(1, 5, 1);\n\n}\n```\n<a name=\"JeoiH\"></a>\n## Topological Sort\n<a name=\"ueS0P\"></a>\n### 1. 什么是拓扑排序？意义是什么？\n首先先理解拓扑的含义：the way the parts of sth are arranged and related. 形象的来说：比如说一个人要自学计算机科学知识(sth)，而该领域知识由很多板块的内容(parts)构成，这些内容又相互关联(在学懂A课程前必须有B课程的基础，related)，那么他就面临一个问题，怎么安排学习顺序(路径，arranged)？一个显然不合理的安排是在学习操作系统先于数据结构与算法，因为数据结构与算法是学习OS的前置课程。**一个不违反前置条件的学习路径就是一个拓扑排序，其意义就是得到一条合理的学习路径。**说的更广泛一点，拓扑排序就是得到一个合理的处理顺序。<br />如果我们把各板块内容之间铺垫关系画成一张图，各板块为顶点，有向边作为关联(如 Vertex数据结构与算法指向Vertex操作系统)，那么**拓扑排序在这个图中体现为一条沿着有向边方向的路径**(即路径中任意一段单位路径u到v,不存在边(v,u))<br />显然，**存在拓扑排序的图一定是有向无环图**( directed acyclic graph，DAG),[如果图是有环的，那么就找不到符合要求的路径，因为总会违反前置条件](https://www.quora.com/Why-must-a-graph-with-a-topological-sort-be-acyclic-and-why-must-an-acyclic-graph-have-a-topological-sort)\n<a name=\"yLpq8\"></a>\n### 2. 如何实现拓扑排序算法？怎样使其更高效？\n对于我们要选择的第一个顶点，显然的，它必须没有前置条件，即没有顶点指向它，入度(indegree为0)。我们选择这样一个点，然后**在图中抹去该点和它的边**(显然的，都是由它发出的边，与它相关的顶点入度也随之更新)，在剩下的图中重复这个步骤，直到图为空(如果找不到入度为0的顶点而图不为空，说明图不是DAG，存在环)。顶点被抹去的顺序，就是拓扑排序。<br />如何快速寻找到入度为0的点呢？如果通过遍历顶点集的方式，那么开销是很大的，特别是如果图很稀疏(边很少，sparse)，那么要去除的边也是很少的，因此每一步被影响到入度的顶点的数量也是很少的，即大部分的顶点入度是一直没变的，反复的遍历它们是pointless行为。<br />提升效率方法是**将入度为0的点单独拿出来，我们可以用栈或队列来存储。在每次去掉顶点和边之后，我们将更新后入度变为0的顶点加入到队列中**。显然的，队列的出队顺序就是我们要求的拓扑排序。\n```cpp\n#pragma once\n#include<iostream>\n#include\"Graph.h\"\n#include<queue>\nusing namespace std;\n\nvoid TopologicalSort(Graph& myGraph)\n{ \n\tqueue<vertex*> zero;\n\tint counter = -1;\n\tint N = myGraph.size();\n\n\tfor (auto& iter :myGraph.graph) // initalize vertexSet which indegree is zero\n\t{\n\t\tif (iter.second->ind == 0)\n\t\t\tzero.push(iter.second);\n\t}\n\n\twhile (!zero.empty())\n\t{\n\t\tvertex* v = zero.front();\n\t\tzero.pop();\n\t\tv->seq = ++counter;\n\t\tcout << v->name << ' ';\n\t\tint adjN = v->adj.size();\n\t\tfor (int i = 0; i < adjN; ++i)\n\t\t{\n\t\t\tif (--(v->adj[i].second->ind) == 0)\n\t\t\t\tzero.push(v->adj[i].second);\n\t\t}\n\t}\n\n\tif (counter != N-1)\n\t\tabort();\n}\n```\n<a name=\"Ms2lL\"></a>\n## Shortest-Path Algorithms\n<a name=\"TdCMl\"></a>\n### 1. 什么是单源最短路径问题？\n单源最短路径问题(Single-Source Shortest-Path Problem): **给定一个有权图(weighted graph,可以有环)中的一个点**`**v**`**，求出**`**v**`**到其它所有顶点的最短路径**，that is ,在答案所呈现的结果图中，`v`到结果图中任意一个顶点`w`的路径，其长度是`v`与`w`之间存在的所有路径中，长度最短的那条。<br />也可以从另一个角度理解这个问题，即如果把边长视为开销，那么**该问题就是要以最小的开销，从源顶点开始，覆盖整张图的顶点**\n<a name=\"q5MIP\"></a>\n### 2.为什么Breadth-First Search可以解决Unweighted Shortest-Paths?\n为了理解SSSP问题，我们先考虑无权图，无权图可视为权重为1的有权图<br />我们先设置问题的初始状态：`v`到任意`w`的距离都是无穷大，任意`w`的状态都是unknown(`v`到该`w`的最短路径还未确定)。<br />我们首先能确定的是`v`能直接到达的点(`v`的邻接点)，因为v只有唯一途径能到达这些点，所以这个唯一途径就是最短路径。我们把这些点称为第一层，其最短路径均为1。接着，我们能确定的点显然是第一层的邻接点，**因为**`**v**`**能通过第一层的点去访问只有这些点**，我们把这些点称为第二层，其最短路径自然为2。按照这样的一个广度优先搜索的逻辑，我们便能确定所有点的最短路径。<br />因为是无权图，所以不存在对路径长度的多次更新（关于该点可见后续讨论中的例子：不存在将s->w1->w3更改为s->w2->w3的可能），对每个顶点的处理，只需简单的将其distance信息设置为前一个顶点的distance+1即可。\n```cpp\nvoid Graph::unweighted_Shortest_Path_with_queue(vertex& s)\n{\n\tqueue<vertex*> q;\n\tfor (auto& iter : graph)\n\t\titer.second->dist = INFINITY;\n\ts.dist = 0;\n\tq.push(&s);\n\twhile (!q.empty())\n\t{\n\t\tvertex v = *q.front(); // priority '.' > '*'\n\t\tq.pop(); \n\t\tfor (auto& adjac : v.adj)\n\t\t{\n\t\t\tadjac.second->dist = v.dist + 1; \n\t\t\tadjac.second->path = v.name;\n\t\t\tq.push(adjac.second);\n\t\t}\n\t}\n}\n\nvoid Graph::unweighted_Shortest_Path(vertex& s)\n{\n\tint NUM_VERTICES = size();\n\tfor (auto& iter : graph) \n\t{\n\t\titer.second->dist = INFINITY;\n\t\titer.second->known = false;\n\t}\n\ts.dist = 0;\n\n\tfor (int currDist = 0; currDist < NUM_VERTICES; ++currDist) // double for loops:inefficiency\n\t\tfor (auto& iter : graph) \n\t\t\tif (!iter.second->known && iter.second->dist == currDist)\n\t\t\t{\n\t\t\t\titer.second->known = true;\n\t\t\t\tfor (auto& adjac : (iter.second->adj))\n\t\t\t\t{\n\t\t\t\t\tadjac.second->dist = currDist + 1; // update distance\n\t\t\t\t\tadjac.second->path = iter.second->name;\n\t\t\t\t}\n\t\t\t}\n}\n```\n<a name=\"YjF5L\"></a>\n### 3.为什么Dijkstra Algorithm每一步要选择最近的结点，为什么该算法可以解决Single-Source Weighted？\n与上一问一样，要找到`v`到所有顶点的最短路径，我们总得先知道`v`能到达哪些点。所以我们在用Dijkstra解决SSSP的时候，我们似乎也应该按照这样的结点选择顺序：首先找的是`v`的邻接点，然后再邻接点..... 。但是我们需要注意，**我们实际选择结点的顺序(选择结点即把结点变为known，说明找到了到它的最短路径)，是不断的选取未确定结点中离**`**v**`**距离最近的那一个，而不是像无权图中那样邻接点接着邻接点的广度搜索。**<br />**为什么要选择最近的那一个？**<br />举个最简单的例子：在这个图中，我们首先探索了源顶点的邻接点w1,w2，更新其dist为ds+dcost，那么w1.dist=1，w2.dist =3。那么下一轮我们选择那个顶点进行探索(其邻接点)呢？显然是w1，因为在当前条件下，我们只知道源顶点离w1更近一些，那么到w3(后续未知结点)的最短路径自然更可能的在w1这边(我们还不知道后续顶点的dist信息)。**因此我们在每次选择一个顶点以探索他的邻接点(更新dist信息)，都要选择当前距离v最近的那个，因为经过这样一个点的路径才最有可能是(到后续顶点)最短路径/开销可能最少。**<br />为什么在无权图中不用这样做？<br />无权图的边长权重都为1，开销的是一样的。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1667390674960-21e67dd1-f11c-4336-a168-c237056626fe.jpeg)<br />我们要有一个认知：**源顶点**`**v**`**到某一目标顶点**`**w****t**`**之间的最短路径①上存在着几个中间顶点，那么v到任意一个中间结点**`**w****i**`**的最短路径②一定与①重合。**或者说v到目标顶点的最短路径，是目标顶点在该路径的上一个顶点的最短路径延长了一个边长所得到的。<br />**因此我们逐步找到各顶点的最短路径，并从之前找到的最短路径(以开销最少的方式)延展到其它顶点上，便可以找到到所有顶点的最短路径。**\n```cpp\nvoid Graph::Dijkstra_Algorithm(vertex& s)\n{\n\tfor (auto& iter : graph)\n\t{\n\t\titer.second->dist = INFINITY;\n\t\titer.second->known = false;\n\t}\n\ts.dist = 0;\n\twhile (existUnknown()) //there is an unknown vertex\n\t{\n \t\tvertex* v = smallestUnknown();   // smallest unknown distance vertex\n\t\tv->known = true;\n\t\tfor (auto& iter : v->adj)\n\t\t{\n\t\t\tif (v->dist + iter.first < iter.second->dist) \n\t\t\t{\n\t\t\t\titer.second->dist = v->dist + iter.first; // update\n\t\t\t\titer.second->path = v->name;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool Graph:: existUnknown()\n{\n\tfor (auto& iter : graph)  // iteration \n\t{\n\t\tif (!iter.second->known)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvertex* Graph::smallestUnknown()\n{\n\tvertex* min = graph.begin()->second;\n\tfor (auto& iter : graph)  // iteration \n\t{\n\t\tif (!iter.second->known && iter.second->dist < min->dist)\n\t\t\tmin = iter.second;\n\t}\n\treturn min;\n}\n```\n<a name=\"b4gnk\"></a>\n### 4.为什么Dijkstra Algorithm不适用于有负权值边的图\n在Dijkstra算法中，我们**一旦将一个顶点**`**v**`**由unknown标记为known，就说明由**`**s**`**到**`**v**`**的最短路径已经找到，且不会再改变，即算法不会在后续过程中回头(look back)修改到**`**v**`**的最短路程这一信息**。如果我们用Dijkstra算法在图中确定了`v`的最短路径，然后发现`v`到某个邻接点`u`(状态为unknown)的边权值为负，那么此时`s`到`v`的实际最短路径就发生了变化：s->v->w->v，然而因为Dijkstra算法不会look back，所以算法继续保持之前的最短路径，因此会产生与事实不符的结果。\n<a name=\"wzqMO\"></a>\n## Critical Path Problems\n<a name=\"MCV9V\"></a>\n### 1. 如何理解关键路径？关键路径是什么？\n一个项目由多个可独立完成工作(jobs)组成，各工作之间存在优先级限制关系(precedence constraint)，即某一项工作必须在完成另一项(或多项)工作后才能启动。①如何确定项目的最快(早)完成时间？②如何确定某些工作的可延迟时间 (that is,slack time 松弛时间) 以不至于增加整个项目的完成时间？<br />**关键路径这样一组工作序列：该工作序列可以用来确定项目的最快完成时间。对第二点，关键路径上的所有工作的可延迟时间均为0，关键路径上的任何一个工作被延迟，都会增加整个项目的完成时间，这也是为什么称之为\"关键\"。**<br />这样的项目可以体现在有向无环图中。为什么一定是无环？与拓扑排序一样的道理，如果有几个工作成环状相互制约，那就无法开启任何一项工作，因为总是违反其优先级限制关系。**关键路径在这样的图中体现为从开始到结束的最长路径(longest path)**<br />注意路径的长度由边的权值(工作完成所需时间)决定而不是边的数量\n<a name=\"oj5FV\"></a>\n### 2. 为什么图的最长路径就是关键路径？\n> 关键路径是通过识别最长的相关活动并测量从开始到结束完成它们所需的时间来确定的 -wikipedia\n\n我们首先要理解一条路径上的各个工作节点之间存在着严格的先后关系，即优先级限制关系。这就说明**各工作只能串行的执行**，哪怕你有很多处理器(processors)也必须等待高优先级的工作执行完毕后再开启新的工作。互不关联(不在同一路径)的工作可以并行的执行，所以**在最长路径上的最后一个工作执行完毕时，其它路径也一定执行完毕，即整个项目执行完毕。因此最长路径决定了项目的完成时间，不延迟的执行最长路径(上的工作)所花的时间，就是项目的最快完成时间。**\n<a name=\"Aa03a\"></a>\n## Network Flow Problems\n<a name=\"RBuq3\"></a>\n### 1. 如何理解网络流问题？\n网络流问题就是从一个端`s`往另一个端`t`发送流(Flow,如通水，运货，发送数据包等)，要经过数个中间节点，各节点间的边的传输容量是有限的(如水管的阈值，超过了这个值水管会破裂)，问从s发送到t的最大流(the maximum amount of ﬂow)是多少。显然的要找出这个最大流，**我们要解决的根本问题是如何正确安排运输方案(即路径选择)以最大化流**。<br />**如何计算图中流的数量(the amount of ﬂow)？** **只需看从端**`**s**`**发出了多少流即可**(端`t`肯定接受同样数量的流，除非“漏水”了)<br />**怎么验证我们得到的流的数量是最大的？**把图分割(cut)为两个部分，一部分包含s，另一部分包含t(其余结点随意，因此存在多种切割方式)，**经过切割线上的边的容量总和决定了最大流的界限，容量总和的最小值即为图所能承受的最大流的值(the minimum cut capacity is exactly equal to the maximum ﬂow)**<br />由此我们可以看出，**解决最大流问题的目的不是为了得到最大流的值，而是知道能达到最大流的运输方案**<br />[**网络流问题基础 Network Flow Problems**](https://www.youtube.com/watch?v=6DFWUgV5Osc&list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&index=8)\n<a name=\"LytbY\"></a>\n### 2. 如何得到最大流？\n首先考虑简单的算法(naive algorithm )，我们随机的选择路径( free to choose any path from s to t)，直到Gr中不存在s到t的路径，看能否得到最大流，事实证明，这样是不可靠的，得到的方案可能会使我们会得到一个小于最大流的值。**该方法存在的缺陷是，一旦在某一步选中了错误的路径(不属于最大流方案的路径)，算法无法纠正错误，因此找不到最大流。**<br />我们改进一下这个算法，**在每次进行一次路径选择(即在G****r****图中相应边执行了减法)之后，接着在相应边上加上一条方向相反的边，其权值就等于刚刚该边减去的值。称为Ford–Fulkerson algorithm**<br />**这样做的目的，是让算法有了撤销(undo)的能力，可以把不好的路径撤销掉，因此该算法总能找到正确的路径，进而找到最大流。**<br />[**Ford-Fulkerson Algorithm 寻找网络最大流  -Dr Wang **](https://www.youtube.com/watch?v=8sLON0DqLZo&list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&index=9)\n\n\n","source":"_posts/D_A_C++.md","raw":"---\ntitle: 《数据结构与算法C++》学习历程 \ndate: 2022/10/25\ncategories:\n- Data structure and Algorithm\ntags: \n- Foundation\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n<a name=\"qIfKY\"></a>\n\n# 前言\n\n以下记录了我2022年暑假开始学习数据结构的历程。从哈希表到图论，有着详细的思考过程。\n\n<!--more-->\n\n---\n\n<a name=\"Aq9ue\"></a>\n# Chapter 1 Lists,Stacks and Queues\n<a name=\"csZFb\"></a>\n### 1. 对自制vector容器添加错误检查能力\n> 访问vector容器，可能会出现的错误的迭代器操作主要有两种\n> 1. 错误的访存操作：迭代器未初始化，执行`*`操作\n> 2. 迭代器超出容器边界：迭代器在末尾执行`++iter/iter++`操作\n> \n另外，迭代器还会出现如`7`所述的失效的情况\n\n<a name=\"kxJtb\"></a>\n#### 1.处理错误操作：在重载运算符`*`和`++`时检查current的值\n```cpp\nObject operator *()\n{\n\tif (const_iterator::current == NULL)  // Check boundary\n    {\n        cout << \"Error: iterator is NULL!\" << endl;\n\t\tabort();\n\t}\n\treturn *(const_iterator::current);\n}\n\niterator& operator ++ ()\n{\n    if (const_iterator::current == objects[theSize-1]) // Error:Cannot access objects\n\t{\n\t\tcout << \"Error: iterator is end!\" << endl;\n\t    abort();\n\t}\n\tconst_iterator::current++;\n\treturn *this;\n}\n```\niterator类与const_iterator类作为vector模板类的嵌套类，访问外部类的私有成员`objects`与`theSize`是一件比较困难的事情 [StackOverFlow：Can inner classes access private variables?](https://stackoverflow.com/questions/486099/can-inner-classes-access-private-variables)\n> 嵌套类与外部类之间没有访问特权\n\n<a name=\"hHyA9\"></a>\n#### 2.处理失效的迭代器：给迭代器添加一个数据成员用于指向当前表，用一个函数用于判断迭代器是否指向正确的表。当发生扩容时，原有的theVector指向的空间被释放。（`theVector == NULL`感觉有点问题）\n```cpp\nclass const_iterator\n{\n    ...\nprotected:\n    Object* current;\n    const vector<Object>* theVector;\n    \n    void assertIsValid()const\n\t{\n\t\tif(current == NULL || theVector == NULL)\n            throw \"IteratorOutOfbounds\";\n    }\n    ...\n}\n```\n<a name=\"fgUkk\"></a>\n### 2. 搜寻链表的注意点\n在链表搜寻值为x的节点时，显然需要保存两个节点的信息：当前节点`current`和上一个节点`foreCurrent`,要注意对这两个值不同的初始化，搜寻的条件也不同。有以下两种模式：\n```cpp\ncurrent = head->next\nforeCurrent = head;\nwhile (current && current->data != x)\n{\n    foreCurrent = current;\n    current = current->next;\n}\n```\n```cpp\nNode* current = head; // Initially nullptr\nNode* foreCurrent = nullptr;\nwhile (current->next!= nullptr && current->data != x )\n{\n\tforeCurrent = current;\n\tcurrent = current->next;\n}\n```\n注意：混淆这两种模式将出现访存错误，如以下情况\n```cpp\nNode* current = head->next;\nNode* foreCurrent = head;\nwhile (current->next!= nullptr && current->data != x )\n{\n\tforeCurrent = current;\n\tcurrent = current->next;\n}\n```\n这样会出现的问题是：当链表中仅有一个头节点时，初始`current=head->next`值为`nullptr`，第3行的`current->next`将执行失败（实现iterator类后，尽可能的使用该类，该类不存在以上问题）\n<a name=\"hF7j1\"></a>\n### 3.平衡符号\n创建一个空栈后读取文件，当读取到开放字符`(,{,[,/*`时压入栈，当读取到封闭字符`),},],*/`时从栈顶弹出字符。\n> 1. 读取到封闭字符时，栈为空，则封闭字符不匹配，报错\n> 2. 弹出的字符与封闭字符不匹配，报错\n> 3. 读取到文件尾后，栈不为空，则开放字符不匹配，报错\n\n```cpp\nvoid balSymbol()\n{\n\tchar current, prev;\n\tstring left(\"{[(*\");\n\tstring right(\"}])\");\n\tifstream iFile(\"3_21Sample.txt\");\n\tstack<char> check;\n\tif (!iFile.is_open())\n\t\tabort();\n\tiFile >> current;\n\tprev = '\\0';\n\twhile (!iFile.eof())\n\t{ \n\t\t// push open symbol in stack\n\t\tif (left.find(current) != string::npos) \n\t\t{\n\t\t\tif(current !='*')\n\t\t\t\tcheck.push(current);\n\t\t\telse if (current == '*' && prev == '/') // push in '/*'\n\t\t\t{\n\t\t\t\tcheck.push(prev);\n\t\t\t}\n\t\t\t// no push action for current =='*' prev !='/'\n\t\t}\n\t\t// If it is a closed symbol and stack is not empty, the corresponding symbol will pop up\n\n\t\tif (current == '/' && prev == '*') // special for '/','/' can be left or right\n\t\t{ // for '*/',no action for current =='/' and stack is empty (/*....),\n\t\t\tif(check.empty())\n\t\t\t{\n\t\t\t\t//last mismatch closed symbol is a speical situation, which can not belong to error:eof()\n\t\t\t\tcout << \"closed symbol mismatch!\" << endl;\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\telse if(check.top() == '/')\n\t\t\t\tcheck.pop();\n\t\t}\n\t\telse if (right.find(current) != string::npos)   // for (]}\n\t\t{\n\t\t\tif (check.empty()) // prevent top() error\n\t\t\t{\n\t\t\t\t//last mismatch closed symbol is a speical situation, which can not belong to error:eof()\n\t\t\t\tcout << \"closed symbol mismatch!\" << endl;\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\telse if (current == '}' && check.top() == '{')\n\t\t\t\tcheck.pop();\n\t\t\telse if (current == ']' && check.top() == '[')\n\t\t\t\tcheck.pop();\n\t\t\telse if (current == ')' && check.top() == '(')\n\t\t\t\tcheck.pop();\n\t\t\telse\n\t\t\t\tbreak; // error: top stack symbol mismatch → eof() is false\n\t\t}\n\t\tprev = current;\n\t\tiFile >> current; // read next character in buffer\n\t}\n\t// judge\n\tif (!iFile.eof() )\n\t\tcout << \"closed symbol mismatch!\" << endl;\n\telse if (!check.empty())\n\t\tcout << \"open symbol mismatch!\" << endl;\n\telse\n\t\tcout << \"Successful!\" << endl;\n}\n```\n<a name=\"JdH6s\"></a>\n### 4. 中缀表达式转后缀表达式\n1.为什么在向栈中压入运算符时，要先弹出优先级更高的运算符\n> 运算符的出栈顺序代表了运算符的执行顺序。显然的，优先级更高的运算符最先打印并出栈，即在后缀表达式中代表最早参与运算\n\n2.为什么直到碰到右括号`)`之前，不弹出左括号`(`，遇到右括号`)`后,弹出栈元素直到遇到`(`\n> 该操作的意思是弹出括号内的所有运算符，显然的，括号内的各运算符优先级高于括号外的运算符\n\n```cpp\nvoid infixToPostFix()\n{\n\tifstream iFile(\"3_23Sample.txt\");\n\tif (!iFile.is_open())\n\t\tabort();\n\tstring operators = \"()+-/*\";\n\tstack<char>keepOptors;\n\tchar current;\n\tiFile >> current;\n\twhile (!iFile.eof())\n\t{\n\t\tif (operators.find(current) != string::npos)\n\t\t{\n\t\t\tif (keepOptors.empty()) // initial\n\t\t\t\tkeepOptors.push(current);\n\t\t\telse if (current == '+')\n\t\t\t{\n\t\t\t\twhile (operators.find(keepOptors.top(), 2)!= string::npos) //top item is +, -,* or /\n\t\t\t\t{\n\t\t\t\t\tcout << keepOptors.top()<<' ';\n\t\t\t\t\tkeepOptors.pop();\n\t\t\t\t\tif (keepOptors.empty())\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tkeepOptors.push(current);\n\t\t\t}\n\t\t\telse if(current =='-')\n\t\t\t{\n\t\t\t\twhile (operators.find(keepOptors.top(), 3)) //top item is -,* or /\n\t\t\t\t{\n\t\t\t\t\tcout << keepOptors.top()<<' ';\n\t\t\t\t\tkeepOptors.pop();\n\t\t\t\t\tif (keepOptors.empty())\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tkeepOptors.push(current);\n\t\t\t}\n\t\t\telse if (current == '*' || current == '(')\n\t\t\t\tkeepOptors.push(current);\n\t\t\telse if (current == ')')\n\t\t\t{\n\t\t\t\twhile (keepOptors.top() != '(')\n\t\t\t\t{\n\t\t\t\t\tcout << keepOptors.top()<<' ';\n\t\t\t\t\tkeepOptors.pop();\n\t\t\t\t}\n\t\t\t\tkeepOptors.pop(); // pop up '('\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tcout << current << ' ';\n\t\tiFile >> current;\n\t}\n\twhile (!keepOptors.empty())\n\t{\n\t\tcout << keepOptors.top() << ' ';\n\t\tkeepOptors.pop();\n\t}\n}\n```\n<a name=\"Kvu8h\"></a>\n### 5. 后缀表达式转中缀表达式\n想法与计算后缀表达式差不多，注意两个地方\n> 1.优先参与运算的运算符的运算结果是下一个运算符的操作数，想想怎么把表达式连接成一个整体\n> 2.为每个计算式加上括号，确保在最终的中缀表达式中能清晰的表达计算顺序，如 8*5+3 与 (8*(5+3))\n\n```cpp\nvoid postfixToInfix()\n{\n\tstack<string> expr;\n\tifstream iFile(\"3_22Sample.txt\");\n\tif (!iFile.is_open())\n\t\tabort();\n\tstring first, second;\n\tchar current;\n\tiFile >> current;\n\twhile (!iFile.eof())\n\t{\n\t\tif (48 <= current && current <= 57)\n\t\t\texpr.push(string(1,current));\n\t\telse\n\t\t{\n\t\t\tfirst = expr.top();\n\t\t\texpr.pop();\n\t\t\tsecond = expr.top();\n\t\t\texpr.pop();\n\t\t\tif (current == '*')\n\t\t\t\texpr.push('('+first + '*'+second+')');\n\t\t\telse if (current == '/')\n\t\t\t\texpr.push('('+first +'/'+ second + ')');\n\t\t\telse if (current == '+')\n\t\t\t\texpr.push('(' + first + '+' + second + ')');\n\t\t\telse\n\t\t\t\texpr.push('(' + first + '-' + second + ')');\n\t\t}\n\t\tiFile >> current;\n\t}\n\tcout << expr.top() << endl;\n}\n```\n<a name=\"OSFAk\"></a>\n### 6. 逆向打印链表的两个方法\n<a name=\"UuJnf\"></a>\n#### 1.链表反转\n改变单向链表的结构，反转其方向。需要用到三个结点的信息`prev、current、next`\n```cpp\nvoid Reverse_List()  // O(1)\n\t{\n\t\tNode* prev, *current, *cNext;\n\t\tprev = nullptr;\n\t\tcurrent = head->next;\n\t\tcNext = current->next;\n\n\t\twhile (cNext != nullptr)\n\t\t{\n\t\t\tcurrent->next = prev; // reverse direction\n\t\t\tprev = current;\n\t\t\tcurrent = cNext;\n\t\t\tcNext = current->next; \n\t\t}\n\t\tcurrent->next = prev;\n\t\thead->next = current; // head to tail\n\n\t\twhile (current != nullptr)\n\t\t{\n\t\t\tcout << current->value << ' ';\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tcout << endl;\n\t}\n```\n> 注意同时声明多个指针时，不能写成`Node* prev, current, cNext`，这种声明下`current、cNext`是int型，只有一个`prev`是指针类型。应改为`Node* prev, *current, *cNext;`\n\n<a name=\"aAKjU\"></a>\n#### 2.利用栈\n逆向打印可以利用栈先进后出的性质实现\n```cpp\nvoid Reverse_Print_With_Stack() //  O(N)\n{\n    stack<T> storage;\n    Node* p = head->next;\n    while (p != nullptr)\n    {\n        storage.push(p->value);\n        p = p->next;\n    }\n    while (!storage.empty())\n    {\n        cout << storage.top() << ' ';\n        storage.pop();\n    }\n    cout << endl;\n\t}\n```\n<a name=\"QwIKh\"></a>\n### 7. 环形缓冲区的满vs空问题\n用**数组**实现队列通常有两种方式\n\n1. head 指向队列头，即第一个元素，tail 指向新元素即将插入的位置，即最后一个元素的下一个位置，enque后tail+1 (初始状态：head = tail = 0)   \n2. head 指向队列头，tail指向最后一个元素，enque前tail+1 （初始状态：front = 0 , tail = -1）\n\n两种情况下，均要保持队列最后一个元素不能使用，(n-1) 长度队列可以用长度为 n 的数组创建\n\n1. <br />\n\nempty：`head = tail  `<br />full：`head = (tail+1) % maxSize`  <br />如果完全填充数组，那么会导致full和empty情况下，均满足`head = tail `\n\n2. <br />\n\nempty : `head = (tail+1) % maxSize`  <br />full：`head = (tail+2) % maxSize` ？<br />如果完全填充数组，那么会导致full和empty情况下,均满足`head = (tail+1) % maxSize`![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1660033289402-7374663e-99df-4e23-8d39-2bcb71e5622a.png)\n<a name=\"mDKbV\"></a>\n### 8. 判断链表是否有环的两个方法\n> 1. 用`hashset`存储遍历过的节点，用新节点对比，有重复则存在环\n> 2. 双指针遍历，速度不同，相遇则存在环\n\n```cpp\ntemplate<typename T>\nclass Solution\n{\npublic:\n\tvoid detectloop(Node<T>* head)\n\t{\n\t\tNode<T>* first, * second;\n\t\tfirst = second = head;\n\t\t/*A walks faster than B, so only A is judged.\n\t\tIf A is the last node, you need to judge A->next*/\n\t\twhile (first != nullptr && first->next != nullptr)\n\t\t{\n\t\t\tfirst = first->next->next; // two step\n\t\t\tsecond = second->next; // one step\n\t\t\tif (first == second)\n\t\t\t{\n\t\t\t\tcout << \"exist loop\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcout << \"no loop\" << endl;\n\t\treturn;\n\t}\n};\n```\n> 涉及的算法：[Floyd's Cycle Finding Algorithm](https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/)\n\n[知乎：如何判断链表有环](https://zhuanlan.zhihu.com/p/31401474)<br />[LeetCode：Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/discuss/1829489/C%2B%2B-oror-Easy-To-Understand-oror-2-Pointer-oror-Fast-and-Slow)\n<a name=\"qdbBD\"></a>\n## other questions：\n\n1. **stackoverflow示例中总是出现的foo ，bar 是什么意思**\n\nfoo：File or Object，文件或对象。它用于代替对象变量或文件名，用于代码演示<br />bar：与foo的作用一样，表示变量或文件，用于代码演示2.VS2019调出监视窗口的办法\n\n2. **vs2019中调式调出监视窗口**\n\n设置断点，运行程序<br />![屏幕截图 2022-07-20 175431.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1658310883417-a80aaf32-ea48-40bb-b554-2c6d8960689b.png)\n\n3. **git上传项目到github**\n\n[知乎：github基础教学](https://zhuanlan.zhihu.com/p/369486197)\n<a name=\"IthCG\"></a>\n## remaining problem\n\n1. **在vector中实现erase(iterator pos)**\n\n涉及萃取\n\n2. **实现能够指定容器的stack类**\n3. **STL stack: emplace() vs push()**\n\n涉及右值引用，移动构造(?)\n\n4. **判断链表是否有环，为什么不直接判断最后一个节点指向是否为nullptr**\n\n我认为可能的原因：当最后一个节点指向本身时，其next也不为nullptr，而此时单链表中不存在环，所以该方法不适用。\n\n---\n\n<a name=\"oX3jS\"></a>\n# Chapter 2 Trees\n<a name=\"JBUuP\"></a>\n## record:\n<a name=\"oEiO6\"></a>\n### 1. 二叉查找树类中为什么要额外添加功能与公有函数相同，但参数不同的同名私有函数\n在类外调用公有函数，而公有函数内部需要递归处理左右子树，需要传入新的根节点，所以需要有额外的能传入根节点参数的函数，因为这类函数只被公有函数所使用，所以设置为私有（辅助函数）<br />[stackoverflow：When/why to make function private in class?](https://stackoverflow.com/questions/4505938/when-why-to-make-function-private-in-class)\n<a name=\"DpaEu\"></a>\n### 2.搜索二叉树的insert成员函数结点指针t必须引用传递的原因\n如果采用值传递，那么函数insert中的指针将是实参的副本，在函数insert中修改该副本，不能达到修改结点p的成员变量left or right的目的, remove函数同理<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1661568230165-1e7336ea-23dc-443d-afa4-e35e7a5a4058.jpeg)\n<a name=\"WEgNR\"></a>\n### 3. 平衡二叉树\n\n对BST的find操作，其运行时间为$O(d)$,$d$为结点的深度。给定一系列值，不同的插入序列对应不同的树结构，有着不同的平均结点深度，进而有不同的查找效率。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1661156478689-efe3aeff-b060-4bc9-80ee-099b96f5aa02.png)<br />创建高度为h的AVL树所需的最少结点数为斐波那契数列第h+2项的值减1（高度和项数均从0计数）\n<a name=\"FZLgt\"></a>\n## remaining problem\n<a name=\"Le4pv\"></a>\n### 1. 给定一系列值，确定构造BST的方法个数\n[stackoverflow：How many ways can you insert a series of values into a BST to form a specific tree?](https://stackoverflow.com/questions/17119116/how-many-ways-can-you-insert-a-series-of-values-into-a-bst-to-form-a-specific-tr)\n\n---\n\n<a name=\"Cieup\"></a>\n# Chapter 3 Hashing\n<a name=\"RQFF9\"></a>\n## 1. 为什么哈希表只能惰性删除(lazy deletion)\n答：在插入其它元素A时，A可能与待删除元素B发生过冲突(collision),即可能有`myhash(A) == myhash(B)`,也可能是A在向前探测的过程中与B发生过冲突。 如果删除元素B，那么在寻找A就会失败，因为此时B所在的位置是EMPTY，那么findPos(A)在B的位置上会返回currentPos,查找结束，但currentPos是EMPTY而不是A所在的值。\n<a name=\"mwjke\"></a>\n## 2. 为什么要有哈希表？是怎么达到高效性的？\n为了在**常数时间**内高效实现对数据的插入，删除，查找操作。 通过**哈希函数**（通常是 `hash(x) % tableSize`,`hash(x)`的作用是将x转化为数字，由key类提供，如果x本身就是数字，那么hash(x) = x），让待插入数据**直接定位**到哈希表中的一个位置（哈希表是什么？ 一个固定大小的存储项的数组， 哈希 = 散列）<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1664794253808-1aee7326-a1c4-44c2-986e-5ca40efa4d87.jpeg)\n<a name=\"Hcjq3\"></a>\n## 3. 冲突(collision)是什么？怎么解决冲突的？\n不同的数据可能会被哈希函数映射到相同的位置，而一个位置只能属于一个数据，因此产生了冲突。为解决冲突，很简单是想法就是：**既然原本属于它的位置被占用了，那就将数据移到可以存放的空位置**<br />如何找到这个空位置呢？有两种方法\n\n1. **分离链接法（separate chaining）:**\n\n既然冲突是因为一个位置只能存放一个数据，那么引入链表以实现一个位置能够存放多个数据，冲突便解决了。哈希表中的一个位置对应一条链表，显然的，在某个位置发生的冲突越多，那么这条链表就越长。无论是执行查找还是删除操作，都要先找到链表（由哈希函数得到），再在链表里面找到数据。\n\n2. **开放定址法（open addressing）：**\n\n往前探测（probe），形式化为公式就是`hashi(x) = (hash(x) + f(i))`,**i表示向前探测的次数**，f(i)称为冲突解决策略（collision resolution strategy）,显然`f(0)=0`。根据f(i)形式的不同，分为线性(Linear)探测:`f(i)=i`、平方(quadratic)探测:`f(i) = i2`、双(double)散列:`f(i) = i*hash2(x)`<br />**线性探测会引起一次聚集（**primary cluster**），平方探测会引起二次聚集（**Secondary Clustering**），**关于这一点：[stackoverflow：What is primary and secondary clustering in hash?](https://stackoverflow.com/questions/27742285/what-is-primary-and-secondary-clustering-in-hash) 说的很清楚<br />为什么一次聚集对性能的影响会比二次聚集更大呢？首先要知道，聚集之所以会影响性能，是因为聚集导致hashPos之后的位置大部分被占用，进而导致探测次数增加。一次聚集是无间隔的聚集，那么只要在这堆聚集的项中发生了冲突，就基本上要一步一步的探测完所有聚集项才能找到空位置。而二次聚集是有间隔的，一次两步的探测会减少探测的发生。这个具体的描述比较困难，但是很好想。<br />双散列，消除了聚集问题，它应用了另一个哈希函数`hash2(x)`（**哈希结果不能为0，则f(i)将失去意义**），使得探测更趋于随机化，而不是集中在哈希位置附近。<br />注意点：\n\n-  哈希表的**大小(tableSize)为素数(Prime)**能更好的减少冲突的发生 \n- **tableSize为素数且λ<0.5**（有一半以上空项）时平方探测能保证插入成功。否则甚至不如线性探测，因为插入可能会失败（书上有证明）\n- 当计算哈希值代价较高时，性能角度上，双散列较之平方探测不是一个更好的选择\n\n**两个方法的对比：** 前者不如后者，因为分离链表法会因为插入而分配新内存，这将降低执行效率；其次，分离链表法等于是哈希表与链表的结合，等于要求实现了另一种数据结构(而不是哈希表)，提高了程序的复杂性\n```cpp\nint findPos(const hashedObj& x) const\n\t{\n\t\tint currentPos = myhash(x);\n\t\tint offset = 1;\n\n\t\twhile (array[currentPos].info != Empty && array[currentPos].element != x)\n\t\t{\n\t\t\tcurrentPos += offset;\n\t\t\toffset = pow(offset,2);\n\t\t\tif (currentPos >= array.size())\n\t\t\t\tcurrentPos -= array.size();\n\t\t}\n\t\treturn currentPos;\n\t}\n```\n<a name=\"vpuOb\"></a>\n## 4. 为什么要再散列(rehashing)？再散列要怎么做？\n当哈希表过于满(too full，λ too big)，查找操作将会变得非常缓慢（如之前所说，探测次数会非常多），进而影响插入和删除操作。解决这个困境的办法就是扩大哈希表以降低λ。<br />做法是：创建一个表长为大于2倍当前长度的第一个素数的新表（如当前长度是7，扩大后为17），相应的也产生了新的哈希函数，接着把原表中的所有数据通过新的哈希函数映射到新表中。<br />怎么界定哈希表是否需要再散列，一个好的方法是：当λ到达某个界定值时\n\n---\n\n<a name=\"OulqF\"></a>\n# Chapter 4 Heap\n<a name=\"KirP0\"></a>\n## 1. 为什么要有二叉堆(Binary Heap)? 是怎么达到高效的？\n为了实现**优先级队列(priority queue)**，即根据不同对象间的优先级排列而形成的队列，如操作系统中进程的优先级队列。相比于用队列(Queue)实现的根据对象到来的时间属性而确定优先级队列(即First Come First Served), 我们希望有一种数据结构，它有着更加灵活的优先级批判标准，而不是只看任务的到达时间。不仅如此，为了高效性，我们希望这个数据结构能够快速的找出队列中优先级最大的那一个。<br />由此我们引出二叉堆，二叉堆是一个**底层为数组的完全二叉树(complete binary tree)，**有结构性质和堆序性质<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1665135196819-0f05c687-059e-4b79-9c73-9c31e16de204.png)\n```cpp\nvoid insert(const Comparable& x)\n\t{\n\t\tif (heapSize == array.size() - 1)\n\t\t\tarray.resize(array.size() * 2);\n\n\t\tint hole = ++heapSize;\n\t\tComparable copy = x;\n\t\tarray[0] = std::move(copy);\n\t\tfor (; x < array[hole / 2]; hole /= 2)  // percolate up\n\t\t{\n\t\t\tarray[hole] = std::move(array[hole / 2);\n\t\t}\n\t\tarray[hole] = std::move(array[0]);\n\t} \n\nvoid deleteMin()\n\t{\n\t\thole = 1;\n\t\tComparable x = std::move(array[heapSize--]);\n\t\tfor (; hole <= heapSize; hole*=2) // percolate down\n\t\t{\n\t\t\tchild = 2 * hole;\n\t\t\tif (child != heapSize && array[child] < array[child + 1])\n\t\t\t\t++child;\n\t\t\tif (x > array[child])\n\t\t\t\tarray[hole] = std::move(array[child]);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tarray[hole] = std::move(x);\n\t}\n\nvoid heapify()\n\t{\n\t\tfor (int i = heapSize / 2; i > 0; --i)\n\t\t\tpercolateDown(i);\n\t}\n```\n\n---\n\n<a name=\"eHZpk\"></a>\n# Chapter 5 Sorting\n<a name=\"SWGCy\"></a>\n## Insertion_Sort\n<a name=\"Hw7N9\"></a>\n### 1. 怎么插入的？为什么结果能有序？\n对序列(Comparable)，假定第一个数据(array[0])是有序的，把从第二项到末尾的数据逐个插入到开头的有序序列中。<br />怎么插入的？将待插入项`tmp`与有序序列中的项逐个比较，遇到`array[i]>tmp`(升序序列)，则将有序序列中的元素右移，为`tmp`提供插入位，接着插入`tmp`。等价于将位置为p的项放入前p+1项(从0开始索引)的正确位置(从小到大)。如果数组本身就比较有序，那么可以省去不少插入操作<br />为什么能有序？ straightforward，我觉得有些许减治法的感觉，先解决小问题，逐步解决大问题。\n```cpp\ntemplate<typename Comparable>\nvoid insertionSort(std::vector<Comparable>& array)\n{\n\tint N = array.size();\n\tfor (int p = 1; p < N; ++p)\n\t{\n\t\tComparable tmp = std::move(array[p]);\n\t\tint j = p - 1;\n\t\tfor (; j >= 0 && tmp < array[j]; --j)\n\t\t{\n\t\t\tarray[j + 1] = std::move(array[j]); // j move right, p move left\n\t\t}\n\t\tarray[j + 1] = std::move(tmp);\n\t}\n};\n```\n<a name=\"AXqXN\"></a>\n## Shell_Sort\n<a name=\"NvzxL\"></a>\n### 1. 为什么说希尔排序涉及了插入排序？\n因为希尔排序先将序列分组，然后在组内进行插入排序\n<a name=\"rqY4s\"></a>\n### 2. 希尔排序是如何分组的？\n使用一组增量h1，h2，h3， . . . , ht(就是代表了不同的跨度，h1 =1)。第一阶段，对任意位置i，把array[i]，array[i+ht]，array[i+2ht]...分为一组执行插入排序；第二阶段，对任意位置i，把array[i]，array[i+ht-1]，array[i+2ht-1]...分为一组执行插入排序。显然的，在最后阶段，使用增量h1=1时就是对整个序列执行插入排序。<br />选择合适的增量能使插入排序的时间复杂度低于插入排序，如 Hibbard增量： 1, 3, 7, . . . , 2k − 1。<br />**执行一个增量为h****k****的排序(hk-Sort)，等价于对h****k****个子数组(subarray)执行插入排序(见下图)**。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1665481444552-78d1a034-c95c-462b-b080-475d22f10d1c.jpeg)\n<a name=\"yUWsx\"></a>\n### 3. 希尔排序是如何改进插入排序的? 执行名副其实的插入排序前(h1)，分组的作用是什么？\n分组的作用是对数组执行[预排序](https://zhuanlan.zhihu.com/p/87781731)，即在执行真正的插入排序前先使数组比较有序，以减少执行插入操作的次数。显然插入排序在1.元素个数少 2. 数组比较有序 的情况下执行效率高。分组营造了前一个条件以高效排序子数组，并为逐步减少分组的增量(跨度)以排序数组中的更多元素提供了第二个条件。所以显然的，希尔排序优于插入排序。\n```cpp\ntemplate<typename Comparable>\nvoid shell_Sort(std::vector<Comparable> array)\n{\n\tint N = array.size();\n\tfor (int gap = N/2; gap > 0; gap /= 2)\n\t{ \n\t\t// insertion Sort\n\t\tfor (int p = gap; p < N; ++p)   // point: ++p here\n\t\t{\n\t\t\tint j = p - gap;\n\t\t\tComparable tmp = std::move(array[p]);\n\t\t\tfor (; j >= 0 &&  array[j] > tmp; j-=gap)\n\t\t\t\tarray[j + gap] = std::move(array[j]);\n\t\t\tarray[j + gap] = std::move(tmp);\n\t\t}\n\t}\n};\n```\n<a name=\"ZZpJ6\"></a>\n## Heap_Sort\n<a name=\"mMQHg\"></a>\n### 1. 如何利用堆实现排序\n要利用堆(heap)将一个乱序的数组变成有序的数组，显然的，要首先构造一个堆(build heap)，即利用heapify的方法将N个元素组成堆的结构(本质还是数组)；接着，对这个堆执行N-1次`deleteMax`(或`deleteMin`)操作，在每次执行删除操作时，将删除的元素填入刚刚空出来的最后一个元素的位置上；最后能得到一个递增序列(最大堆)或递减序列(最小堆)。<br />关键是要认识到，在本质上，对堆执行deleteMax操作，是将堆的最后一个元素(`array[HeapSize]`)填在根(`array[0]`)的位置(覆盖原有的根值),接着把这个结点通过下滤(percolate down)放在合适位置。较之堆删除，堆排序只改变了一个操作，那就是把这个覆盖的过程，变成一个交换(swap)的过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1665664167534-eee32f0c-0cba-487b-a1aa-b684f3f02866.png)\n```cpp\ntemplate<typename Comparable>\nvoid heapSort(vector<Comparable> & objects)\n{\n\t// bulid heap\n\tfor (int j = objects.size()/2-1; j >= 0; --j)\n\t\tpercDown(objects, j, objects.size());\n\t//make a decreasing array\n\tfor (int i = objects.size()-1; i>0; --i)\n\t{\n\t\tswap(objects[0], objects[i]);\n\t\tpercDown(objects, 0, i);\n\t}\n}\n\ninline int  leftChild(int i)\n{\n\treturn 2 * i + 1;\n}\n\ntemplate<typename Comparable>\nvoid percDown(vector<Comparable> &objects , int i, int n)\n{\n\tComparable tmp = move(objects[i]);\n\tint child;// left child \n\tfor(;leftChild(i) < n; i = child)\n\t{\n\t\tchild = leftChild(i);\n\t\tif (child != n-1 && objects[child] < objects[child + 1])\n\t\t\t++child;\n\t\tif (tmp < objects[child])\n\t\t\tobjects[i] = move(objects[child]);\n\t\telse\n\t\t\tbreak;\n\t}\n\tobjects[i] = move(tmp);\n}\n```\n<a name=\"pNLGn\"></a>\n## Merge_Sort\n<a name=\"cBdMT\"></a>\n### 1. 归并排序是如何排序的，为什么说体现了分而治之( divide-and-conquer)的思想？\n归并排序，最重要的基本操作就是**将两个已排序的数组整合为一个**，也就是Merge(合并)操作。要获取两个已排序的数组，首先将待排序的数组一分为二，然后对这两个子数组递归的调用归并排序（递归返回条件：子数组只剩一个元素` left >= right`)。 <br />归并排序本质上是对**逐步完成对子数组的排序进而完成大数组的排序**。<br />**divide：将数组一分为二    conquer：Merge**\n```cpp\ntemplate<typename Comparable>\nvoid mergeSort(vector<Comparable>& objects, vector<Comparable>& tmpA, int left, int right)\n{\n\tif (left >= right) // recursive call's end condition : only one element \n\t\treturn;  \n\tint center = (left + right) / 2;\n\tmergeSort(objects, tmpA, left, center); // merge first half \n\tmergeSort(objects, tmpA, center + 1, right);  // merge second half\n\tmerge(objects, tmpA, left, center + 1, right); // patch\n}\n\ntemplate<typename Comparable>\nvoid mergeSort(vector<Comparable>& objects)  // driver\n{\n\tvector<Comparable> tmpA(objects.size());\n\tmergeSort(objects, tmpA, 0, objects.size() - 1);\n}\n\ntemplate<typename Comparable> // merge two sorted array into one\nvoid merge(vector<Comparable>& objects, vector<Comparable>& tmpA, int leftBegin, int rightBegin, int rightEnd)\n{\n\tint leftEnd = rightBegin - 1;\n\tint tmpAIndex = leftBegin;\n\tint N = rightEnd - leftBegin + 1;\n\n\twhile (leftBegin <= leftEnd && rightBegin <= rightEnd) // comparison between two halves\n\t{\n\t\tif (objects[leftBegin] <= objects[rightBegin])\n\t\t\ttmpA[tmpAIndex++] = move(objects[leftBegin++]);\n\t\telse\n\t\t\ttmpA[tmpAIndex++] = move(objects[rightBegin++]);\n\t}\n\n\twhile (leftBegin <= leftEnd) // copy the remainder\n\t{\n\t\ttmpA[tmpAIndex++] = move(objects[leftBegin++]);\n\t}\n\n\twhile (rightBegin <= rightEnd)\n\t{\n\t\ttmpA[tmpAIndex++] = move(objects[rightBegin++]);\n\t}\n\n\t// how to write back to objects\n\tfor (int i = 0; i < N; ++i,--rightEnd )\n\t{\n\t\tobjects[rightEnd] = move(tmpA[rightEnd]);\n\t}\n\n}\n```\n![](https://cdn.nlark.com/yuque/0/2023/jpeg/29536731/1672988373854-be3e4874-5705-410b-8800-ad92faa15a40.jpeg)\n<a name=\"dIPOD\"></a>\n## Quick_Sort \n<a name=\"SkElc\"></a>\n### 1. 快速排序是如何排序的\n与归并排序类似，快速排序也有分割数组的操作，但不同于归并排序一分为二的做法**，快速排序会先在数组中选取一个枢纽元(pivot)，然后把剩下的元素根据大于/小于pivot分为两组(group)，**产生两个子数组，放在pivot前后，接着递归的对子数组调用快速排序。\n<a name=\"Tfhnl\"></a>\n### 2. 为什么选择三数中值(Median-of-Three )作为pivot的效率最高\n这里的三数中值，指的是数组最左边`array[0]`，最右边`array[size-1]`，和中间`array[(left+right)/2]`这三个值中大小排中间的那个。<br />**选取pivot的原则是取尽可能靠近数组的中值(第 ⌈N/2⌉大的值)，这样做的目的是让分组(partition)后产生了两个子数组如归并排序般尽可能均匀，进而减少递归的层次。**不随机选取三个数取中值的原因在于random函数的代价较高，会影响性能(不随机去一个pivot的原因也是如此)。直接选取第一个元素作为pivot是一个欠妥的做法，这样会导致算法在数组有预排序的情况下做无用功。<br />**为什么将三者的最小值放在**`**array[left]**`**？** 因为最小值必然小于pivot，避免了一次多余的交换，同时这个left还能作为partition过程中`j`的哨兵(sentinel)，避免j越界。<br />**为什么将三者的最大值放在**`**array[right]**`**？**同理，避免了交换，但此处没有起到做哨兵的作用，因为我们会在选取pivot时就将pivot放在`array[right-1]`的位置,而i与j遇到equal to pivot的值都会停止，所以pivot也作为了`i`的哨兵。\n<a name=\"XXNbN\"></a>\n### 3. 如何分组？\n我们的目标是把小于pivot的值放在数组左边，大于pivot的值放在数组右边。**采取的策略时**`**i**`**从数组左边开始遍历，遇到大于pivot的值就停止(该值不属于左边)；**`**j**`**从数组右边开始遍历，遇到小于pivot的值就停止。接着交换**`**i**`**和**`**j**`**所在位置的元素。当i和j交叉时，把**`**pivot**`**与**`**i**`**所在位置的值交换**(为什么是`i`而不是`j`？因为pivot预先被放在数组右边right-1的位置，如果被放在右边那pivot就是和`j`交换位置)<br />**如何处理等于pivot的元素？**先说结论，`**i**`**和**`**j**`**遇到这样的元素都要停下**。<br />接着在极端情况(所有元素都一样)情况下讨论其它做法的低效性<br />**为什么不一个停下而另一个继续前进？**如果`i`停下而`j`不停下，则`i``j`交叉的位置会偏向左侧，而pivot要与i最后在的位置交换值，这样显然会导致子数组的大小不平衡。<br />**为什么不两个都不停下？**首先`i`，`j`显然可能会出界，即使存在`i``j`出界的代码，这样做会导致i最后所处的位置在靠近最右边的位置(取决于具体实现)，而pivot要与`i`交换位置，进而导致产生的子数组很不平衡，降低了算法效率\n<a name=\"mt8ir\"></a>\n### 4. 递归结束条件是什么？什么是cutoff？为什么要结合插入排序？\n快速排序或许应该像归并排序那样，当子数组仅剩一个元素时递归返回。但是实际上并不这样设置递归返回条件，因为存在这样一个事实：**当数组元素个数很少(5~20)时，快速排序的效率还不如插入排序。因此在partition之后如果子数组的大小小于某一界限(cutoff)，就停止递归调用，转而对子数组调用插入排序,进而提升算法的整体效率**<br />这里提到了[快速排序与归并排序的区别](https://stackoverflow.com/questions/70402/why-is-quicksort-better-than-mergesort)，还有的区别点是快速排序不占用额外的内存，快速排序使用的是[尾递归](https://stackoverflow.com/questions/33923/what-is-tail-recursion)等\n```cpp\ntemplate<typename Comparable>\nconst Comparable Median(vector<Comparable> & array,int left,int right)\n{\n\tint center = (left + right) / 2;\n\tif (array[left] > array[right])\n\t\tswap(array[left], array[right]);\n\tif (array[center] > array[right])\n\t\tswap(array[center], array[right]); // keep left is min among three values\n\tif (array[left] > array[center])\n\t\tswap(array[left], array[center]); // keep right is max among three values\n\tswap(array[center], array[right - 1]); // put pivot into position right-1 \n\treturn array[right - 1];\n}\n\ntemplate<typename Comparable>\nvoid quickSort(vector<Comparable>& array, int left, int right)\n{\n\tint range = right - left + 1;\n\tif (range > 10) // cutoff = 10\n\t{\n\t\tComparable pivot = Median(array, left, right);\n\t\t// partition\n\t\tint i = left; int j = right - 1;\n\t\twhile (i < j)\n\t\t{\n\t\t\twhile (array[++i] < pivot); // increase before check , details see stackoverflow \n\t\t\twhile (array[--j] > pivot);\n\t\t\tswap(array[i], array[j]);\n\t\t}\n\t\tswap(array[i], array[right - 1]);\n\t\t// recursion\n\t\tquickSort(array, left, i - 1);\n\t\tquickSort(array, i + 1, right);\n\t}\n\n\telse\n\t\tinsertionSort(array, left, right);\n};\n\n//Driver\ntemplate<typename Comparable>\nvoid quickSort(vector<Comparable>& array)\n{\n\tquickSort(array, 0, array.size() - 1);\n}\n```\n<a name=\"wPOyJ\"></a>\n# Chapter 6 Disjoint Sets\n<a name=\"AHMCd\"></a>\n## 1. 什么是不相交集？什么是union/find操作？\n对于一个集合S，由一个关系R可将S划分为多个[等价类](https://www.zhihu.com/question/276100093/answer/388155191)(equivalence class)，在一个等价类中的所有元素之间均存在关系R(即任意a，b ∈ S, a~b)。显然的，要判断任意给定的S中的元素a，b是否有关系，只需判断a,b是否属于同一个等价类，这也说明了**等价类概念的提出是为了给出一个快速判断a,b是否存在关系的方法(我的理解)**。显然的，等价类是S的一个子集(set)，一个元素也只属于一个等价类，**不同的等价类们就是本章要讨论的不相交集(disjoint sets）**<br />什么是union/find操作？先查找元素a和b所在的等价类(find操作)，然后判断是不是同一个等价类(find(a) == find(b) ？ ),that is，**判断a,b是否有关系。如果没有，就将a,b联系起来，也就是变得有关系**，即将a,b的等价类合并为一个新的等价类(注意关系的传递性(Transitive)，a,b如果有关系，那么两者原来所在集合的所有元素间也存在了关系)，合并的过程就是union操作。如果本身就有关系，就不用操作了。\n<a name=\"x95GB\"></a>\n## 2. 如何表示不相交集？\n初始状态，对于N个元素的集合S，假设N个元素间均不存在关系，因此有N个不相交集(每个集合仅有一个元素)。因为不存在comparison操作，所以我们并不在意元素的值是多少，因此我们**把N个元素以0~N-1编号**。<br />我们**用树来表示一个集合，并把树的根作为集合的名字**(某个元素编号)。初始状态时，每个集合名统一表示为-1。<br />**树形态的不相交集不具备完全二叉树(堆)那样的规整性，为什么可以用数组来实现？**因为对于每个元素我们只关心它所在的集合是哪个，即它所在的树的根是哪个，因此**对于每个元素，我们仅需知道它所在的树的根值**即可。不仅如此，数组的从0开始下标也与我们的编号符合，因此可以**用大小为N的数组存储0~N-1个元素的父节点（即对第i个数组项，array[i]存储了编号i的父结点），提供了一个由任意结点开始向上遍历即可获取根结点（that is ，任意结点所在集合名）的途径。**\n<a name=\"XuWqo\"></a>\n## 3. Union/find 如何执行 ？ \nfind操作要找到元素A所在树的根，即对A结点沿根节点方向向上遍历，直到数组值为 -1(`sets[i] < 0`)，说明此数组编号为根节点(`return x`)。这其实就是一个不断获取父节点的过程，可使用递归。\n```cpp\nint find(int x) const  \n\t{\n\t\tif (sets[x] < 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn find(sets[x]); // recursive\n\t}\n\n```\nUnion操作**要合并两个集合，只需要将一个集合的根结点，链接到另一个集合的根节点上**，因为在我们的方法中，根节点才是集合的唯一标识。具体来说，假设root1(同样的，是一个编号)是某个集合的根结点(即，集合名)，root2是另一个集合的根节点，执行Union，就是执行array[root1] = root2 (执行前：array[root1] == array[root2] == -1 ; 执行后：array[root1] == root2 , array[root2] == -1)<br />如果实参不是根，而是元素编号，则需额外执行两次find\n```cpp\nvoid unions(int root1, int root2)\n\t{\n\t\tsets[root2] = root1;\n\t}\n```\n显然的，因为数组是一个支持随机存取的数据结构，则获取set[x]的值是常数时间(that is O(1) )，find操作真正耗时的是向上探索的过程，也就是说**影响find操作的主要是结点所在的深度**。\n<a name=\"xnSpG\"></a>\n## 4. 如何改进Union\n上述合并是有问题的，把两颗相同高度的树合并，或通过把一颗高树(larger height)根节点链接到一颗矮树的根节点以实现两颗不同高度树的合并，均**会使新树的高度比原来最大的那颗还要多一，即增加了各结点的深度，这样会极大影响find的效率(根节点最大高度为N-1)**。因此我们需要改进合并的方法。<br />很自然的想法就是**把矮树的根节点链接到高树的根节点**(注意本章所用的树不是二叉树，而是一颗多路树)，这样新树的高度还会保持与原来高树的一致；如果两棵树高度相同，那么谁链接到谁都可以，结果都会使新树高度增1(所以根节点最大高度为log2N)<br />如何确定高树和矮树？显然的，**我们需要跟踪每棵树的高度，可以用现有的数组存储，原先根节点的数组值为-1，现在将其改写为其所代表集合的高度的负数**(为什么是负数？或许是为了方便find函数的判断语句更好编写:`if (sets[x] < 0 return x;`注意之前提到设置各集合初始值为-1，也与这里符合)<br />也可以根据数的大小(size)决定谁链接到谁，但显然由高度做决定更好\n```cpp\nvoid unionSets(int root1, int root2)\n\t{\n\t\tif (sets[root2] < sets[root1]) // set[root] keep track of height(negative)\n\t\t\tsets[root1] = root2; // root2 is deeper\n\t\telse\n\t\t{\n\t\t\tif (sets[root2] == sets[root1])\n\t\t\t\t--sets[root1];\n\t\t\tsets[root2] = root1;\n\t\t}\n\t}\n```\n<a name=\"unJoe\"></a>\n## 5. 如何改进find\n在寻找编号为x的元素的根的过程中，我们使用**路径压缩(Path Compression)**的方法(自调整)，即**把从x到root之间所有结点的父节点均改为根节点。**<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/29536731/1666421236514-c4f89687-71a5-42a4-b5fe-19f8f379487a.png)<br />具体做法是**递归的将根节点的编号赋值给路径上的结点**\n```cpp\n\tint find(int x) \n\t{\n\t\tif (sets[x] < 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn sets[x] = find(sets[x]);\n\t}\n```\n<a name=\"fO0SW\"></a>\n# Chapter 7 Graph Algorithms\n<a name=\"TOgKc\"></a>\n## [Graph implement](https://stackoverflow.com/questions/5493474/graph-implementation-c)\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1666956918039-3ebc54cf-6c4e-4feb-8f90-6473899dc634.jpeg)\n```cpp\n#pragma once\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct vertex\n{\n\ttypedef pair<int, vertex* > ve;\n\tint name; \n\tint seq;// serial number\n\tint ind; // indegree\n    int addition // additional Message \n\tvector<ve> adj; // adjacent list:cost of edge, destination vertex\n\n\tvertex(int n) :name(n),seq(0),ind(0){}\n};\n\nclass Graph\n{\npublic:\n\ttypedef map<int, vertex*> vmap;\n\tvmap graph;\n\tvoid addEdge(const int from, const int to,const int weight);\n\tvoid addVertex(int newSeq);\n};\n\nvoid Graph::addEdge(const int from, const int to, const int weight)\n{\n\tvertex* f = graph.find(from)->second;\n\tvertex* t = graph.find(to)->second; \n\tpair<int, vertex*> edge = make_pair(weight, t);\n\tf->adj.push_back(edge);\n    ++(t->ind);\n}\n\nvoid Graph::addVertex(int newSeq)\n{\n\tauto iter = graph.find(newSeq);\n\tif (iter != graph.end())\n\t{\n\t\tvertex * v;\n\t\tv = new vertex(newSeq);\n\t\tgraph[newSeq] = v;\n\t\treturn;\n\t}\n}\n\nint Graph::size()\n{\n\treturn graph.size();\n}\n\nvoid InitialGraph(Graph& myGraph)  // a instance\n{\n\tmyGraph.addVertex(0);\n\tmyGraph.addVertex(1);\n\tmyGraph.addVertex(2); \n\tmyGraph.addVertex(3);\n\tmyGraph.addVertex(4);\n\tmyGraph.addVertex(5);\n\tmyGraph.addEdge(0, 1, 1);// as unweighted graph , weight = 1\n\tmyGraph.addEdge(0, 2, 1);\n\tmyGraph.addEdge(3, 2, 1);\n\tmyGraph.addEdge(3, 0, 1);\n\tmyGraph.addEdge(4, 3, 1); \n\tmyGraph.addEdge(4, 1, 1);\n\tmyGraph.addEdge(1, 5, 1);\n\n}\n```\n<a name=\"JeoiH\"></a>\n## Topological Sort\n<a name=\"ueS0P\"></a>\n### 1. 什么是拓扑排序？意义是什么？\n首先先理解拓扑的含义：the way the parts of sth are arranged and related. 形象的来说：比如说一个人要自学计算机科学知识(sth)，而该领域知识由很多板块的内容(parts)构成，这些内容又相互关联(在学懂A课程前必须有B课程的基础，related)，那么他就面临一个问题，怎么安排学习顺序(路径，arranged)？一个显然不合理的安排是在学习操作系统先于数据结构与算法，因为数据结构与算法是学习OS的前置课程。**一个不违反前置条件的学习路径就是一个拓扑排序，其意义就是得到一条合理的学习路径。**说的更广泛一点，拓扑排序就是得到一个合理的处理顺序。<br />如果我们把各板块内容之间铺垫关系画成一张图，各板块为顶点，有向边作为关联(如 Vertex数据结构与算法指向Vertex操作系统)，那么**拓扑排序在这个图中体现为一条沿着有向边方向的路径**(即路径中任意一段单位路径u到v,不存在边(v,u))<br />显然，**存在拓扑排序的图一定是有向无环图**( directed acyclic graph，DAG),[如果图是有环的，那么就找不到符合要求的路径，因为总会违反前置条件](https://www.quora.com/Why-must-a-graph-with-a-topological-sort-be-acyclic-and-why-must-an-acyclic-graph-have-a-topological-sort)\n<a name=\"yLpq8\"></a>\n### 2. 如何实现拓扑排序算法？怎样使其更高效？\n对于我们要选择的第一个顶点，显然的，它必须没有前置条件，即没有顶点指向它，入度(indegree为0)。我们选择这样一个点，然后**在图中抹去该点和它的边**(显然的，都是由它发出的边，与它相关的顶点入度也随之更新)，在剩下的图中重复这个步骤，直到图为空(如果找不到入度为0的顶点而图不为空，说明图不是DAG，存在环)。顶点被抹去的顺序，就是拓扑排序。<br />如何快速寻找到入度为0的点呢？如果通过遍历顶点集的方式，那么开销是很大的，特别是如果图很稀疏(边很少，sparse)，那么要去除的边也是很少的，因此每一步被影响到入度的顶点的数量也是很少的，即大部分的顶点入度是一直没变的，反复的遍历它们是pointless行为。<br />提升效率方法是**将入度为0的点单独拿出来，我们可以用栈或队列来存储。在每次去掉顶点和边之后，我们将更新后入度变为0的顶点加入到队列中**。显然的，队列的出队顺序就是我们要求的拓扑排序。\n```cpp\n#pragma once\n#include<iostream>\n#include\"Graph.h\"\n#include<queue>\nusing namespace std;\n\nvoid TopologicalSort(Graph& myGraph)\n{ \n\tqueue<vertex*> zero;\n\tint counter = -1;\n\tint N = myGraph.size();\n\n\tfor (auto& iter :myGraph.graph) // initalize vertexSet which indegree is zero\n\t{\n\t\tif (iter.second->ind == 0)\n\t\t\tzero.push(iter.second);\n\t}\n\n\twhile (!zero.empty())\n\t{\n\t\tvertex* v = zero.front();\n\t\tzero.pop();\n\t\tv->seq = ++counter;\n\t\tcout << v->name << ' ';\n\t\tint adjN = v->adj.size();\n\t\tfor (int i = 0; i < adjN; ++i)\n\t\t{\n\t\t\tif (--(v->adj[i].second->ind) == 0)\n\t\t\t\tzero.push(v->adj[i].second);\n\t\t}\n\t}\n\n\tif (counter != N-1)\n\t\tabort();\n}\n```\n<a name=\"Ms2lL\"></a>\n## Shortest-Path Algorithms\n<a name=\"TdCMl\"></a>\n### 1. 什么是单源最短路径问题？\n单源最短路径问题(Single-Source Shortest-Path Problem): **给定一个有权图(weighted graph,可以有环)中的一个点**`**v**`**，求出**`**v**`**到其它所有顶点的最短路径**，that is ,在答案所呈现的结果图中，`v`到结果图中任意一个顶点`w`的路径，其长度是`v`与`w`之间存在的所有路径中，长度最短的那条。<br />也可以从另一个角度理解这个问题，即如果把边长视为开销，那么**该问题就是要以最小的开销，从源顶点开始，覆盖整张图的顶点**\n<a name=\"q5MIP\"></a>\n### 2.为什么Breadth-First Search可以解决Unweighted Shortest-Paths?\n为了理解SSSP问题，我们先考虑无权图，无权图可视为权重为1的有权图<br />我们先设置问题的初始状态：`v`到任意`w`的距离都是无穷大，任意`w`的状态都是unknown(`v`到该`w`的最短路径还未确定)。<br />我们首先能确定的是`v`能直接到达的点(`v`的邻接点)，因为v只有唯一途径能到达这些点，所以这个唯一途径就是最短路径。我们把这些点称为第一层，其最短路径均为1。接着，我们能确定的点显然是第一层的邻接点，**因为**`**v**`**能通过第一层的点去访问只有这些点**，我们把这些点称为第二层，其最短路径自然为2。按照这样的一个广度优先搜索的逻辑，我们便能确定所有点的最短路径。<br />因为是无权图，所以不存在对路径长度的多次更新（关于该点可见后续讨论中的例子：不存在将s->w1->w3更改为s->w2->w3的可能），对每个顶点的处理，只需简单的将其distance信息设置为前一个顶点的distance+1即可。\n```cpp\nvoid Graph::unweighted_Shortest_Path_with_queue(vertex& s)\n{\n\tqueue<vertex*> q;\n\tfor (auto& iter : graph)\n\t\titer.second->dist = INFINITY;\n\ts.dist = 0;\n\tq.push(&s);\n\twhile (!q.empty())\n\t{\n\t\tvertex v = *q.front(); // priority '.' > '*'\n\t\tq.pop(); \n\t\tfor (auto& adjac : v.adj)\n\t\t{\n\t\t\tadjac.second->dist = v.dist + 1; \n\t\t\tadjac.second->path = v.name;\n\t\t\tq.push(adjac.second);\n\t\t}\n\t}\n}\n\nvoid Graph::unweighted_Shortest_Path(vertex& s)\n{\n\tint NUM_VERTICES = size();\n\tfor (auto& iter : graph) \n\t{\n\t\titer.second->dist = INFINITY;\n\t\titer.second->known = false;\n\t}\n\ts.dist = 0;\n\n\tfor (int currDist = 0; currDist < NUM_VERTICES; ++currDist) // double for loops:inefficiency\n\t\tfor (auto& iter : graph) \n\t\t\tif (!iter.second->known && iter.second->dist == currDist)\n\t\t\t{\n\t\t\t\titer.second->known = true;\n\t\t\t\tfor (auto& adjac : (iter.second->adj))\n\t\t\t\t{\n\t\t\t\t\tadjac.second->dist = currDist + 1; // update distance\n\t\t\t\t\tadjac.second->path = iter.second->name;\n\t\t\t\t}\n\t\t\t}\n}\n```\n<a name=\"YjF5L\"></a>\n### 3.为什么Dijkstra Algorithm每一步要选择最近的结点，为什么该算法可以解决Single-Source Weighted？\n与上一问一样，要找到`v`到所有顶点的最短路径，我们总得先知道`v`能到达哪些点。所以我们在用Dijkstra解决SSSP的时候，我们似乎也应该按照这样的结点选择顺序：首先找的是`v`的邻接点，然后再邻接点..... 。但是我们需要注意，**我们实际选择结点的顺序(选择结点即把结点变为known，说明找到了到它的最短路径)，是不断的选取未确定结点中离**`**v**`**距离最近的那一个，而不是像无权图中那样邻接点接着邻接点的广度搜索。**<br />**为什么要选择最近的那一个？**<br />举个最简单的例子：在这个图中，我们首先探索了源顶点的邻接点w1,w2，更新其dist为ds+dcost，那么w1.dist=1，w2.dist =3。那么下一轮我们选择那个顶点进行探索(其邻接点)呢？显然是w1，因为在当前条件下，我们只知道源顶点离w1更近一些，那么到w3(后续未知结点)的最短路径自然更可能的在w1这边(我们还不知道后续顶点的dist信息)。**因此我们在每次选择一个顶点以探索他的邻接点(更新dist信息)，都要选择当前距离v最近的那个，因为经过这样一个点的路径才最有可能是(到后续顶点)最短路径/开销可能最少。**<br />为什么在无权图中不用这样做？<br />无权图的边长权重都为1，开销的是一样的。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1667390674960-21e67dd1-f11c-4336-a168-c237056626fe.jpeg)<br />我们要有一个认知：**源顶点**`**v**`**到某一目标顶点**`**w****t**`**之间的最短路径①上存在着几个中间顶点，那么v到任意一个中间结点**`**w****i**`**的最短路径②一定与①重合。**或者说v到目标顶点的最短路径，是目标顶点在该路径的上一个顶点的最短路径延长了一个边长所得到的。<br />**因此我们逐步找到各顶点的最短路径，并从之前找到的最短路径(以开销最少的方式)延展到其它顶点上，便可以找到到所有顶点的最短路径。**\n```cpp\nvoid Graph::Dijkstra_Algorithm(vertex& s)\n{\n\tfor (auto& iter : graph)\n\t{\n\t\titer.second->dist = INFINITY;\n\t\titer.second->known = false;\n\t}\n\ts.dist = 0;\n\twhile (existUnknown()) //there is an unknown vertex\n\t{\n \t\tvertex* v = smallestUnknown();   // smallest unknown distance vertex\n\t\tv->known = true;\n\t\tfor (auto& iter : v->adj)\n\t\t{\n\t\t\tif (v->dist + iter.first < iter.second->dist) \n\t\t\t{\n\t\t\t\titer.second->dist = v->dist + iter.first; // update\n\t\t\t\titer.second->path = v->name;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool Graph:: existUnknown()\n{\n\tfor (auto& iter : graph)  // iteration \n\t{\n\t\tif (!iter.second->known)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvertex* Graph::smallestUnknown()\n{\n\tvertex* min = graph.begin()->second;\n\tfor (auto& iter : graph)  // iteration \n\t{\n\t\tif (!iter.second->known && iter.second->dist < min->dist)\n\t\t\tmin = iter.second;\n\t}\n\treturn min;\n}\n```\n<a name=\"b4gnk\"></a>\n### 4.为什么Dijkstra Algorithm不适用于有负权值边的图\n在Dijkstra算法中，我们**一旦将一个顶点**`**v**`**由unknown标记为known，就说明由**`**s**`**到**`**v**`**的最短路径已经找到，且不会再改变，即算法不会在后续过程中回头(look back)修改到**`**v**`**的最短路程这一信息**。如果我们用Dijkstra算法在图中确定了`v`的最短路径，然后发现`v`到某个邻接点`u`(状态为unknown)的边权值为负，那么此时`s`到`v`的实际最短路径就发生了变化：s->v->w->v，然而因为Dijkstra算法不会look back，所以算法继续保持之前的最短路径，因此会产生与事实不符的结果。\n<a name=\"wzqMO\"></a>\n## Critical Path Problems\n<a name=\"MCV9V\"></a>\n### 1. 如何理解关键路径？关键路径是什么？\n一个项目由多个可独立完成工作(jobs)组成，各工作之间存在优先级限制关系(precedence constraint)，即某一项工作必须在完成另一项(或多项)工作后才能启动。①如何确定项目的最快(早)完成时间？②如何确定某些工作的可延迟时间 (that is,slack time 松弛时间) 以不至于增加整个项目的完成时间？<br />**关键路径这样一组工作序列：该工作序列可以用来确定项目的最快完成时间。对第二点，关键路径上的所有工作的可延迟时间均为0，关键路径上的任何一个工作被延迟，都会增加整个项目的完成时间，这也是为什么称之为\"关键\"。**<br />这样的项目可以体现在有向无环图中。为什么一定是无环？与拓扑排序一样的道理，如果有几个工作成环状相互制约，那就无法开启任何一项工作，因为总是违反其优先级限制关系。**关键路径在这样的图中体现为从开始到结束的最长路径(longest path)**<br />注意路径的长度由边的权值(工作完成所需时间)决定而不是边的数量\n<a name=\"oj5FV\"></a>\n### 2. 为什么图的最长路径就是关键路径？\n> 关键路径是通过识别最长的相关活动并测量从开始到结束完成它们所需的时间来确定的 -wikipedia\n\n我们首先要理解一条路径上的各个工作节点之间存在着严格的先后关系，即优先级限制关系。这就说明**各工作只能串行的执行**，哪怕你有很多处理器(processors)也必须等待高优先级的工作执行完毕后再开启新的工作。互不关联(不在同一路径)的工作可以并行的执行，所以**在最长路径上的最后一个工作执行完毕时，其它路径也一定执行完毕，即整个项目执行完毕。因此最长路径决定了项目的完成时间，不延迟的执行最长路径(上的工作)所花的时间，就是项目的最快完成时间。**\n<a name=\"Aa03a\"></a>\n## Network Flow Problems\n<a name=\"RBuq3\"></a>\n### 1. 如何理解网络流问题？\n网络流问题就是从一个端`s`往另一个端`t`发送流(Flow,如通水，运货，发送数据包等)，要经过数个中间节点，各节点间的边的传输容量是有限的(如水管的阈值，超过了这个值水管会破裂)，问从s发送到t的最大流(the maximum amount of ﬂow)是多少。显然的要找出这个最大流，**我们要解决的根本问题是如何正确安排运输方案(即路径选择)以最大化流**。<br />**如何计算图中流的数量(the amount of ﬂow)？** **只需看从端**`**s**`**发出了多少流即可**(端`t`肯定接受同样数量的流，除非“漏水”了)<br />**怎么验证我们得到的流的数量是最大的？**把图分割(cut)为两个部分，一部分包含s，另一部分包含t(其余结点随意，因此存在多种切割方式)，**经过切割线上的边的容量总和决定了最大流的界限，容量总和的最小值即为图所能承受的最大流的值(the minimum cut capacity is exactly equal to the maximum ﬂow)**<br />由此我们可以看出，**解决最大流问题的目的不是为了得到最大流的值，而是知道能达到最大流的运输方案**<br />[**网络流问题基础 Network Flow Problems**](https://www.youtube.com/watch?v=6DFWUgV5Osc&list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&index=8)\n<a name=\"LytbY\"></a>\n### 2. 如何得到最大流？\n首先考虑简单的算法(naive algorithm )，我们随机的选择路径( free to choose any path from s to t)，直到Gr中不存在s到t的路径，看能否得到最大流，事实证明，这样是不可靠的，得到的方案可能会使我们会得到一个小于最大流的值。**该方法存在的缺陷是，一旦在某一步选中了错误的路径(不属于最大流方案的路径)，算法无法纠正错误，因此找不到最大流。**<br />我们改进一下这个算法，**在每次进行一次路径选择(即在G****r****图中相应边执行了减法)之后，接着在相应边上加上一条方向相反的边，其权值就等于刚刚该边减去的值。称为Ford–Fulkerson algorithm**<br />**这样做的目的，是让算法有了撤销(undo)的能力，可以把不好的路径撤销掉，因此该算法总能找到正确的路径，进而找到最大流。**<br />[**Ford-Fulkerson Algorithm 寻找网络最大流  -Dr Wang **](https://www.youtube.com/watch?v=8sLON0DqLZo&list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&index=9)\n\n\n","slug":"D_A_C++","published":1,"updated":"2023-03-28T01:10:33.866Z","_id":"clfqu81jy0003vymo73rohact","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n<a name=\"qIfKY\"></a>\n<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h1>\n<p>以下记录了我2022年暑假开始学习数据结构的历程。从哈希表到图论，有着详细的思考过程。</p>\n<span id=\"more\"></span>\n<hr>\n<p><a name=\"Aq9ue\"></a></p>\n<h1 id=\"chapter-1-listsstacks-and-queues\"><a class=\"markdownIt-Anchor\" href=\"#chapter-1-listsstacks-and-queues\"></a> Chapter 1 Lists,Stacks and Queues</h1>\n<p><a name=\"csZFb\"></a></p>\n<h3 id=\"1-对自制vector容器添加错误检查能力\"><a class=\"markdownIt-Anchor\" href=\"#1-对自制vector容器添加错误检查能力\"></a> 1. 对自制vector容器添加错误检查能力</h3>\n<blockquote>\n<p>访问vector容器，可能会出现的错误的迭代器操作主要有两种</p>\n<ol>\n<li>错误的访存操作：迭代器未初始化，执行<code>*</code>操作</li>\n<li>迭代器超出容器边界：迭代器在末尾执行<code>++iter/iter++</code>操作</li>\n</ol>\n</blockquote>\n<p>另外，迭代器还会出现如<code>7</code>所述的失效的情况</p>\n<p><a name=\"kxJtb\"></a></p>\n<h4 id=\"1处理错误操作在重载运算符和时检查current的值\"><a class=\"markdownIt-Anchor\" href=\"#1处理错误操作在重载运算符和时检查current的值\"></a> 1.处理错误操作：在重载运算符<code>*</code>和<code>++</code>时检查current的值</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object <span class=\"keyword\">operator</span> *()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (const_iterator::current == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// Check boundary</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Error: iterator is NULL!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *(const_iterator::current);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">iterator&amp; <span class=\"keyword\">operator</span> ++ ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (const_iterator::current == objects[theSize<span class=\"number\">-1</span>]) <span class=\"comment\">// Error:Cannot access objects</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Error: iterator is end!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t    <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconst_iterator::current++;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iterator类与const_iterator类作为vector模板类的嵌套类，访问外部类的私有成员<code>objects</code>与<code>theSize</code>是一件比较困难的事情 <a href=\"https://stackoverflow.com/questions/486099/can-inner-classes-access-private-variables\">StackOverFlow：Can inner classes access private variables?</a></p>\n<blockquote>\n<p>嵌套类与外部类之间没有访问特权</p>\n</blockquote>\n<p><a name=\"hHyA9\"></a></p>\n<h4 id=\"2处理失效的迭代器给迭代器添加一个数据成员用于指向当前表用一个函数用于判断迭代器是否指向正确的表-当发生扩容时原有的thevector指向的空间被释放-thevector-null感觉有点问题\"><a class=\"markdownIt-Anchor\" href=\"#2处理失效的迭代器给迭代器添加一个数据成员用于指向当前表用一个函数用于判断迭代器是否指向正确的表-当发生扩容时原有的thevector指向的空间被释放-thevector-null感觉有点问题\"></a> 2.处理失效的迭代器：给迭代器添加一个数据成员用于指向当前表，用一个函数用于判断迭代器是否指向正确的表。当发生扩容时，原有的theVector指向的空间被释放。（<code>theVector == NULL</code>感觉有点问题）</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">const_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    Object* current;</span><br><span class=\"line\">    <span class=\"type\">const</span> vector&lt;Object&gt;* theVector;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertIsValid</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(current == <span class=\"literal\">NULL</span> || theVector == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"string\">&quot;IteratorOutOfbounds&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"fgUkk\"></a></p>\n<h3 id=\"2-搜寻链表的注意点\"><a class=\"markdownIt-Anchor\" href=\"#2-搜寻链表的注意点\"></a> 2. 搜寻链表的注意点</h3>\n<p>在链表搜寻值为x的节点时，显然需要保存两个节点的信息：当前节点<code>current</code>和上一个节点<code>foreCurrent</code>,要注意对这两个值不同的初始化，搜寻的条件也不同。有以下两种模式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current = head-&gt;next</span><br><span class=\"line\">foreCurrent = head;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (current &amp;&amp; current-&gt;data != x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    foreCurrent = current;</span><br><span class=\"line\">    current = current-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node* current = head; <span class=\"comment\">// Initially nullptr</span></span><br><span class=\"line\">Node* foreCurrent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (current-&gt;next!= <span class=\"literal\">nullptr</span> &amp;&amp; current-&gt;data != x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tforeCurrent = current;</span><br><span class=\"line\">\tcurrent = current-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：混淆这两种模式将出现访存错误，如以下情况</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node* current = head-&gt;next;</span><br><span class=\"line\">Node* foreCurrent = head;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (current-&gt;next!= <span class=\"literal\">nullptr</span> &amp;&amp; current-&gt;data != x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tforeCurrent = current;</span><br><span class=\"line\">\tcurrent = current-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样会出现的问题是：当链表中仅有一个头节点时，初始<code>current=head-&gt;next</code>值为<code>nullptr</code>，第3行的<code>current-&gt;next</code>将执行失败（实现iterator类后，尽可能的使用该类，该类不存在以上问题）<br>\n<a name=\"hF7j1\"></a></p>\n<h3 id=\"3平衡符号\"><a class=\"markdownIt-Anchor\" href=\"#3平衡符号\"></a> 3.平衡符号</h3>\n<p>创建一个空栈后读取文件，当读取到开放字符<code>(,&#123;,[,/*</code>时压入栈，当读取到封闭字符<code>),&#125;,],*/</code>时从栈顶弹出字符。</p>\n<blockquote>\n<ol>\n<li>读取到封闭字符时，栈为空，则封闭字符不匹配，报错</li>\n<li>弹出的字符与封闭字符不匹配，报错</li>\n<li>读取到文件尾后，栈不为空，则开放字符不匹配，报错</li>\n</ol>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">balSymbol</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> current, prev;</span><br><span class=\"line\">\t<span class=\"function\">string <span class=\"title\">left</span><span class=\"params\">(<span class=\"string\">&quot;&#123;[(*&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">string <span class=\"title\">right</span><span class=\"params\">(<span class=\"string\">&quot;&#125;])&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">ifstream <span class=\"title\">iFile</span><span class=\"params\">(<span class=\"string\">&quot;3_21Sample.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">char</span>&gt; check;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">is_open</span>())</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\tiFile &gt;&gt; current;</span><br><span class=\"line\">\tprev = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!iFile.<span class=\"built_in\">eof</span>())</span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// push open symbol in stack</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (left.<span class=\"built_in\">find</span>(current) != string::npos) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(current !=<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; prev == <span class=\"string\">&#x27;/&#x27;</span>) <span class=\"comment\">// push in &#x27;/*&#x27;</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">push</span>(prev);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// no push action for current ==&#x27;*&#x27; prev !=&#x27;/&#x27;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If it is a closed symbol and stack is not empty, the corresponding symbol will pop up</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; prev == <span class=\"string\">&#x27;*&#x27;</span>) <span class=\"comment\">// special for &#x27;/&#x27;,&#x27;/&#x27; can be left or right</span></span><br><span class=\"line\">\t\t&#123; <span class=\"comment\">// for &#x27;*/&#x27;,no action for current ==&#x27;/&#x27; and stack is empty (/*....),</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(check.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//last mismatch closed symbol is a speical situation, which can not belong to error:eof()</span></span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; <span class=\"string\">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right.<span class=\"built_in\">find</span>(current) != string::npos)   <span class=\"comment\">// for (]&#125;</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (check.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// prevent top() error</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//last mismatch closed symbol is a speical situation, which can not belong to error:eof()</span></span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; <span class=\"string\">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;&#123;&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;[&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>; <span class=\"comment\">// error: top stack symbol mismatch → eof() is false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tprev = current;</span><br><span class=\"line\">\t\tiFile &gt;&gt; current; <span class=\"comment\">// read next character in buffer</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// judge</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">eof</span>() )</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!check.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;open symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Successful!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"JdH6s\"></a></p>\n<h3 id=\"4-中缀表达式转后缀表达式\"><a class=\"markdownIt-Anchor\" href=\"#4-中缀表达式转后缀表达式\"></a> 4. 中缀表达式转后缀表达式</h3>\n<p>1.为什么在向栈中压入运算符时，要先弹出优先级更高的运算符</p>\n<blockquote>\n<p>运算符的出栈顺序代表了运算符的执行顺序。显然的，优先级更高的运算符最先打印并出栈，即在后缀表达式中代表最早参与运算</p>\n</blockquote>\n<p>2.为什么直到碰到右括号<code>)</code>之前，不弹出左括号<code>(</code>，遇到右括号<code>)</code>后,弹出栈元素直到遇到<code>(</code></p>\n<blockquote>\n<p>该操作的意思是弹出括号内的所有运算符，显然的，括号内的各运算符优先级高于括号外的运算符</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">infixToPostFix</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">ifstream <span class=\"title\">iFile</span><span class=\"params\">(<span class=\"string\">&quot;3_23Sample.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">is_open</span>())</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\tstring operators = <span class=\"string\">&quot;()+-/*&quot;</span>;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">char</span>&gt;keepOptors;</span><br><span class=\"line\">\t<span class=\"type\">char</span> current;</span><br><span class=\"line\">\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!iFile.<span class=\"built_in\">eof</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (operators.<span class=\"built_in\">find</span>(current) != string::npos)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (keepOptors.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// initial</span></span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (operators.<span class=\"built_in\">find</span>(keepOptors.<span class=\"built_in\">top</span>(), <span class=\"number\">2</span>)!= string::npos) <span class=\"comment\">//top item is +, -,* or /</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>()&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (keepOptors.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(current ==<span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (operators.<span class=\"built_in\">find</span>(keepOptors.<span class=\"built_in\">top</span>(), <span class=\"number\">3</span>)) <span class=\"comment\">//top item is -,* or /</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>()&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (keepOptors.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;*&#x27;</span> || current == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;)&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (keepOptors.<span class=\"built_in\">top</span>() != <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>()&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// pop up &#x27;(&#x27;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tcout &lt;&lt; current &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!keepOptors.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>() &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"Kvu8h\"></a></p>\n<h3 id=\"5-后缀表达式转中缀表达式\"><a class=\"markdownIt-Anchor\" href=\"#5-后缀表达式转中缀表达式\"></a> 5. 后缀表达式转中缀表达式</h3>\n<p>想法与计算后缀表达式差不多，注意两个地方</p>\n<blockquote>\n<p>1.优先参与运算的运算符的运算结果是下一个运算符的操作数，想想怎么把表达式连接成一个整体<br>\n2.为每个计算式加上括号，确保在最终的中缀表达式中能清晰的表达计算顺序，如 8<em>5+3 与 (8</em>(5+3))</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postfixToInfix</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tstack&lt;string&gt; expr;</span><br><span class=\"line\">\t<span class=\"function\">ifstream <span class=\"title\">iFile</span><span class=\"params\">(<span class=\"string\">&quot;3_22Sample.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">is_open</span>())</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\tstring first, second;</span><br><span class=\"line\">\t<span class=\"type\">char</span> current;</span><br><span class=\"line\">\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!iFile.<span class=\"built_in\">eof</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"number\">48</span> &lt;= current &amp;&amp; current &lt;= <span class=\"number\">57</span>)</span><br><span class=\"line\">\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"built_in\">string</span>(<span class=\"number\">1</span>,current));</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfirst = expr.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\t\texpr.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\tsecond = expr.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\t\texpr.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span>+first + <span class=\"string\">&#x27;*&#x27;</span>+second+<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span>+first +<span class=\"string\">&#x27;/&#x27;</span>+ second + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span> + first + <span class=\"string\">&#x27;+&#x27;</span> + second + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span> + first + <span class=\"string\">&#x27;-&#x27;</span> + second + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; expr.<span class=\"built_in\">top</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"OSFAk\"></a></p>\n<h3 id=\"6-逆向打印链表的两个方法\"><a class=\"markdownIt-Anchor\" href=\"#6-逆向打印链表的两个方法\"></a> 6. 逆向打印链表的两个方法</h3>\n<p><a name=\"UuJnf\"></a></p>\n<h4 id=\"1链表反转\"><a class=\"markdownIt-Anchor\" href=\"#1链表反转\"></a> 1.链表反转</h4>\n<p>改变单向链表的结构，反转其方向。需要用到三个结点的信息<code>prev、current、next</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Reverse_List</span><span class=\"params\">()</span>  <span class=\"comment\">// O(1)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* prev, *current, *cNext;</span><br><span class=\"line\">\t\tprev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\tcurrent = head-&gt;next;</span><br><span class=\"line\">\t\tcNext = current-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cNext != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcurrent-&gt;next = prev; <span class=\"comment\">// reverse direction</span></span><br><span class=\"line\">\t\t\tprev = current;</span><br><span class=\"line\">\t\t\tcurrent = cNext;</span><br><span class=\"line\">\t\t\tcNext = current-&gt;next; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcurrent-&gt;next = prev;</span><br><span class=\"line\">\t\thead-&gt;next = current; <span class=\"comment\">// head to tail</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; current-&gt;value &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\tcurrent = current-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意同时声明多个指针时，不能写成<code>Node* prev, current, cNext</code>，这种声明下<code>current、cNext</code>是int型，只有一个<code>prev</code>是指针类型。应改为<code>Node* prev, *current, *cNext;</code></p>\n</blockquote>\n<p><a name=\"aAKjU\"></a></p>\n<h4 id=\"2利用栈\"><a class=\"markdownIt-Anchor\" href=\"#2利用栈\"></a> 2.利用栈</h4>\n<p>逆向打印可以利用栈先进后出的性质实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Reverse_Print_With_Stack</span><span class=\"params\">()</span> <span class=\"comment\">//  O(N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stack&lt;T&gt; storage;</span><br><span class=\"line\">    Node* p = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        storage.<span class=\"built_in\">push</span>(p-&gt;value);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!storage.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; storage.<span class=\"built_in\">top</span>() &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        storage.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"QwIKh\"></a></p>\n<h3 id=\"7-环形缓冲区的满vs空问题\"><a class=\"markdownIt-Anchor\" href=\"#7-环形缓冲区的满vs空问题\"></a> 7. 环形缓冲区的满vs空问题</h3>\n<p>用<strong>数组</strong>实现队列通常有两种方式</p>\n<ol>\n<li>head 指向队列头，即第一个元素，tail 指向新元素即将插入的位置，即最后一个元素的下一个位置，enque后tail+1 (初始状态：head = tail = 0)</li>\n<li>head 指向队列头，tail指向最后一个元素，enque前tail+1 （初始状态：front = 0 , tail = -1）</li>\n</ol>\n<p>两种情况下，均要保持队列最后一个元素不能使用，(n-1) 长度队列可以用长度为 n 的数组创建</p>\n<ol>\n<li>\n<br>\n</li>\n</ol>\n<p>empty：<code>head = tail  </code><br>full：<code>head = (tail+1) % maxSize</code>  <br>如果完全填充数组，那么会导致full和empty情况下，均满足<code>head = tail </code></p>\n<ol start=\"2\">\n<li>\n<br>\n</li>\n</ol>\n<p>empty : <code>head = (tail+1) % maxSize</code>  <br>full：<code>head = (tail+2) % maxSize</code> ？<br>如果完全填充数组，那么会导致full和empty情况下,均满足<code>head = (tail+1) % maxSize</code><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1660033289402-7374663e-99df-4e23-8d39-2bcb71e5622a.png\" alt=\"image.png\"><br>\n<a name=\"mDKbV\"></a></p>\n<h3 id=\"8-判断链表是否有环的两个方法\"><a class=\"markdownIt-Anchor\" href=\"#8-判断链表是否有环的两个方法\"></a> 8. 判断链表是否有环的两个方法</h3>\n<blockquote>\n<ol>\n<li>用<code>hashset</code>存储遍历过的节点，用新节点对比，有重复则存在环</li>\n<li>双指针遍历，速度不同，相遇则存在环</li>\n</ol>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">detectloop</span><span class=\"params\">(Node&lt;T&gt;* head)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode&lt;T&gt;* first, * second;</span><br><span class=\"line\">\t\tfirst = second = head;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*A walks faster than B, so only A is judged.</span></span><br><span class=\"line\"><span class=\"comment\">\t\tIf A is the last node, you need to judge A-&gt;next*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (first != <span class=\"literal\">nullptr</span> &amp;&amp; first-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfirst = first-&gt;next-&gt;next; <span class=\"comment\">// two step</span></span><br><span class=\"line\">\t\t\tsecond = second-&gt;next; <span class=\"comment\">// one step</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (first == second)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; <span class=\"string\">&quot;exist loop&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;no loop&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>涉及的算法：<a href=\"https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/\">Floyd’s Cycle Finding Algorithm</a></p>\n</blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/31401474\">知乎：如何判断链表有环</a><br><a href=\"https://leetcode.com/problems/linked-list-cycle/discuss/1829489/C%2B%2B-oror-Easy-To-Understand-oror-2-Pointer-oror-Fast-and-Slow\">LeetCode：Linked List Cycle</a><br>\n<a name=\"qdbBD\"></a></p>\n<h2 id=\"other-questions\"><a class=\"markdownIt-Anchor\" href=\"#other-questions\"></a> other questions：</h2>\n<ol>\n<li><strong>stackoverflow示例中总是出现的foo ，bar 是什么意思</strong></li>\n</ol>\n<p>foo：File or Object，文件或对象。它用于代替对象变量或文件名，用于代码演示<br>bar：与foo的作用一样，表示变量或文件，用于代码演示2.VS2019调出监视窗口的办法</p>\n<ol start=\"2\">\n<li><strong>vs2019中调式调出监视窗口</strong></li>\n</ol>\n<p>设置断点，运行程序<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1658310883417-a80aaf32-ea48-40bb-b554-2c6d8960689b.png\" alt=\"屏幕截图 2022-07-20 175431.png\"></p>\n<ol start=\"3\">\n<li><strong>git上传项目到github</strong></li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/369486197\">知乎：github基础教学</a><br>\n<a name=\"IthCG\"></a></p>\n<h2 id=\"remaining-problem\"><a class=\"markdownIt-Anchor\" href=\"#remaining-problem\"></a> remaining problem</h2>\n<ol>\n<li><strong>在vector中实现erase(iterator pos)</strong></li>\n</ol>\n<p>涉及萃取</p>\n<ol start=\"2\">\n<li><strong>实现能够指定容器的stack类</strong></li>\n<li><strong>STL stack: emplace() vs push()</strong></li>\n</ol>\n<p>涉及右值引用，移动构造(?)</p>\n<ol start=\"4\">\n<li><strong>判断链表是否有环，为什么不直接判断最后一个节点指向是否为nullptr</strong></li>\n</ol>\n<p>我认为可能的原因：当最后一个节点指向本身时，其next也不为nullptr，而此时单链表中不存在环，所以该方法不适用。</p>\n<hr>\n<p><a name=\"oX3jS\"></a></p>\n<h1 id=\"chapter-2-trees\"><a class=\"markdownIt-Anchor\" href=\"#chapter-2-trees\"></a> Chapter 2 Trees</h1>\n<p><a name=\"JBUuP\"></a></p>\n<h2 id=\"record\"><a class=\"markdownIt-Anchor\" href=\"#record\"></a> record:</h2>\n<p><a name=\"oEiO6\"></a></p>\n<h3 id=\"1-二叉查找树类中为什么要额外添加功能与公有函数相同但参数不同的同名私有函数\"><a class=\"markdownIt-Anchor\" href=\"#1-二叉查找树类中为什么要额外添加功能与公有函数相同但参数不同的同名私有函数\"></a> 1. 二叉查找树类中为什么要额外添加功能与公有函数相同，但参数不同的同名私有函数</h3>\n<p>在类外调用公有函数，而公有函数内部需要递归处理左右子树，需要传入新的根节点，所以需要有额外的能传入根节点参数的函数，因为这类函数只被公有函数所使用，所以设置为私有（辅助函数）<br><a href=\"https://stackoverflow.com/questions/4505938/when-why-to-make-function-private-in-class\">stackoverflow：When/why to make function private in class?</a><br>\n<a name=\"DpaEu\"></a></p>\n<h3 id=\"2搜索二叉树的insert成员函数结点指针t必须引用传递的原因\"><a class=\"markdownIt-Anchor\" href=\"#2搜索二叉树的insert成员函数结点指针t必须引用传递的原因\"></a> 2.搜索二叉树的insert成员函数结点指针t必须引用传递的原因</h3>\n<p>如果采用值传递，那么函数insert中的指针将是实参的副本，在函数insert中修改该副本，不能达到修改结点p的成员变量left or right的目的, remove函数同理<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1661568230165-1e7336ea-23dc-443d-afa4-e35e7a5a4058.jpeg\" alt><br>\n<a name=\"WEgNR\"></a></p>\n<h3 id=\"3-平衡二叉树\"><a class=\"markdownIt-Anchor\" href=\"#3-平衡二叉树\"></a> 3. 平衡二叉树</h3>\n<p>对BST的find操作，其运行时间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(d)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>为结点的深度。给定一系列值，不同的插入序列对应不同的树结构，有着不同的平均结点深度，进而有不同的查找效率。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1661156478689-efe3aeff-b060-4bc9-80ee-099b96f5aa02.png\" alt=\"image.png\"><br>创建高度为h的AVL树所需的最少结点数为斐波那契数列第h+2项的值减1（高度和项数均从0计数）<br>\n<a name=\"FZLgt\"></a></p>\n<h2 id=\"remaining-problem-2\"><a class=\"markdownIt-Anchor\" href=\"#remaining-problem-2\"></a> remaining problem</h2>\n<p><a name=\"Le4pv\"></a></p>\n<h3 id=\"1-给定一系列值确定构造bst的方法个数\"><a class=\"markdownIt-Anchor\" href=\"#1-给定一系列值确定构造bst的方法个数\"></a> 1. 给定一系列值，确定构造BST的方法个数</h3>\n<p><a href=\"https://stackoverflow.com/questions/17119116/how-many-ways-can-you-insert-a-series-of-values-into-a-bst-to-form-a-specific-tr\">stackoverflow：How many ways can you insert a series of values into a BST to form a specific tree?</a></p>\n<hr>\n<p><a name=\"Cieup\"></a></p>\n<h1 id=\"chapter-3-hashing\"><a class=\"markdownIt-Anchor\" href=\"#chapter-3-hashing\"></a> Chapter 3 Hashing</h1>\n<p><a name=\"RQFF9\"></a></p>\n<h2 id=\"1-为什么哈希表只能惰性删除lazy-deletion\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么哈希表只能惰性删除lazy-deletion\"></a> 1. 为什么哈希表只能惰性删除(lazy deletion)</h2>\n<p>答：在插入其它元素A时，A可能与待删除元素B发生过冲突(collision),即可能有<code>myhash(A) == myhash(B)</code>,也可能是A在向前探测的过程中与B发生过冲突。 如果删除元素B，那么在寻找A就会失败，因为此时B所在的位置是EMPTY，那么findPos(A)在B的位置上会返回currentPos,查找结束，但currentPos是EMPTY而不是A所在的值。<br>\n<a name=\"mwjke\"></a></p>\n<h2 id=\"2-为什么要有哈希表是怎么达到高效性的\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么要有哈希表是怎么达到高效性的\"></a> 2. 为什么要有哈希表？是怎么达到高效性的？</h2>\n<p>为了在<strong>常数时间</strong>内高效实现对数据的插入，删除，查找操作。 通过<strong>哈希函数</strong>（通常是 <code>hash(x) % tableSize</code>,<code>hash(x)</code>的作用是将x转化为数字，由key类提供，如果x本身就是数字，那么hash(x) = x），让待插入数据<strong>直接定位</strong>到哈希表中的一个位置（哈希表是什么？ 一个固定大小的存储项的数组， 哈希 = 散列）<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1664794253808-1aee7326-a1c4-44c2-986e-5ca40efa4d87.jpeg\" alt><br>\n<a name=\"Hcjq3\"></a></p>\n<h2 id=\"3-冲突collision是什么怎么解决冲突的\"><a class=\"markdownIt-Anchor\" href=\"#3-冲突collision是什么怎么解决冲突的\"></a> 3. 冲突(collision)是什么？怎么解决冲突的？</h2>\n<p>不同的数据可能会被哈希函数映射到相同的位置，而一个位置只能属于一个数据，因此产生了冲突。为解决冲突，很简单是想法就是：<strong>既然原本属于它的位置被占用了，那就将数据移到可以存放的空位置</strong><br>如何找到这个空位置呢？有两种方法</p>\n<ol>\n<li><strong>分离链接法（separate chaining）:</strong></li>\n</ol>\n<p>既然冲突是因为一个位置只能存放一个数据，那么引入链表以实现一个位置能够存放多个数据，冲突便解决了。哈希表中的一个位置对应一条链表，显然的，在某个位置发生的冲突越多，那么这条链表就越长。无论是执行查找还是删除操作，都要先找到链表（由哈希函数得到），再在链表里面找到数据。</p>\n<ol start=\"2\">\n<li><strong>开放定址法（open addressing）：</strong></li>\n</ol>\n<p>往前探测（probe），形式化为公式就是<code>hashi(x) = (hash(x) + f(i))</code>,<strong>i表示向前探测的次数</strong>，f(i)称为冲突解决策略（collision resolution strategy）,显然<code>f(0)=0</code>。根据f(i)形式的不同，分为线性(Linear)探测:<code>f(i)=i</code>、平方(quadratic)探测:<code>f(i) = i2</code>、双(double)散列:<code>f(i) = i*hash2(x)</code><br>**线性探测会引起一次聚集（<strong>primary cluster</strong>），平方探测会引起二次聚集（<strong>Secondary Clustering</strong>），**关于这一点：<a href=\"https://stackoverflow.com/questions/27742285/what-is-primary-and-secondary-clustering-in-hash\">stackoverflow：What is primary and secondary clustering in hash?</a> 说的很清楚<br>为什么一次聚集对性能的影响会比二次聚集更大呢？首先要知道，聚集之所以会影响性能，是因为聚集导致hashPos之后的位置大部分被占用，进而导致探测次数增加。一次聚集是无间隔的聚集，那么只要在这堆聚集的项中发生了冲突，就基本上要一步一步的探测完所有聚集项才能找到空位置。而二次聚集是有间隔的，一次两步的探测会减少探测的发生。这个具体的描述比较困难，但是很好想。<br>双散列，消除了聚集问题，它应用了另一个哈希函数<code>hash2(x)</code>（<strong>哈希结果不能为0，则f(i)将失去意义</strong>），使得探测更趋于随机化，而不是集中在哈希位置附近。<br>注意点：</p>\n<ul>\n<li>哈希表的**大小(tableSize)为素数(Prime)**能更好的减少冲突的发生</li>\n<li><strong>tableSize为素数且λ&lt;0.5</strong>（有一半以上空项）时平方探测能保证插入成功。否则甚至不如线性探测，因为插入可能会失败（书上有证明）</li>\n<li>当计算哈希值代价较高时，性能角度上，双散列较之平方探测不是一个更好的选择</li>\n</ul>\n<p><strong>两个方法的对比：</strong> 前者不如后者，因为分离链表法会因为插入而分配新内存，这将降低执行效率；其次，分离链表法等于是哈希表与链表的结合，等于要求实现了另一种数据结构(而不是哈希表)，提高了程序的复杂性</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findPos</span><span class=\"params\">(<span class=\"type\">const</span> hashedObj&amp; x)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> currentPos = <span class=\"built_in\">myhash</span>(x);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> offset = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (array[currentPos].info != Empty &amp;&amp; array[currentPos].element != x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcurrentPos += offset;</span><br><span class=\"line\">\t\t\toffset = <span class=\"built_in\">pow</span>(offset,<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (currentPos &gt;= array.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t\t\t\tcurrentPos -= array.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> currentPos;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"vpuOb\"></a></p>\n<h2 id=\"4-为什么要再散列rehashing再散列要怎么做\"><a class=\"markdownIt-Anchor\" href=\"#4-为什么要再散列rehashing再散列要怎么做\"></a> 4. 为什么要再散列(rehashing)？再散列要怎么做？</h2>\n<p>当哈希表过于满(too full，λ too big)，查找操作将会变得非常缓慢（如之前所说，探测次数会非常多），进而影响插入和删除操作。解决这个困境的办法就是扩大哈希表以降低λ。<br>做法是：创建一个表长为大于2倍当前长度的第一个素数的新表（如当前长度是7，扩大后为17），相应的也产生了新的哈希函数，接着把原表中的所有数据通过新的哈希函数映射到新表中。<br>怎么界定哈希表是否需要再散列，一个好的方法是：当λ到达某个界定值时</p>\n<hr>\n<p><a name=\"OulqF\"></a></p>\n<h1 id=\"chapter-4-heap\"><a class=\"markdownIt-Anchor\" href=\"#chapter-4-heap\"></a> Chapter 4 Heap</h1>\n<p><a name=\"KirP0\"></a></p>\n<h2 id=\"1-为什么要有二叉堆binary-heap-是怎么达到高效的\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么要有二叉堆binary-heap-是怎么达到高效的\"></a> 1. 为什么要有二叉堆(Binary Heap)? 是怎么达到高效的？</h2>\n<p>为了实现<strong>优先级队列(priority queue)</strong>，即根据不同对象间的优先级排列而形成的队列，如操作系统中进程的优先级队列。相比于用队列(Queue)实现的根据对象到来的时间属性而确定优先级队列(即First Come First Served), 我们希望有一种数据结构，它有着更加灵活的优先级批判标准，而不是只看任务的到达时间。不仅如此，为了高效性，我们希望这个数据结构能够快速的找出队列中优先级最大的那一个。<br>由此我们引出二叉堆，二叉堆是一个**底层为数组的完全二叉树(complete binary tree)，**有结构性质和堆序性质<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1665135196819-0f05c687-059e-4b79-9c73-9c31e16de204.png\" alt=\"image.png\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> Comparable&amp; x)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (heapSize == array.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tarray.<span class=\"built_in\">resize</span>(array.<span class=\"built_in\">size</span>() * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> hole = ++heapSize;</span><br><span class=\"line\">\t\tComparable copy = x;</span><br><span class=\"line\">\t\tarray[<span class=\"number\">0</span>] = std::<span class=\"built_in\">move</span>(copy);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; x &lt; array[hole / <span class=\"number\">2</span>]; hole /= <span class=\"number\">2</span>)  <span class=\"comment\">// percolate up</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tarray[hole] = std::<span class=\"built_in\">move</span>(array[hole / <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarray[hole] = std::<span class=\"built_in\">move</span>(array[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteMin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\thole = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tComparable x = std::<span class=\"built_in\">move</span>(array[heapSize--]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; hole &lt;= heapSize; hole*=<span class=\"number\">2</span>) <span class=\"comment\">// percolate down</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchild = <span class=\"number\">2</span> * hole;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child != heapSize &amp;&amp; array[child] &lt; array[child + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t\t++child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x &gt; array[child])</span><br><span class=\"line\">\t\t\t\tarray[hole] = std::<span class=\"built_in\">move</span>(array[child]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarray[hole] = std::<span class=\"built_in\">move</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = heapSize / <span class=\"number\">2</span>; i &gt; <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">percolateDown</span>(i);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a name=\"eHZpk\"></a></p>\n<h1 id=\"chapter-5-sorting\"><a class=\"markdownIt-Anchor\" href=\"#chapter-5-sorting\"></a> Chapter 5 Sorting</h1>\n<p><a name=\"SWGCy\"></a></p>\n<h2 id=\"insertion_sort\"><a class=\"markdownIt-Anchor\" href=\"#insertion_sort\"></a> Insertion_Sort</h2>\n<p><a name=\"Hw7N9\"></a></p>\n<h3 id=\"1-怎么插入的为什么结果能有序\"><a class=\"markdownIt-Anchor\" href=\"#1-怎么插入的为什么结果能有序\"></a> 1. 怎么插入的？为什么结果能有序？</h3>\n<p>对序列(Comparable)，假定第一个数据(array[0])是有序的，把从第二项到末尾的数据逐个插入到开头的有序序列中。<br>怎么插入的？将待插入项<code>tmp</code>与有序序列中的项逐个比较，遇到<code>array[i]&gt;tmp</code>(升序序列)，则将有序序列中的元素右移，为<code>tmp</code>提供插入位，接着插入<code>tmp</code>。等价于将位置为p的项放入前p+1项(从0开始索引)的正确位置(从小到大)。如果数组本身就比较有序，那么可以省去不少插入操作<br>为什么能有序？ straightforward，我觉得有些许减治法的感觉，先解决小问题，逐步解决大问题。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(std::vector&lt;Comparable&gt;&amp; array)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = array.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt; N; ++p)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tComparable tmp = std::<span class=\"built_in\">move</span>(array[p]);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = p - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; tmp &lt; array[j]; --j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tarray[j + <span class=\"number\">1</span>] = std::<span class=\"built_in\">move</span>(array[j]); <span class=\"comment\">// j move right, p move left</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarray[j + <span class=\"number\">1</span>] = std::<span class=\"built_in\">move</span>(tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a name=\"AXqXN\"></a></p>\n<h2 id=\"shell_sort\"><a class=\"markdownIt-Anchor\" href=\"#shell_sort\"></a> Shell_Sort</h2>\n<p><a name=\"NvzxL\"></a></p>\n<h3 id=\"1-为什么说希尔排序涉及了插入排序\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么说希尔排序涉及了插入排序\"></a> 1. 为什么说希尔排序涉及了插入排序？</h3>\n<p>因为希尔排序先将序列分组，然后在组内进行插入排序<br>\n<a name=\"rqY4s\"></a></p>\n<h3 id=\"2-希尔排序是如何分组的\"><a class=\"markdownIt-Anchor\" href=\"#2-希尔排序是如何分组的\"></a> 2. 希尔排序是如何分组的？</h3>\n<p>使用一组增量h1，h2，h3， . . . , ht(就是代表了不同的跨度，h1 =1)。第一阶段，对任意位置i，把array[i]，array[i+ht]，array[i+2ht]…分为一组执行插入排序；第二阶段，对任意位置i，把array[i]，array[i+ht-1]，array[i+2ht-1]…分为一组执行插入排序。显然的，在最后阶段，使用增量h1=1时就是对整个序列执行插入排序。<br>选择合适的增量能使插入排序的时间复杂度低于插入排序，如 Hibbard增量： 1, 3, 7, . . . , 2k − 1。<br><strong>执行一个增量为h<strong><strong>k</strong></strong>的排序(hk-Sort)，等价于对h<strong><strong>k</strong></strong>个子数组(subarray)执行插入排序(见下图)</strong>。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1665481444552-78d1a034-c95c-462b-b080-475d22f10d1c.jpeg\" alt><br>\n<a name=\"yUWsx\"></a></p>\n<h3 id=\"3-希尔排序是如何改进插入排序的-执行名副其实的插入排序前h1分组的作用是什么\"><a class=\"markdownIt-Anchor\" href=\"#3-希尔排序是如何改进插入排序的-执行名副其实的插入排序前h1分组的作用是什么\"></a> 3. 希尔排序是如何改进插入排序的? 执行名副其实的插入排序前(h1)，分组的作用是什么？</h3>\n<p>分组的作用是对数组执行<a href=\"https://zhuanlan.zhihu.com/p/87781731\">预排序</a>，即在执行真正的插入排序前先使数组比较有序，以减少执行插入操作的次数。显然插入排序在1.元素个数少 2. 数组比较有序 的情况下执行效率高。分组营造了前一个条件以高效排序子数组，并为逐步减少分组的增量(跨度)以排序数组中的更多元素提供了第二个条件。所以显然的，希尔排序优于插入排序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shell_Sort</span><span class=\"params\">(std::vector&lt;Comparable&gt; array)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = array.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> gap = N/<span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// insertion Sort</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = gap; p &lt; N; ++p)   <span class=\"comment\">// point: ++p here</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = p - gap;</span><br><span class=\"line\">\t\t\tComparable tmp = std::<span class=\"built_in\">move</span>(array[p]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp;  array[j] &gt; tmp; j-=gap)</span><br><span class=\"line\">\t\t\t\tarray[j + gap] = std::<span class=\"built_in\">move</span>(array[j]);</span><br><span class=\"line\">\t\t\tarray[j + gap] = std::<span class=\"built_in\">move</span>(tmp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a name=\"ZZpJ6\"></a></p>\n<h2 id=\"heap_sort\"><a class=\"markdownIt-Anchor\" href=\"#heap_sort\"></a> Heap_Sort</h2>\n<p><a name=\"mMQHg\"></a></p>\n<h3 id=\"1-如何利用堆实现排序\"><a class=\"markdownIt-Anchor\" href=\"#1-如何利用堆实现排序\"></a> 1. 如何利用堆实现排序</h3>\n<p>要利用堆(heap)将一个乱序的数组变成有序的数组，显然的，要首先构造一个堆(build heap)，即利用heapify的方法将N个元素组成堆的结构(本质还是数组)；接着，对这个堆执行N-1次<code>deleteMax</code>(或<code>deleteMin</code>)操作，在每次执行删除操作时，将删除的元素填入刚刚空出来的最后一个元素的位置上；最后能得到一个递增序列(最大堆)或递减序列(最小堆)。<br>关键是要认识到，在本质上，对堆执行deleteMax操作，是将堆的最后一个元素(<code>array[HeapSize]</code>)填在根(<code>array[0]</code>)的位置(覆盖原有的根值),接着把这个结点通过下滤(percolate down)放在合适位置。较之堆删除，堆排序只改变了一个操作，那就是把这个覆盖的过程，变成一个交换(swap)的过程。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1665664167534-eee32f0c-0cba-487b-a1aa-b684f3f02866.png\" alt=\"image.png\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(vector&lt;Comparable&gt; &amp; objects)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// bulid heap</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = objects.<span class=\"built_in\">size</span>()/<span class=\"number\">2</span><span class=\"number\">-1</span>; j &gt;= <span class=\"number\">0</span>; --j)</span><br><span class=\"line\">\t\t<span class=\"built_in\">percDown</span>(objects, j, objects.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">\t<span class=\"comment\">//make a decreasing array</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = objects.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>; i&gt;<span class=\"number\">0</span>; --i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(objects[<span class=\"number\">0</span>], objects[i]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">percDown</span>(objects, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span>  <span class=\"title\">leftChild</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">percDown</span><span class=\"params\">(vector&lt;Comparable&gt; &amp;objects , <span class=\"type\">int</span> i, <span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tComparable tmp = <span class=\"built_in\">move</span>(objects[i]);</span><br><span class=\"line\">\t<span class=\"type\">int</span> child;<span class=\"comment\">// left child </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;<span class=\"built_in\">leftChild</span>(i) &lt; n; i = child)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tchild = <span class=\"built_in\">leftChild</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (child != n<span class=\"number\">-1</span> &amp;&amp; objects[child] &lt; objects[child + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t++child;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &lt; objects[child])</span><br><span class=\"line\">\t\t\tobjects[i] = <span class=\"built_in\">move</span>(objects[child]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tobjects[i] = <span class=\"built_in\">move</span>(tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"pNLGn\"></a></p>\n<h2 id=\"merge_sort\"><a class=\"markdownIt-Anchor\" href=\"#merge_sort\"></a> Merge_Sort</h2>\n<p><a name=\"cBdMT\"></a></p>\n<h3 id=\"1-归并排序是如何排序的为什么说体现了分而治之-divide-and-conquer的思想\"><a class=\"markdownIt-Anchor\" href=\"#1-归并排序是如何排序的为什么说体现了分而治之-divide-and-conquer的思想\"></a> 1. 归并排序是如何排序的，为什么说体现了分而治之( divide-and-conquer)的思想？</h3>\n<p>归并排序，最重要的基本操作就是<strong>将两个已排序的数组整合为一个</strong>，也就是Merge(合并)操作。要获取两个已排序的数组，首先将待排序的数组一分为二，然后对这两个子数组递归的调用归并排序（递归返回条件：子数组只剩一个元素<code> left &gt;= right</code>)。 <br>归并排序本质上是对<strong>逐步完成对子数组的排序进而完成大数组的排序</strong>。<br><strong>divide：将数组一分为二    conquer：Merge</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; objects, vector&lt;Comparable&gt;&amp; tmpA, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left &gt;= right) <span class=\"comment\">// recursive call&#x27;s end condition : only one element </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;  </span><br><span class=\"line\">\t<span class=\"type\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(objects, tmpA, left, center); <span class=\"comment\">// merge first half </span></span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(objects, tmpA, center + <span class=\"number\">1</span>, right);  <span class=\"comment\">// merge second half</span></span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(objects, tmpA, left, center + <span class=\"number\">1</span>, right); <span class=\"comment\">// patch</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; objects)</span>  <span class=\"comment\">// driver</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;Comparable&gt; <span class=\"title\">tmpA</span><span class=\"params\">(objects.size())</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(objects, tmpA, <span class=\"number\">0</span>, objects.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt; <span class=\"comment\">// merge two sorted array into one</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; objects, vector&lt;Comparable&gt;&amp; tmpA, <span class=\"type\">int</span> leftBegin, <span class=\"type\">int</span> rightBegin, <span class=\"type\">int</span> rightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> leftEnd = rightBegin - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmpAIndex = leftBegin;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = rightEnd - leftBegin + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftBegin &lt;= leftEnd &amp;&amp; rightBegin &lt;= rightEnd) <span class=\"comment\">// comparison between two halves</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (objects[leftBegin] &lt;= objects[rightBegin])</span><br><span class=\"line\">\t\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[leftBegin++]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[rightBegin++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftBegin &lt;= leftEnd) <span class=\"comment\">// copy the remainder</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[leftBegin++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (rightBegin &lt;= rightEnd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[rightBegin++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// how to write back to objects</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; ++i,--rightEnd )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tobjects[rightEnd] = <span class=\"built_in\">move</span>(tmpA[rightEnd]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/jpeg/29536731/1672988373854-be3e4874-5705-410b-8800-ad92faa15a40.jpeg\" alt><br>\n<a name=\"dIPOD\"></a></p>\n<h2 id=\"quick_sort\"><a class=\"markdownIt-Anchor\" href=\"#quick_sort\"></a> Quick_Sort</h2>\n<p><a name=\"SkElc\"></a></p>\n<h3 id=\"1-快速排序是如何排序的\"><a class=\"markdownIt-Anchor\" href=\"#1-快速排序是如何排序的\"></a> 1. 快速排序是如何排序的</h3>\n<p>与归并排序类似，快速排序也有分割数组的操作，但不同于归并排序一分为二的做法**，快速排序会先在数组中选取一个枢纽元(pivot)，然后把剩下的元素根据大于/小于pivot分为两组(group)，**产生两个子数组，放在pivot前后，接着递归的对子数组调用快速排序。<br>\n<a name=\"Tfhnl\"></a></p>\n<h3 id=\"2-为什么选择三数中值median-of-three-作为pivot的效率最高\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么选择三数中值median-of-three-作为pivot的效率最高\"></a> 2. 为什么选择三数中值(Median-of-Three )作为pivot的效率最高</h3>\n<p>这里的三数中值，指的是数组最左边<code>array[0]</code>，最右边<code>array[size-1]</code>，和中间<code>array[(left+right)/2]</code>这三个值中大小排中间的那个。<br><strong>选取pivot的原则是取尽可能靠近数组的中值(第 ⌈N/2⌉大的值)，这样做的目的是让分组(partition)后产生了两个子数组如归并排序般尽可能均匀，进而减少递归的层次。<strong>不随机选取三个数取中值的原因在于random函数的代价较高，会影响性能(不随机去一个pivot的原因也是如此)。直接选取第一个元素作为pivot是一个欠妥的做法，这样会导致算法在数组有预排序的情况下做无用功。<br><strong>为什么将三者的最小值放在</strong><code>**array[left]**</code></strong>？</strong> 因为最小值必然小于pivot，避免了一次多余的交换，同时这个left还能作为partition过程中<code>j</code>的哨兵(sentinel)，避免j越界。<br><strong>为什么将三者的最大值放在</strong><code>**array[right]**</code>**？**同理，避免了交换，但此处没有起到做哨兵的作用，因为我们会在选取pivot时就将pivot放在<code>array[right-1]</code>的位置,而i与j遇到equal to pivot的值都会停止，所以pivot也作为了<code>i</code>的哨兵。<br>\n<a name=\"XXNbN\"></a></p>\n<h3 id=\"3-如何分组\"><a class=\"markdownIt-Anchor\" href=\"#3-如何分组\"></a> 3. 如何分组？</h3>\n<p>我们的目标是把小于pivot的值放在数组左边，大于pivot的值放在数组右边。<strong>采取的策略时</strong><code>**i**</code><strong>从数组左边开始遍历，遇到大于pivot的值就停止(该值不属于左边)；</strong><code>**j**</code><strong>从数组右边开始遍历，遇到小于pivot的值就停止。接着交换</strong><code>**i**</code><strong>和</strong><code>**j**</code><strong>所在位置的元素。当i和j交叉时，把</strong><code>**pivot**</code><strong>与</strong><code>**i**</code><strong>所在位置的值交换</strong>(为什么是<code>i</code>而不是<code>j</code>？因为pivot预先被放在数组右边right-1的位置，如果被放在右边那pivot就是和<code>j</code>交换位置)<br>**如何处理等于pivot的元素？**先说结论，<code>**i**</code><strong>和</strong><code>**j**</code><strong>遇到这样的元素都要停下</strong>。<br>接着在极端情况(所有元素都一样)情况下讨论其它做法的低效性<br>**为什么不一个停下而另一个继续前进？**如果<code>i</code>停下而<code>j</code>不停下，则<code>i``j</code>交叉的位置会偏向左侧，而pivot要与i最后在的位置交换值，这样显然会导致子数组的大小不平衡。<br>**为什么不两个都不停下？**首先<code>i</code>，<code>j</code>显然可能会出界，即使存在<code>i``j</code>出界的代码，这样做会导致i最后所处的位置在靠近最右边的位置(取决于具体实现)，而pivot要与<code>i</code>交换位置，进而导致产生的子数组很不平衡，降低了算法效率<br>\n<a name=\"mt8ir\"></a></p>\n<h3 id=\"4-递归结束条件是什么什么是cutoff为什么要结合插入排序\"><a class=\"markdownIt-Anchor\" href=\"#4-递归结束条件是什么什么是cutoff为什么要结合插入排序\"></a> 4. 递归结束条件是什么？什么是cutoff？为什么要结合插入排序？</h3>\n<p>快速排序或许应该像归并排序那样，当子数组仅剩一个元素时递归返回。但是实际上并不这样设置递归返回条件，因为存在这样一个事实：<strong>当数组元素个数很少(5~20)时，快速排序的效率还不如插入排序。因此在partition之后如果子数组的大小小于某一界限(cutoff)，就停止递归调用，转而对子数组调用插入排序,进而提升算法的整体效率</strong><br>这里提到了<a href=\"https://stackoverflow.com/questions/70402/why-is-quicksort-better-than-mergesort\">快速排序与归并排序的区别</a>，还有的区别点是快速排序不占用额外的内存，快速排序使用的是<a href=\"https://stackoverflow.com/questions/33923/what-is-tail-recursion\">尾递归</a>等</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> Comparable <span class=\"title\">Median</span><span class=\"params\">(vector&lt;Comparable&gt; &amp; array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (array[left] &gt; array[right])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[left], array[right]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (array[center] &gt; array[right])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[center], array[right]); <span class=\"comment\">// keep left is min among three values</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (array[left] &gt; array[center])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[left], array[center]); <span class=\"comment\">// keep right is max among three values</span></span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(array[center], array[right - <span class=\"number\">1</span>]); <span class=\"comment\">// put pivot into position right-1 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> array[right - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; array, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> range = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (range &gt; <span class=\"number\">10</span>) <span class=\"comment\">// cutoff = 10</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tComparable pivot = <span class=\"built_in\">Median</span>(array, left, right);</span><br><span class=\"line\">\t\t<span class=\"comment\">// partition</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i = left; <span class=\"type\">int</span> j = right - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (array[++i] &lt; pivot); <span class=\"comment\">// increase before check , details see stackoverflow </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (array[--j] &gt; pivot);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(array[i], array[j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[i], array[right - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"comment\">// recursion</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(array, left, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(array, i + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">insertionSort</span>(array, left, right);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Driver</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; array)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">quickSort</span>(array, <span class=\"number\">0</span>, array.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"wPOyJ\"></a></p>\n<h1 id=\"chapter-6-disjoint-sets\"><a class=\"markdownIt-Anchor\" href=\"#chapter-6-disjoint-sets\"></a> Chapter 6 Disjoint Sets</h1>\n<p><a name=\"AHMCd\"></a></p>\n<h2 id=\"1-什么是不相交集什么是unionfind操作\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是不相交集什么是unionfind操作\"></a> 1. 什么是不相交集？什么是union/find操作？</h2>\n<p>对于一个集合S，由一个关系R可将S划分为多个<a href=\"https://www.zhihu.com/question/276100093/answer/388155191\">等价类</a>(equivalence class)，在一个等价类中的所有元素之间均存在关系R(即任意a，b ∈ S, a~b)。显然的，要判断任意给定的S中的元素a，b是否有关系，只需判断a,b是否属于同一个等价类，这也说明了<strong>等价类概念的提出是为了给出一个快速判断a,b是否存在关系的方法(我的理解)</strong>。显然的，等价类是S的一个子集(set)，一个元素也只属于一个等价类，<strong>不同的等价类们就是本章要讨论的不相交集(disjoint sets）</strong><br>什么是union/find操作？先查找元素a和b所在的等价类(find操作)，然后判断是不是同一个等价类(find(a) == find(b) ？ ),that is，<strong>判断a,b是否有关系。如果没有，就将a,b联系起来，也就是变得有关系</strong>，即将a,b的等价类合并为一个新的等价类(注意关系的传递性(Transitive)，a,b如果有关系，那么两者原来所在集合的所有元素间也存在了关系)，合并的过程就是union操作。如果本身就有关系，就不用操作了。<br>\n<a name=\"x95GB\"></a></p>\n<h2 id=\"2-如何表示不相交集\"><a class=\"markdownIt-Anchor\" href=\"#2-如何表示不相交集\"></a> 2. 如何表示不相交集？</h2>\n<p>初始状态，对于N个元素的集合S，假设N个元素间均不存在关系，因此有N个不相交集(每个集合仅有一个元素)。因为不存在comparison操作，所以我们并不在意元素的值是多少，因此我们<strong>把N个元素以0~N-1编号</strong>。<br>我们<strong>用树来表示一个集合，并把树的根作为集合的名字</strong>(某个元素编号)。初始状态时，每个集合名统一表示为-1。<br><strong>树形态的不相交集不具备完全二叉树(堆)那样的规整性，为什么可以用数组来实现？<strong>因为对于每个元素我们只关心它所在的集合是哪个，即它所在的树的根是哪个，因此</strong>对于每个元素，我们仅需知道它所在的树的根值</strong>即可。不仅如此，数组的从0开始下标也与我们的编号符合，因此可以<strong>用大小为N的数组存储0~N-1个元素的父节点（即对第i个数组项，array[i]存储了编号i的父结点），提供了一个由任意结点开始向上遍历即可获取根结点（that is ，任意结点所在集合名）的途径。</strong><br>\n<a name=\"XuWqo\"></a></p>\n<h2 id=\"3-unionfind-如何执行\"><a class=\"markdownIt-Anchor\" href=\"#3-unionfind-如何执行\"></a> 3. Union/find 如何执行 ？</h2>\n<p>find操作要找到元素A所在树的根，即对A结点沿根节点方向向上遍历，直到数组值为 -1(<code>sets[i] &lt; 0</code>)，说明此数组编号为根节点(<code>return x</code>)。这其实就是一个不断获取父节点的过程，可使用递归。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> <span class=\"type\">const</span>  </span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sets[x] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(sets[x]); <span class=\"comment\">// recursive</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Union操作<strong>要合并两个集合，只需要将一个集合的根结点，链接到另一个集合的根节点上</strong>，因为在我们的方法中，根节点才是集合的唯一标识。具体来说，假设root1(同样的，是一个编号)是某个集合的根结点(即，集合名)，root2是另一个集合的根节点，执行Union，就是执行array[root1] = root2 (执行前：array[root1] == array[root2] == -1 ; 执行后：array[root1] == root2 , array[root2] == -1)<br>如果实参不是根，而是元素编号，则需额外执行两次find</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unions</span><span class=\"params\">(<span class=\"type\">int</span> root1, <span class=\"type\">int</span> root2)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tsets[root2] = root1;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>显然的，因为数组是一个支持随机存取的数据结构，则获取set[x]的值是常数时间(that is O(1) )，find操作真正耗时的是向上探索的过程，也就是说<strong>影响find操作的主要是结点所在的深度</strong>。<br>\n<a name=\"xnSpG\"></a></p>\n<h2 id=\"4-如何改进union\"><a class=\"markdownIt-Anchor\" href=\"#4-如何改进union\"></a> 4. 如何改进Union</h2>\n<p>上述合并是有问题的，把两颗相同高度的树合并，或通过把一颗高树(larger height)根节点链接到一颗矮树的根节点以实现两颗不同高度树的合并，均<strong>会使新树的高度比原来最大的那颗还要多一，即增加了各结点的深度，这样会极大影响find的效率(根节点最大高度为N-1)</strong>。因此我们需要改进合并的方法。<br>很自然的想法就是<strong>把矮树的根节点链接到高树的根节点</strong>(注意本章所用的树不是二叉树，而是一颗多路树)，这样新树的高度还会保持与原来高树的一致；如果两棵树高度相同，那么谁链接到谁都可以，结果都会使新树高度增1(所以根节点最大高度为log2N)<br>如何确定高树和矮树？显然的，<strong>我们需要跟踪每棵树的高度，可以用现有的数组存储，原先根节点的数组值为-1，现在将其改写为其所代表集合的高度的负数</strong>(为什么是负数？或许是为了方便find函数的判断语句更好编写:<code>if (sets[x] &lt; 0 return x;</code>注意之前提到设置各集合初始值为-1，也与这里符合)<br>也可以根据数的大小(size)决定谁链接到谁，但显然由高度做决定更好</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unionSets</span><span class=\"params\">(<span class=\"type\">int</span> root1, <span class=\"type\">int</span> root2)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sets[root2] &lt; sets[root1]) <span class=\"comment\">// set[root] keep track of height(negative)</span></span><br><span class=\"line\">\t\t\tsets[root1] = root2; <span class=\"comment\">// root2 is deeper</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sets[root2] == sets[root1])</span><br><span class=\"line\">\t\t\t\t--sets[root1];</span><br><span class=\"line\">\t\t\tsets[root2] = root1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"unJoe\"></a></p>\n<h2 id=\"5-如何改进find\"><a class=\"markdownIt-Anchor\" href=\"#5-如何改进find\"></a> 5. 如何改进find</h2>\n<p>在寻找编号为x的元素的根的过程中，我们使用<strong>路径压缩(Path Compression)<strong>的方法(自调整)，即</strong>把从x到root之间所有结点的父节点均改为根节点。</strong><br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1666421236514-c4f89687-71a5-42a4-b5fe-19f8f379487a.png\" alt=\"image.png\"><br>具体做法是<strong>递归的将根节点的编号赋值给路径上的结点</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sets[x] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sets[x] = <span class=\"built_in\">find</span>(sets[x]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"fO0SW\"></a></p>\n<h1 id=\"chapter-7-graph-algorithms\"><a class=\"markdownIt-Anchor\" href=\"#chapter-7-graph-algorithms\"></a> Chapter 7 Graph Algorithms</h1>\n<p><a name=\"TOgKc\"></a></p>\n<h2 id=\"graph-implement\"><a class=\"markdownIt-Anchor\" href=\"#graph-implement\"></a> <a href=\"https://stackoverflow.com/questions/5493474/graph-implementation-c\">Graph implement</a></h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1666956918039-3ebc54cf-6c4e-4feb-8f90-6473899dc634.jpeg\" alt></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">vertex</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, vertex* &gt; ve;</span><br><span class=\"line\">\t<span class=\"type\">int</span> name; </span><br><span class=\"line\">\t<span class=\"type\">int</span> seq;<span class=\"comment\">// serial number</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ind; <span class=\"comment\">// indegree</span></span><br><span class=\"line\">    <span class=\"type\">int</span> addition <span class=\"comment\">// additional Message </span></span><br><span class=\"line\">\tvector&lt;ve&gt; adj; <span class=\"comment\">// adjacent list:cost of edge, destination vertex</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vertex</span>(<span class=\"type\">int</span> n) :<span class=\"built_in\">name</span>(n),<span class=\"built_in\">seq</span>(<span class=\"number\">0</span>),<span class=\"built_in\">ind</span>(<span class=\"number\">0</span>)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Graph</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> map&lt;<span class=\"type\">int</span>, vertex*&gt; vmap;</span><br><span class=\"line\">\tvmap graph;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> from, <span class=\"type\">const</span> <span class=\"type\">int</span> to,<span class=\"type\">const</span> <span class=\"type\">int</span> weight)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addVertex</span><span class=\"params\">(<span class=\"type\">int</span> newSeq)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::addEdge</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> from, <span class=\"type\">const</span> <span class=\"type\">int</span> to, <span class=\"type\">const</span> <span class=\"type\">int</span> weight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tvertex* f = graph.<span class=\"built_in\">find</span>(from)-&gt;second;</span><br><span class=\"line\">\tvertex* t = graph.<span class=\"built_in\">find</span>(to)-&gt;second; </span><br><span class=\"line\">\tpair&lt;<span class=\"type\">int</span>, vertex*&gt; edge = <span class=\"built_in\">make_pair</span>(weight, t);</span><br><span class=\"line\">\tf-&gt;adj.<span class=\"built_in\">push_back</span>(edge);</span><br><span class=\"line\">    ++(t-&gt;ind);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::addVertex</span><span class=\"params\">(<span class=\"type\">int</span> newSeq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> iter = graph.<span class=\"built_in\">find</span>(newSeq);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (iter != graph.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvertex * v;</span><br><span class=\"line\">\t\tv = <span class=\"keyword\">new</span> <span class=\"built_in\">vertex</span>(newSeq);</span><br><span class=\"line\">\t\tgraph[newSeq] = v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Graph::size</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> graph.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitialGraph</span><span class=\"params\">(Graph&amp; myGraph)</span>  <span class=\"comment\">// a instance</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">2</span>); </span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);<span class=\"comment\">// as unweighted graph , weight = 1</span></span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>); </span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"JeoiH\"></a></p>\n<h2 id=\"topological-sort\"><a class=\"markdownIt-Anchor\" href=\"#topological-sort\"></a> Topological Sort</h2>\n<p><a name=\"ueS0P\"></a></p>\n<h3 id=\"1-什么是拓扑排序意义是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是拓扑排序意义是什么\"></a> 1. 什么是拓扑排序？意义是什么？</h3>\n<p>首先先理解拓扑的含义：the way the parts of sth are arranged and related. 形象的来说：比如说一个人要自学计算机科学知识(sth)，而该领域知识由很多板块的内容(parts)构成，这些内容又相互关联(在学懂A课程前必须有B课程的基础，related)，那么他就面临一个问题，怎么安排学习顺序(路径，arranged)？一个显然不合理的安排是在学习操作系统先于数据结构与算法，因为数据结构与算法是学习OS的前置课程。<strong>一个不违反前置条件的学习路径就是一个拓扑排序，其意义就是得到一条合理的学习路径。<strong>说的更广泛一点，拓扑排序就是得到一个合理的处理顺序。<br>如果我们把各板块内容之间铺垫关系画成一张图，各板块为顶点，有向边作为关联(如 Vertex数据结构与算法指向Vertex操作系统)，那么</strong>拓扑排序在这个图中体现为一条沿着有向边方向的路径</strong>(即路径中任意一段单位路径u到v,不存在边(v,u))<br>显然，<strong>存在拓扑排序的图一定是有向无环图</strong>( directed acyclic graph，DAG),<a href=\"https://www.quora.com/Why-must-a-graph-with-a-topological-sort-be-acyclic-and-why-must-an-acyclic-graph-have-a-topological-sort\">如果图是有环的，那么就找不到符合要求的路径，因为总会违反前置条件</a><br>\n<a name=\"yLpq8\"></a></p>\n<h3 id=\"2-如何实现拓扑排序算法怎样使其更高效\"><a class=\"markdownIt-Anchor\" href=\"#2-如何实现拓扑排序算法怎样使其更高效\"></a> 2. 如何实现拓扑排序算法？怎样使其更高效？</h3>\n<p>对于我们要选择的第一个顶点，显然的，它必须没有前置条件，即没有顶点指向它，入度(indegree为0)。我们选择这样一个点，然后<strong>在图中抹去该点和它的边</strong>(显然的，都是由它发出的边，与它相关的顶点入度也随之更新)，在剩下的图中重复这个步骤，直到图为空(如果找不到入度为0的顶点而图不为空，说明图不是DAG，存在环)。顶点被抹去的顺序，就是拓扑排序。<br>如何快速寻找到入度为0的点呢？如果通过遍历顶点集的方式，那么开销是很大的，特别是如果图很稀疏(边很少，sparse)，那么要去除的边也是很少的，因此每一步被影响到入度的顶点的数量也是很少的，即大部分的顶点入度是一直没变的，反复的遍历它们是pointless行为。<br>提升效率方法是<strong>将入度为0的点单独拿出来，我们可以用栈或队列来存储。在每次去掉顶点和边之后，我们将更新后入度变为0的顶点加入到队列中</strong>。显然的，队列的出队顺序就是我们要求的拓扑排序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&quot;Graph.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TopologicalSort</span><span class=\"params\">(Graph&amp; myGraph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\tqueue&lt;vertex*&gt; zero;</span><br><span class=\"line\">\t<span class=\"type\">int</span> counter = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = myGraph.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter :myGraph.graph) <span class=\"comment\">// initalize vertexSet which indegree is zero</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iter.second-&gt;ind == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tzero.<span class=\"built_in\">push</span>(iter.second);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!zero.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvertex* v = zero.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tzero.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tv-&gt;seq = ++counter;</span><br><span class=\"line\">\t\tcout &lt;&lt; v-&gt;name &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> adjN = v-&gt;adj.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; adjN; ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (--(v-&gt;adj[i].second-&gt;ind) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tzero.<span class=\"built_in\">push</span>(v-&gt;adj[i].second);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (counter != N<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"Ms2lL\"></a></p>\n<h2 id=\"shortest-path-algorithms\"><a class=\"markdownIt-Anchor\" href=\"#shortest-path-algorithms\"></a> Shortest-Path Algorithms</h2>\n<p><a name=\"TdCMl\"></a></p>\n<h3 id=\"1-什么是单源最短路径问题\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是单源最短路径问题\"></a> 1. 什么是单源最短路径问题？</h3>\n<p>单源最短路径问题(Single-Source Shortest-Path Problem): <strong>给定一个有权图(weighted graph,可以有环)中的一个点</strong><code>**v**</code><strong>，求出</strong><code>**v**</code><strong>到其它所有顶点的最短路径</strong>，that is ,在答案所呈现的结果图中，<code>v</code>到结果图中任意一个顶点<code>w</code>的路径，其长度是<code>v</code>与<code>w</code>之间存在的所有路径中，长度最短的那条。<br>也可以从另一个角度理解这个问题，即如果把边长视为开销，那么<strong>该问题就是要以最小的开销，从源顶点开始，覆盖整张图的顶点</strong><br>\n<a name=\"q5MIP\"></a></p>\n<h3 id=\"2为什么breadth-first-search可以解决unweighted-shortest-paths\"><a class=\"markdownIt-Anchor\" href=\"#2为什么breadth-first-search可以解决unweighted-shortest-paths\"></a> 2.为什么Breadth-First Search可以解决Unweighted Shortest-Paths?</h3>\n<p>为了理解SSSP问题，我们先考虑无权图，无权图可视为权重为1的有权图<br>我们先设置问题的初始状态：<code>v</code>到任意<code>w</code>的距离都是无穷大，任意<code>w</code>的状态都是unknown(<code>v</code>到该<code>w</code>的最短路径还未确定)。<br>我们首先能确定的是<code>v</code>能直接到达的点(<code>v</code>的邻接点)，因为v只有唯一途径能到达这些点，所以这个唯一途径就是最短路径。我们把这些点称为第一层，其最短路径均为1。接着，我们能确定的点显然是第一层的邻接点，<strong>因为</strong><code>**v**</code><strong>能通过第一层的点去访问只有这些点</strong>，我们把这些点称为第二层，其最短路径自然为2。按照这样的一个广度优先搜索的逻辑，我们便能确定所有点的最短路径。<br>因为是无权图，所以不存在对路径长度的多次更新（关于该点可见后续讨论中的例子：不存在将s-&gt;w1-&gt;w3更改为s-&gt;w2-&gt;w3的可能），对每个顶点的处理，只需简单的将其distance信息设置为前一个顶点的distance+1即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::unweighted_Shortest_Path_with_queue</span><span class=\"params\">(vertex&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tqueue&lt;vertex*&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)</span><br><span class=\"line\">\t\titer.second-&gt;dist = INFINITY;</span><br><span class=\"line\">\ts.dist = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(&amp;s);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvertex v = *q.<span class=\"built_in\">front</span>(); <span class=\"comment\">// priority &#x27;.&#x27; &gt; &#x27;*&#x27;</span></span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; adjac : v.adj)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tadjac.second-&gt;dist = v.dist + <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\tadjac.second-&gt;path = v.name;</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">push</span>(adjac.second);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::unweighted_Shortest_Path</span><span class=\"params\">(vertex&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> NUM_VERTICES = <span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titer.second-&gt;dist = INFINITY;</span><br><span class=\"line\">\t\titer.second-&gt;known = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.dist = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> currDist = <span class=\"number\">0</span>; currDist &lt; NUM_VERTICES; ++currDist) <span class=\"comment\">// double for loops:inefficiency</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!iter.second-&gt;known &amp;&amp; iter.second-&gt;dist == currDist)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\titer.second-&gt;known = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; adjac : (iter.second-&gt;adj))</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tadjac.second-&gt;dist = currDist + <span class=\"number\">1</span>; <span class=\"comment\">// update distance</span></span><br><span class=\"line\">\t\t\t\t\tadjac.second-&gt;path = iter.second-&gt;name;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"YjF5L\"></a></p>\n<h3 id=\"3为什么dijkstra-algorithm每一步要选择最近的结点为什么该算法可以解决single-source-weighted\"><a class=\"markdownIt-Anchor\" href=\"#3为什么dijkstra-algorithm每一步要选择最近的结点为什么该算法可以解决single-source-weighted\"></a> 3.为什么Dijkstra Algorithm每一步要选择最近的结点，为什么该算法可以解决Single-Source Weighted？</h3>\n<p>与上一问一样，要找到<code>v</code>到所有顶点的最短路径，我们总得先知道<code>v</code>能到达哪些点。所以我们在用Dijkstra解决SSSP的时候，我们似乎也应该按照这样的结点选择顺序：首先找的是<code>v</code>的邻接点，然后再邻接点… 。但是我们需要注意，<strong>我们实际选择结点的顺序(选择结点即把结点变为known，说明找到了到它的最短路径)，是不断的选取未确定结点中离</strong><code>**v**</code><strong>距离最近的那一个，而不是像无权图中那样邻接点接着邻接点的广度搜索。</strong><br><strong>为什么要选择最近的那一个？</strong><br>举个最简单的例子：在这个图中，我们首先探索了源顶点的邻接点w1,w2，更新其dist为ds+dcost，那么w1.dist=1，w2.dist =3。那么下一轮我们选择那个顶点进行探索(其邻接点)呢？显然是w1，因为在当前条件下，我们只知道源顶点离w1更近一些，那么到w3(后续未知结点)的最短路径自然更可能的在w1这边(我们还不知道后续顶点的dist信息)。<strong>因此我们在每次选择一个顶点以探索他的邻接点(更新dist信息)，都要选择当前距离v最近的那个，因为经过这样一个点的路径才最有可能是(到后续顶点)最短路径/开销可能最少。</strong><br>为什么在无权图中不用这样做？<br>无权图的边长权重都为1，开销的是一样的。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1667390674960-21e67dd1-f11c-4336-a168-c237056626fe.jpeg\" alt><br>我们要有一个认知：<strong>源顶点</strong><code>**v**</code><strong>到某一目标顶点</strong><code>**w****t**</code><strong>之间的最短路径①上存在着几个中间顶点，那么v到任意一个中间结点</strong><code>**w****i**</code>**的最短路径②一定与①重合。**或者说v到目标顶点的最短路径，是目标顶点在该路径的上一个顶点的最短路径延长了一个边长所得到的。<br><strong>因此我们逐步找到各顶点的最短路径，并从之前找到的最短路径(以开销最少的方式)延展到其它顶点上，便可以找到到所有顶点的最短路径。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::Dijkstra_Algorithm</span><span class=\"params\">(vertex&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titer.second-&gt;dist = INFINITY;</span><br><span class=\"line\">\t\titer.second-&gt;known = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.dist = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">existUnknown</span>()) <span class=\"comment\">//there is an unknown vertex</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"> \t\tvertex* v = <span class=\"built_in\">smallestUnknown</span>();   <span class=\"comment\">// smallest unknown distance vertex</span></span><br><span class=\"line\">\t\tv-&gt;known = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : v-&gt;adj)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v-&gt;dist + iter.first &lt; iter.second-&gt;dist) </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\titer.second-&gt;dist = v-&gt;dist + iter.first; <span class=\"comment\">// update</span></span><br><span class=\"line\">\t\t\t\titer.second-&gt;path = v-&gt;name;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Graph:: <span class=\"built_in\">existUnknown</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)  <span class=\"comment\">// iteration </span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!iter.second-&gt;known)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vertex* <span class=\"title\">Graph::smallestUnknown</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tvertex* min = graph.<span class=\"built_in\">begin</span>()-&gt;second;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)  <span class=\"comment\">// iteration </span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!iter.second-&gt;known &amp;&amp; iter.second-&gt;dist &lt; min-&gt;dist)</span><br><span class=\"line\">\t\t\tmin = iter.second;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"b4gnk\"></a></p>\n<h3 id=\"4为什么dijkstra-algorithm不适用于有负权值边的图\"><a class=\"markdownIt-Anchor\" href=\"#4为什么dijkstra-algorithm不适用于有负权值边的图\"></a> 4.为什么Dijkstra Algorithm不适用于有负权值边的图</h3>\n<p>在Dijkstra算法中，我们<strong>一旦将一个顶点</strong><code>**v**</code><strong>由unknown标记为known，就说明由</strong><code>**s**</code><strong>到</strong><code>**v**</code><strong>的最短路径已经找到，且不会再改变，即算法不会在后续过程中回头(look back)修改到</strong><code>**v**</code><strong>的最短路程这一信息</strong>。如果我们用Dijkstra算法在图中确定了<code>v</code>的最短路径，然后发现<code>v</code>到某个邻接点<code>u</code>(状态为unknown)的边权值为负，那么此时<code>s</code>到<code>v</code>的实际最短路径就发生了变化：s-&gt;v-&gt;w-&gt;v，然而因为Dijkstra算法不会look back，所以算法继续保持之前的最短路径，因此会产生与事实不符的结果。<br>\n<a name=\"wzqMO\"></a></p>\n<h2 id=\"critical-path-problems\"><a class=\"markdownIt-Anchor\" href=\"#critical-path-problems\"></a> Critical Path Problems</h2>\n<p><a name=\"MCV9V\"></a></p>\n<h3 id=\"1-如何理解关键路径关键路径是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-如何理解关键路径关键路径是什么\"></a> 1. 如何理解关键路径？关键路径是什么？</h3>\n<p>一个项目由多个可独立完成工作(jobs)组成，各工作之间存在优先级限制关系(precedence constraint)，即某一项工作必须在完成另一项(或多项)工作后才能启动。①如何确定项目的最快(早)完成时间？②如何确定某些工作的可延迟时间 (that is,slack time 松弛时间) 以不至于增加整个项目的完成时间？<br><strong>关键路径这样一组工作序列：该工作序列可以用来确定项目的最快完成时间。对第二点，关键路径上的所有工作的可延迟时间均为0，关键路径上的任何一个工作被延迟，都会增加整个项目的完成时间，这也是为什么称之为&quot;关键&quot;。</strong><br>这样的项目可以体现在有向无环图中。为什么一定是无环？与拓扑排序一样的道理，如果有几个工作成环状相互制约，那就无法开启任何一项工作，因为总是违反其优先级限制关系。<strong>关键路径在这样的图中体现为从开始到结束的最长路径(longest path)</strong><br>注意路径的长度由边的权值(工作完成所需时间)决定而不是边的数量<br>\n<a name=\"oj5FV\"></a></p>\n<h3 id=\"2-为什么图的最长路径就是关键路径\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么图的最长路径就是关键路径\"></a> 2. 为什么图的最长路径就是关键路径？</h3>\n<blockquote>\n<p>关键路径是通过识别最长的相关活动并测量从开始到结束完成它们所需的时间来确定的 -wikipedia</p>\n</blockquote>\n<p>我们首先要理解一条路径上的各个工作节点之间存在着严格的先后关系，即优先级限制关系。这就说明<strong>各工作只能串行的执行</strong>，哪怕你有很多处理器(processors)也必须等待高优先级的工作执行完毕后再开启新的工作。互不关联(不在同一路径)的工作可以并行的执行，所以<strong>在最长路径上的最后一个工作执行完毕时，其它路径也一定执行完毕，即整个项目执行完毕。因此最长路径决定了项目的完成时间，不延迟的执行最长路径(上的工作)所花的时间，就是项目的最快完成时间。</strong><br>\n<a name=\"Aa03a\"></a></p>\n<h2 id=\"network-flow-problems\"><a class=\"markdownIt-Anchor\" href=\"#network-flow-problems\"></a> Network Flow Problems</h2>\n<p><a name=\"RBuq3\"></a></p>\n<h3 id=\"1-如何理解网络流问题\"><a class=\"markdownIt-Anchor\" href=\"#1-如何理解网络流问题\"></a> 1. 如何理解网络流问题？</h3>\n<p>网络流问题就是从一个端<code>s</code>往另一个端<code>t</code>发送流(Flow,如通水，运货，发送数据包等)，要经过数个中间节点，各节点间的边的传输容量是有限的(如水管的阈值，超过了这个值水管会破裂)，问从s发送到t的最大流(the maximum amount of ﬂow)是多少。显然的要找出这个最大流，<strong>我们要解决的根本问题是如何正确安排运输方案(即路径选择)以最大化流</strong>。<br><strong>如何计算图中流的数量(the amount of ﬂow)？</strong> <strong>只需看从端</strong><code>**s**</code><strong>发出了多少流即可</strong>(端<code>t</code>肯定接受同样数量的流，除非“漏水”了)<br>**怎么验证我们得到的流的数量是最大的？**把图分割(cut)为两个部分，一部分包含s，另一部分包含t(其余结点随意，因此存在多种切割方式)，<strong>经过切割线上的边的容量总和决定了最大流的界限，容量总和的最小值即为图所能承受的最大流的值(the minimum cut capacity is exactly equal to the maximum ﬂow)</strong><br>由此我们可以看出，<strong>解决最大流问题的目的不是为了得到最大流的值，而是知道能达到最大流的运输方案</strong><br><a href=\"https://www.youtube.com/watch?v=6DFWUgV5Osc&amp;list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&amp;index=8\"><strong>网络流问题基础 Network Flow Problems</strong></a><br>\n<a name=\"LytbY\"></a></p>\n<h3 id=\"2-如何得到最大流\"><a class=\"markdownIt-Anchor\" href=\"#2-如何得到最大流\"></a> 2. 如何得到最大流？</h3>\n<p>首先考虑简单的算法(naive algorithm )，我们随机的选择路径( free to choose any path from s to t)，直到Gr中不存在s到t的路径，看能否得到最大流，事实证明，这样是不可靠的，得到的方案可能会使我们会得到一个小于最大流的值。<strong>该方法存在的缺陷是，一旦在某一步选中了错误的路径(不属于最大流方案的路径)，算法无法纠正错误，因此找不到最大流。</strong><br>我们改进一下这个算法，<strong>在每次进行一次路径选择(即在G<strong><strong>r</strong></strong>图中相应边执行了减法)之后，接着在相应边上加上一条方向相反的边，其权值就等于刚刚该边减去的值。称为Ford–Fulkerson algorithm</strong><br><strong>这样做的目的，是让算法有了撤销(undo)的能力，可以把不好的路径撤销掉，因此该算法总能找到正确的路径，进而找到最大流。</strong><br><a href=\"https://www.youtube.com/watch?v=8sLON0DqLZo&amp;list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&amp;index=9\">**Ford-Fulkerson Algorithm 寻找网络最大流  -Dr Wang **</a></p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n<a name=\"qIfKY\"></a>\n<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h1>\n<p>以下记录了我2022年暑假开始学习数据结构的历程。从哈希表到图论，有着详细的思考过程。</p>","more":"<hr>\n<p><a name=\"Aq9ue\"></a></p>\n<h1 id=\"chapter-1-listsstacks-and-queues\"><a class=\"markdownIt-Anchor\" href=\"#chapter-1-listsstacks-and-queues\"></a> Chapter 1 Lists,Stacks and Queues</h1>\n<p><a name=\"csZFb\"></a></p>\n<h3 id=\"1-对自制vector容器添加错误检查能力\"><a class=\"markdownIt-Anchor\" href=\"#1-对自制vector容器添加错误检查能力\"></a> 1. 对自制vector容器添加错误检查能力</h3>\n<blockquote>\n<p>访问vector容器，可能会出现的错误的迭代器操作主要有两种</p>\n<ol>\n<li>错误的访存操作：迭代器未初始化，执行<code>*</code>操作</li>\n<li>迭代器超出容器边界：迭代器在末尾执行<code>++iter/iter++</code>操作</li>\n</ol>\n</blockquote>\n<p>另外，迭代器还会出现如<code>7</code>所述的失效的情况</p>\n<p><a name=\"kxJtb\"></a></p>\n<h4 id=\"1处理错误操作在重载运算符和时检查current的值\"><a class=\"markdownIt-Anchor\" href=\"#1处理错误操作在重载运算符和时检查current的值\"></a> 1.处理错误操作：在重载运算符<code>*</code>和<code>++</code>时检查current的值</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object <span class=\"keyword\">operator</span> *()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (const_iterator::current == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// Check boundary</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Error: iterator is NULL!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *(const_iterator::current);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">iterator&amp; <span class=\"keyword\">operator</span> ++ ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (const_iterator::current == objects[theSize<span class=\"number\">-1</span>]) <span class=\"comment\">// Error:Cannot access objects</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Error: iterator is end!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t    <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconst_iterator::current++;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iterator类与const_iterator类作为vector模板类的嵌套类，访问外部类的私有成员<code>objects</code>与<code>theSize</code>是一件比较困难的事情 <a href=\"https://stackoverflow.com/questions/486099/can-inner-classes-access-private-variables\">StackOverFlow：Can inner classes access private variables?</a></p>\n<blockquote>\n<p>嵌套类与外部类之间没有访问特权</p>\n</blockquote>\n<p><a name=\"hHyA9\"></a></p>\n<h4 id=\"2处理失效的迭代器给迭代器添加一个数据成员用于指向当前表用一个函数用于判断迭代器是否指向正确的表-当发生扩容时原有的thevector指向的空间被释放-thevector-null感觉有点问题\"><a class=\"markdownIt-Anchor\" href=\"#2处理失效的迭代器给迭代器添加一个数据成员用于指向当前表用一个函数用于判断迭代器是否指向正确的表-当发生扩容时原有的thevector指向的空间被释放-thevector-null感觉有点问题\"></a> 2.处理失效的迭代器：给迭代器添加一个数据成员用于指向当前表，用一个函数用于判断迭代器是否指向正确的表。当发生扩容时，原有的theVector指向的空间被释放。（<code>theVector == NULL</code>感觉有点问题）</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">const_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    Object* current;</span><br><span class=\"line\">    <span class=\"type\">const</span> vector&lt;Object&gt;* theVector;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">assertIsValid</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(current == <span class=\"literal\">NULL</span> || theVector == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"string\">&quot;IteratorOutOfbounds&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"fgUkk\"></a></p>\n<h3 id=\"2-搜寻链表的注意点\"><a class=\"markdownIt-Anchor\" href=\"#2-搜寻链表的注意点\"></a> 2. 搜寻链表的注意点</h3>\n<p>在链表搜寻值为x的节点时，显然需要保存两个节点的信息：当前节点<code>current</code>和上一个节点<code>foreCurrent</code>,要注意对这两个值不同的初始化，搜寻的条件也不同。有以下两种模式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current = head-&gt;next</span><br><span class=\"line\">foreCurrent = head;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (current &amp;&amp; current-&gt;data != x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    foreCurrent = current;</span><br><span class=\"line\">    current = current-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node* current = head; <span class=\"comment\">// Initially nullptr</span></span><br><span class=\"line\">Node* foreCurrent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (current-&gt;next!= <span class=\"literal\">nullptr</span> &amp;&amp; current-&gt;data != x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tforeCurrent = current;</span><br><span class=\"line\">\tcurrent = current-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：混淆这两种模式将出现访存错误，如以下情况</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node* current = head-&gt;next;</span><br><span class=\"line\">Node* foreCurrent = head;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (current-&gt;next!= <span class=\"literal\">nullptr</span> &amp;&amp; current-&gt;data != x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tforeCurrent = current;</span><br><span class=\"line\">\tcurrent = current-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样会出现的问题是：当链表中仅有一个头节点时，初始<code>current=head-&gt;next</code>值为<code>nullptr</code>，第3行的<code>current-&gt;next</code>将执行失败（实现iterator类后，尽可能的使用该类，该类不存在以上问题）<br>\n<a name=\"hF7j1\"></a></p>\n<h3 id=\"3平衡符号\"><a class=\"markdownIt-Anchor\" href=\"#3平衡符号\"></a> 3.平衡符号</h3>\n<p>创建一个空栈后读取文件，当读取到开放字符<code>(,&#123;,[,/*</code>时压入栈，当读取到封闭字符<code>),&#125;,],*/</code>时从栈顶弹出字符。</p>\n<blockquote>\n<ol>\n<li>读取到封闭字符时，栈为空，则封闭字符不匹配，报错</li>\n<li>弹出的字符与封闭字符不匹配，报错</li>\n<li>读取到文件尾后，栈不为空，则开放字符不匹配，报错</li>\n</ol>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">balSymbol</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> current, prev;</span><br><span class=\"line\">\t<span class=\"function\">string <span class=\"title\">left</span><span class=\"params\">(<span class=\"string\">&quot;&#123;[(*&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">string <span class=\"title\">right</span><span class=\"params\">(<span class=\"string\">&quot;&#125;])&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">ifstream <span class=\"title\">iFile</span><span class=\"params\">(<span class=\"string\">&quot;3_21Sample.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">char</span>&gt; check;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">is_open</span>())</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\tiFile &gt;&gt; current;</span><br><span class=\"line\">\tprev = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!iFile.<span class=\"built_in\">eof</span>())</span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// push open symbol in stack</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (left.<span class=\"built_in\">find</span>(current) != string::npos) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(current !=<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; prev == <span class=\"string\">&#x27;/&#x27;</span>) <span class=\"comment\">// push in &#x27;/*&#x27;</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">push</span>(prev);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// no push action for current ==&#x27;*&#x27; prev !=&#x27;/&#x27;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If it is a closed symbol and stack is not empty, the corresponding symbol will pop up</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; prev == <span class=\"string\">&#x27;*&#x27;</span>) <span class=\"comment\">// special for &#x27;/&#x27;,&#x27;/&#x27; can be left or right</span></span><br><span class=\"line\">\t\t&#123; <span class=\"comment\">// for &#x27;*/&#x27;,no action for current ==&#x27;/&#x27; and stack is empty (/*....),</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(check.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//last mismatch closed symbol is a speical situation, which can not belong to error:eof()</span></span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; <span class=\"string\">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right.<span class=\"built_in\">find</span>(current) != string::npos)   <span class=\"comment\">// for (]&#125;</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (check.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// prevent top() error</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//last mismatch closed symbol is a speical situation, which can not belong to error:eof()</span></span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; <span class=\"string\">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;&#123;&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;[&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; check.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tcheck.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>; <span class=\"comment\">// error: top stack symbol mismatch → eof() is false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tprev = current;</span><br><span class=\"line\">\t\tiFile &gt;&gt; current; <span class=\"comment\">// read next character in buffer</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// judge</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">eof</span>() )</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!check.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;open symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Successful!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"JdH6s\"></a></p>\n<h3 id=\"4-中缀表达式转后缀表达式\"><a class=\"markdownIt-Anchor\" href=\"#4-中缀表达式转后缀表达式\"></a> 4. 中缀表达式转后缀表达式</h3>\n<p>1.为什么在向栈中压入运算符时，要先弹出优先级更高的运算符</p>\n<blockquote>\n<p>运算符的出栈顺序代表了运算符的执行顺序。显然的，优先级更高的运算符最先打印并出栈，即在后缀表达式中代表最早参与运算</p>\n</blockquote>\n<p>2.为什么直到碰到右括号<code>)</code>之前，不弹出左括号<code>(</code>，遇到右括号<code>)</code>后,弹出栈元素直到遇到<code>(</code></p>\n<blockquote>\n<p>该操作的意思是弹出括号内的所有运算符，显然的，括号内的各运算符优先级高于括号外的运算符</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">infixToPostFix</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">ifstream <span class=\"title\">iFile</span><span class=\"params\">(<span class=\"string\">&quot;3_23Sample.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">is_open</span>())</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\tstring operators = <span class=\"string\">&quot;()+-/*&quot;</span>;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">char</span>&gt;keepOptors;</span><br><span class=\"line\">\t<span class=\"type\">char</span> current;</span><br><span class=\"line\">\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!iFile.<span class=\"built_in\">eof</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (operators.<span class=\"built_in\">find</span>(current) != string::npos)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (keepOptors.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// initial</span></span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (operators.<span class=\"built_in\">find</span>(keepOptors.<span class=\"built_in\">top</span>(), <span class=\"number\">2</span>)!= string::npos) <span class=\"comment\">//top item is +, -,* or /</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>()&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (keepOptors.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(current ==<span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (operators.<span class=\"built_in\">find</span>(keepOptors.<span class=\"built_in\">top</span>(), <span class=\"number\">3</span>)) <span class=\"comment\">//top item is -,* or /</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>()&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (keepOptors.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;*&#x27;</span> || current == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;)&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (keepOptors.<span class=\"built_in\">top</span>() != <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>()&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkeepOptors.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// pop up &#x27;(&#x27;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tcout &lt;&lt; current &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!keepOptors.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; keepOptors.<span class=\"built_in\">top</span>() &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tkeepOptors.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"Kvu8h\"></a></p>\n<h3 id=\"5-后缀表达式转中缀表达式\"><a class=\"markdownIt-Anchor\" href=\"#5-后缀表达式转中缀表达式\"></a> 5. 后缀表达式转中缀表达式</h3>\n<p>想法与计算后缀表达式差不多，注意两个地方</p>\n<blockquote>\n<p>1.优先参与运算的运算符的运算结果是下一个运算符的操作数，想想怎么把表达式连接成一个整体<br>\n2.为每个计算式加上括号，确保在最终的中缀表达式中能清晰的表达计算顺序，如 8<em>5+3 与 (8</em>(5+3))</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postfixToInfix</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tstack&lt;string&gt; expr;</span><br><span class=\"line\">\t<span class=\"function\">ifstream <span class=\"title\">iFile</span><span class=\"params\">(<span class=\"string\">&quot;3_22Sample.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iFile.<span class=\"built_in\">is_open</span>())</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">\tstring first, second;</span><br><span class=\"line\">\t<span class=\"type\">char</span> current;</span><br><span class=\"line\">\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!iFile.<span class=\"built_in\">eof</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"number\">48</span> &lt;= current &amp;&amp; current &lt;= <span class=\"number\">57</span>)</span><br><span class=\"line\">\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"built_in\">string</span>(<span class=\"number\">1</span>,current));</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfirst = expr.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\t\texpr.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\tsecond = expr.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\t\texpr.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span>+first + <span class=\"string\">&#x27;*&#x27;</span>+second+<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span>+first +<span class=\"string\">&#x27;/&#x27;</span>+ second + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span> + first + <span class=\"string\">&#x27;+&#x27;</span> + second + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\texpr.<span class=\"built_in\">push</span>(<span class=\"string\">&#x27;(&#x27;</span> + first + <span class=\"string\">&#x27;-&#x27;</span> + second + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tiFile &gt;&gt; current;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; expr.<span class=\"built_in\">top</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"OSFAk\"></a></p>\n<h3 id=\"6-逆向打印链表的两个方法\"><a class=\"markdownIt-Anchor\" href=\"#6-逆向打印链表的两个方法\"></a> 6. 逆向打印链表的两个方法</h3>\n<p><a name=\"UuJnf\"></a></p>\n<h4 id=\"1链表反转\"><a class=\"markdownIt-Anchor\" href=\"#1链表反转\"></a> 1.链表反转</h4>\n<p>改变单向链表的结构，反转其方向。需要用到三个结点的信息<code>prev、current、next</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Reverse_List</span><span class=\"params\">()</span>  <span class=\"comment\">// O(1)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* prev, *current, *cNext;</span><br><span class=\"line\">\t\tprev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\tcurrent = head-&gt;next;</span><br><span class=\"line\">\t\tcNext = current-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cNext != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcurrent-&gt;next = prev; <span class=\"comment\">// reverse direction</span></span><br><span class=\"line\">\t\t\tprev = current;</span><br><span class=\"line\">\t\t\tcurrent = cNext;</span><br><span class=\"line\">\t\t\tcNext = current-&gt;next; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcurrent-&gt;next = prev;</span><br><span class=\"line\">\t\thead-&gt;next = current; <span class=\"comment\">// head to tail</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; current-&gt;value &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\tcurrent = current-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意同时声明多个指针时，不能写成<code>Node* prev, current, cNext</code>，这种声明下<code>current、cNext</code>是int型，只有一个<code>prev</code>是指针类型。应改为<code>Node* prev, *current, *cNext;</code></p>\n</blockquote>\n<p><a name=\"aAKjU\"></a></p>\n<h4 id=\"2利用栈\"><a class=\"markdownIt-Anchor\" href=\"#2利用栈\"></a> 2.利用栈</h4>\n<p>逆向打印可以利用栈先进后出的性质实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Reverse_Print_With_Stack</span><span class=\"params\">()</span> <span class=\"comment\">//  O(N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stack&lt;T&gt; storage;</span><br><span class=\"line\">    Node* p = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        storage.<span class=\"built_in\">push</span>(p-&gt;value);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!storage.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; storage.<span class=\"built_in\">top</span>() &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        storage.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"QwIKh\"></a></p>\n<h3 id=\"7-环形缓冲区的满vs空问题\"><a class=\"markdownIt-Anchor\" href=\"#7-环形缓冲区的满vs空问题\"></a> 7. 环形缓冲区的满vs空问题</h3>\n<p>用<strong>数组</strong>实现队列通常有两种方式</p>\n<ol>\n<li>head 指向队列头，即第一个元素，tail 指向新元素即将插入的位置，即最后一个元素的下一个位置，enque后tail+1 (初始状态：head = tail = 0)</li>\n<li>head 指向队列头，tail指向最后一个元素，enque前tail+1 （初始状态：front = 0 , tail = -1）</li>\n</ol>\n<p>两种情况下，均要保持队列最后一个元素不能使用，(n-1) 长度队列可以用长度为 n 的数组创建</p>\n<ol>\n<li>\n<br>\n</li>\n</ol>\n<p>empty：<code>head = tail  </code><br>full：<code>head = (tail+1) % maxSize</code>  <br>如果完全填充数组，那么会导致full和empty情况下，均满足<code>head = tail </code></p>\n<ol start=\"2\">\n<li>\n<br>\n</li>\n</ol>\n<p>empty : <code>head = (tail+1) % maxSize</code>  <br>full：<code>head = (tail+2) % maxSize</code> ？<br>如果完全填充数组，那么会导致full和empty情况下,均满足<code>head = (tail+1) % maxSize</code><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1660033289402-7374663e-99df-4e23-8d39-2bcb71e5622a.png\" alt=\"image.png\"><br>\n<a name=\"mDKbV\"></a></p>\n<h3 id=\"8-判断链表是否有环的两个方法\"><a class=\"markdownIt-Anchor\" href=\"#8-判断链表是否有环的两个方法\"></a> 8. 判断链表是否有环的两个方法</h3>\n<blockquote>\n<ol>\n<li>用<code>hashset</code>存储遍历过的节点，用新节点对比，有重复则存在环</li>\n<li>双指针遍历，速度不同，相遇则存在环</li>\n</ol>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">detectloop</span><span class=\"params\">(Node&lt;T&gt;* head)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode&lt;T&gt;* first, * second;</span><br><span class=\"line\">\t\tfirst = second = head;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*A walks faster than B, so only A is judged.</span></span><br><span class=\"line\"><span class=\"comment\">\t\tIf A is the last node, you need to judge A-&gt;next*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (first != <span class=\"literal\">nullptr</span> &amp;&amp; first-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfirst = first-&gt;next-&gt;next; <span class=\"comment\">// two step</span></span><br><span class=\"line\">\t\t\tsecond = second-&gt;next; <span class=\"comment\">// one step</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (first == second)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; <span class=\"string\">&quot;exist loop&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;no loop&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>涉及的算法：<a href=\"https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/\">Floyd’s Cycle Finding Algorithm</a></p>\n</blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/31401474\">知乎：如何判断链表有环</a><br><a href=\"https://leetcode.com/problems/linked-list-cycle/discuss/1829489/C%2B%2B-oror-Easy-To-Understand-oror-2-Pointer-oror-Fast-and-Slow\">LeetCode：Linked List Cycle</a><br>\n<a name=\"qdbBD\"></a></p>\n<h2 id=\"other-questions\"><a class=\"markdownIt-Anchor\" href=\"#other-questions\"></a> other questions：</h2>\n<ol>\n<li><strong>stackoverflow示例中总是出现的foo ，bar 是什么意思</strong></li>\n</ol>\n<p>foo：File or Object，文件或对象。它用于代替对象变量或文件名，用于代码演示<br>bar：与foo的作用一样，表示变量或文件，用于代码演示2.VS2019调出监视窗口的办法</p>\n<ol start=\"2\">\n<li><strong>vs2019中调式调出监视窗口</strong></li>\n</ol>\n<p>设置断点，运行程序<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1658310883417-a80aaf32-ea48-40bb-b554-2c6d8960689b.png\" alt=\"屏幕截图 2022-07-20 175431.png\"></p>\n<ol start=\"3\">\n<li><strong>git上传项目到github</strong></li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/369486197\">知乎：github基础教学</a><br>\n<a name=\"IthCG\"></a></p>\n<h2 id=\"remaining-problem\"><a class=\"markdownIt-Anchor\" href=\"#remaining-problem\"></a> remaining problem</h2>\n<ol>\n<li><strong>在vector中实现erase(iterator pos)</strong></li>\n</ol>\n<p>涉及萃取</p>\n<ol start=\"2\">\n<li><strong>实现能够指定容器的stack类</strong></li>\n<li><strong>STL stack: emplace() vs push()</strong></li>\n</ol>\n<p>涉及右值引用，移动构造(?)</p>\n<ol start=\"4\">\n<li><strong>判断链表是否有环，为什么不直接判断最后一个节点指向是否为nullptr</strong></li>\n</ol>\n<p>我认为可能的原因：当最后一个节点指向本身时，其next也不为nullptr，而此时单链表中不存在环，所以该方法不适用。</p>\n<hr>\n<p><a name=\"oX3jS\"></a></p>\n<h1 id=\"chapter-2-trees\"><a class=\"markdownIt-Anchor\" href=\"#chapter-2-trees\"></a> Chapter 2 Trees</h1>\n<p><a name=\"JBUuP\"></a></p>\n<h2 id=\"record\"><a class=\"markdownIt-Anchor\" href=\"#record\"></a> record:</h2>\n<p><a name=\"oEiO6\"></a></p>\n<h3 id=\"1-二叉查找树类中为什么要额外添加功能与公有函数相同但参数不同的同名私有函数\"><a class=\"markdownIt-Anchor\" href=\"#1-二叉查找树类中为什么要额外添加功能与公有函数相同但参数不同的同名私有函数\"></a> 1. 二叉查找树类中为什么要额外添加功能与公有函数相同，但参数不同的同名私有函数</h3>\n<p>在类外调用公有函数，而公有函数内部需要递归处理左右子树，需要传入新的根节点，所以需要有额外的能传入根节点参数的函数，因为这类函数只被公有函数所使用，所以设置为私有（辅助函数）<br><a href=\"https://stackoverflow.com/questions/4505938/when-why-to-make-function-private-in-class\">stackoverflow：When/why to make function private in class?</a><br>\n<a name=\"DpaEu\"></a></p>\n<h3 id=\"2搜索二叉树的insert成员函数结点指针t必须引用传递的原因\"><a class=\"markdownIt-Anchor\" href=\"#2搜索二叉树的insert成员函数结点指针t必须引用传递的原因\"></a> 2.搜索二叉树的insert成员函数结点指针t必须引用传递的原因</h3>\n<p>如果采用值传递，那么函数insert中的指针将是实参的副本，在函数insert中修改该副本，不能达到修改结点p的成员变量left or right的目的, remove函数同理<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1661568230165-1e7336ea-23dc-443d-afa4-e35e7a5a4058.jpeg\" alt><br>\n<a name=\"WEgNR\"></a></p>\n<h3 id=\"3-平衡二叉树\"><a class=\"markdownIt-Anchor\" href=\"#3-平衡二叉树\"></a> 3. 平衡二叉树</h3>\n<p>对BST的find操作，其运行时间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(d)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>为结点的深度。给定一系列值，不同的插入序列对应不同的树结构，有着不同的平均结点深度，进而有不同的查找效率。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1661156478689-efe3aeff-b060-4bc9-80ee-099b96f5aa02.png\" alt=\"image.png\"><br>创建高度为h的AVL树所需的最少结点数为斐波那契数列第h+2项的值减1（高度和项数均从0计数）<br>\n<a name=\"FZLgt\"></a></p>\n<h2 id=\"remaining-problem-2\"><a class=\"markdownIt-Anchor\" href=\"#remaining-problem-2\"></a> remaining problem</h2>\n<p><a name=\"Le4pv\"></a></p>\n<h3 id=\"1-给定一系列值确定构造bst的方法个数\"><a class=\"markdownIt-Anchor\" href=\"#1-给定一系列值确定构造bst的方法个数\"></a> 1. 给定一系列值，确定构造BST的方法个数</h3>\n<p><a href=\"https://stackoverflow.com/questions/17119116/how-many-ways-can-you-insert-a-series-of-values-into-a-bst-to-form-a-specific-tr\">stackoverflow：How many ways can you insert a series of values into a BST to form a specific tree?</a></p>\n<hr>\n<p><a name=\"Cieup\"></a></p>\n<h1 id=\"chapter-3-hashing\"><a class=\"markdownIt-Anchor\" href=\"#chapter-3-hashing\"></a> Chapter 3 Hashing</h1>\n<p><a name=\"RQFF9\"></a></p>\n<h2 id=\"1-为什么哈希表只能惰性删除lazy-deletion\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么哈希表只能惰性删除lazy-deletion\"></a> 1. 为什么哈希表只能惰性删除(lazy deletion)</h2>\n<p>答：在插入其它元素A时，A可能与待删除元素B发生过冲突(collision),即可能有<code>myhash(A) == myhash(B)</code>,也可能是A在向前探测的过程中与B发生过冲突。 如果删除元素B，那么在寻找A就会失败，因为此时B所在的位置是EMPTY，那么findPos(A)在B的位置上会返回currentPos,查找结束，但currentPos是EMPTY而不是A所在的值。<br>\n<a name=\"mwjke\"></a></p>\n<h2 id=\"2-为什么要有哈希表是怎么达到高效性的\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么要有哈希表是怎么达到高效性的\"></a> 2. 为什么要有哈希表？是怎么达到高效性的？</h2>\n<p>为了在<strong>常数时间</strong>内高效实现对数据的插入，删除，查找操作。 通过<strong>哈希函数</strong>（通常是 <code>hash(x) % tableSize</code>,<code>hash(x)</code>的作用是将x转化为数字，由key类提供，如果x本身就是数字，那么hash(x) = x），让待插入数据<strong>直接定位</strong>到哈希表中的一个位置（哈希表是什么？ 一个固定大小的存储项的数组， 哈希 = 散列）<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1664794253808-1aee7326-a1c4-44c2-986e-5ca40efa4d87.jpeg\" alt><br>\n<a name=\"Hcjq3\"></a></p>\n<h2 id=\"3-冲突collision是什么怎么解决冲突的\"><a class=\"markdownIt-Anchor\" href=\"#3-冲突collision是什么怎么解决冲突的\"></a> 3. 冲突(collision)是什么？怎么解决冲突的？</h2>\n<p>不同的数据可能会被哈希函数映射到相同的位置，而一个位置只能属于一个数据，因此产生了冲突。为解决冲突，很简单是想法就是：<strong>既然原本属于它的位置被占用了，那就将数据移到可以存放的空位置</strong><br>如何找到这个空位置呢？有两种方法</p>\n<ol>\n<li><strong>分离链接法（separate chaining）:</strong></li>\n</ol>\n<p>既然冲突是因为一个位置只能存放一个数据，那么引入链表以实现一个位置能够存放多个数据，冲突便解决了。哈希表中的一个位置对应一条链表，显然的，在某个位置发生的冲突越多，那么这条链表就越长。无论是执行查找还是删除操作，都要先找到链表（由哈希函数得到），再在链表里面找到数据。</p>\n<ol start=\"2\">\n<li><strong>开放定址法（open addressing）：</strong></li>\n</ol>\n<p>往前探测（probe），形式化为公式就是<code>hashi(x) = (hash(x) + f(i))</code>,<strong>i表示向前探测的次数</strong>，f(i)称为冲突解决策略（collision resolution strategy）,显然<code>f(0)=0</code>。根据f(i)形式的不同，分为线性(Linear)探测:<code>f(i)=i</code>、平方(quadratic)探测:<code>f(i) = i2</code>、双(double)散列:<code>f(i) = i*hash2(x)</code><br>**线性探测会引起一次聚集（<strong>primary cluster</strong>），平方探测会引起二次聚集（<strong>Secondary Clustering</strong>），**关于这一点：<a href=\"https://stackoverflow.com/questions/27742285/what-is-primary-and-secondary-clustering-in-hash\">stackoverflow：What is primary and secondary clustering in hash?</a> 说的很清楚<br>为什么一次聚集对性能的影响会比二次聚集更大呢？首先要知道，聚集之所以会影响性能，是因为聚集导致hashPos之后的位置大部分被占用，进而导致探测次数增加。一次聚集是无间隔的聚集，那么只要在这堆聚集的项中发生了冲突，就基本上要一步一步的探测完所有聚集项才能找到空位置。而二次聚集是有间隔的，一次两步的探测会减少探测的发生。这个具体的描述比较困难，但是很好想。<br>双散列，消除了聚集问题，它应用了另一个哈希函数<code>hash2(x)</code>（<strong>哈希结果不能为0，则f(i)将失去意义</strong>），使得探测更趋于随机化，而不是集中在哈希位置附近。<br>注意点：</p>\n<ul>\n<li>哈希表的**大小(tableSize)为素数(Prime)**能更好的减少冲突的发生</li>\n<li><strong>tableSize为素数且λ&lt;0.5</strong>（有一半以上空项）时平方探测能保证插入成功。否则甚至不如线性探测，因为插入可能会失败（书上有证明）</li>\n<li>当计算哈希值代价较高时，性能角度上，双散列较之平方探测不是一个更好的选择</li>\n</ul>\n<p><strong>两个方法的对比：</strong> 前者不如后者，因为分离链表法会因为插入而分配新内存，这将降低执行效率；其次，分离链表法等于是哈希表与链表的结合，等于要求实现了另一种数据结构(而不是哈希表)，提高了程序的复杂性</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findPos</span><span class=\"params\">(<span class=\"type\">const</span> hashedObj&amp; x)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> currentPos = <span class=\"built_in\">myhash</span>(x);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> offset = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (array[currentPos].info != Empty &amp;&amp; array[currentPos].element != x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcurrentPos += offset;</span><br><span class=\"line\">\t\t\toffset = <span class=\"built_in\">pow</span>(offset,<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (currentPos &gt;= array.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t\t\t\tcurrentPos -= array.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> currentPos;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"vpuOb\"></a></p>\n<h2 id=\"4-为什么要再散列rehashing再散列要怎么做\"><a class=\"markdownIt-Anchor\" href=\"#4-为什么要再散列rehashing再散列要怎么做\"></a> 4. 为什么要再散列(rehashing)？再散列要怎么做？</h2>\n<p>当哈希表过于满(too full，λ too big)，查找操作将会变得非常缓慢（如之前所说，探测次数会非常多），进而影响插入和删除操作。解决这个困境的办法就是扩大哈希表以降低λ。<br>做法是：创建一个表长为大于2倍当前长度的第一个素数的新表（如当前长度是7，扩大后为17），相应的也产生了新的哈希函数，接着把原表中的所有数据通过新的哈希函数映射到新表中。<br>怎么界定哈希表是否需要再散列，一个好的方法是：当λ到达某个界定值时</p>\n<hr>\n<p><a name=\"OulqF\"></a></p>\n<h1 id=\"chapter-4-heap\"><a class=\"markdownIt-Anchor\" href=\"#chapter-4-heap\"></a> Chapter 4 Heap</h1>\n<p><a name=\"KirP0\"></a></p>\n<h2 id=\"1-为什么要有二叉堆binary-heap-是怎么达到高效的\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么要有二叉堆binary-heap-是怎么达到高效的\"></a> 1. 为什么要有二叉堆(Binary Heap)? 是怎么达到高效的？</h2>\n<p>为了实现<strong>优先级队列(priority queue)</strong>，即根据不同对象间的优先级排列而形成的队列，如操作系统中进程的优先级队列。相比于用队列(Queue)实现的根据对象到来的时间属性而确定优先级队列(即First Come First Served), 我们希望有一种数据结构，它有着更加灵活的优先级批判标准，而不是只看任务的到达时间。不仅如此，为了高效性，我们希望这个数据结构能够快速的找出队列中优先级最大的那一个。<br>由此我们引出二叉堆，二叉堆是一个**底层为数组的完全二叉树(complete binary tree)，**有结构性质和堆序性质<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1665135196819-0f05c687-059e-4b79-9c73-9c31e16de204.png\" alt=\"image.png\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> Comparable&amp; x)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (heapSize == array.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tarray.<span class=\"built_in\">resize</span>(array.<span class=\"built_in\">size</span>() * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> hole = ++heapSize;</span><br><span class=\"line\">\t\tComparable copy = x;</span><br><span class=\"line\">\t\tarray[<span class=\"number\">0</span>] = std::<span class=\"built_in\">move</span>(copy);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; x &lt; array[hole / <span class=\"number\">2</span>]; hole /= <span class=\"number\">2</span>)  <span class=\"comment\">// percolate up</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tarray[hole] = std::<span class=\"built_in\">move</span>(array[hole / <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarray[hole] = std::<span class=\"built_in\">move</span>(array[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteMin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\thole = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tComparable x = std::<span class=\"built_in\">move</span>(array[heapSize--]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; hole &lt;= heapSize; hole*=<span class=\"number\">2</span>) <span class=\"comment\">// percolate down</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchild = <span class=\"number\">2</span> * hole;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child != heapSize &amp;&amp; array[child] &lt; array[child + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t\t++child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x &gt; array[child])</span><br><span class=\"line\">\t\t\t\tarray[hole] = std::<span class=\"built_in\">move</span>(array[child]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarray[hole] = std::<span class=\"built_in\">move</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = heapSize / <span class=\"number\">2</span>; i &gt; <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">percolateDown</span>(i);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a name=\"eHZpk\"></a></p>\n<h1 id=\"chapter-5-sorting\"><a class=\"markdownIt-Anchor\" href=\"#chapter-5-sorting\"></a> Chapter 5 Sorting</h1>\n<p><a name=\"SWGCy\"></a></p>\n<h2 id=\"insertion_sort\"><a class=\"markdownIt-Anchor\" href=\"#insertion_sort\"></a> Insertion_Sort</h2>\n<p><a name=\"Hw7N9\"></a></p>\n<h3 id=\"1-怎么插入的为什么结果能有序\"><a class=\"markdownIt-Anchor\" href=\"#1-怎么插入的为什么结果能有序\"></a> 1. 怎么插入的？为什么结果能有序？</h3>\n<p>对序列(Comparable)，假定第一个数据(array[0])是有序的，把从第二项到末尾的数据逐个插入到开头的有序序列中。<br>怎么插入的？将待插入项<code>tmp</code>与有序序列中的项逐个比较，遇到<code>array[i]&gt;tmp</code>(升序序列)，则将有序序列中的元素右移，为<code>tmp</code>提供插入位，接着插入<code>tmp</code>。等价于将位置为p的项放入前p+1项(从0开始索引)的正确位置(从小到大)。如果数组本身就比较有序，那么可以省去不少插入操作<br>为什么能有序？ straightforward，我觉得有些许减治法的感觉，先解决小问题，逐步解决大问题。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(std::vector&lt;Comparable&gt;&amp; array)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = array.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt; N; ++p)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tComparable tmp = std::<span class=\"built_in\">move</span>(array[p]);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = p - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; tmp &lt; array[j]; --j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tarray[j + <span class=\"number\">1</span>] = std::<span class=\"built_in\">move</span>(array[j]); <span class=\"comment\">// j move right, p move left</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarray[j + <span class=\"number\">1</span>] = std::<span class=\"built_in\">move</span>(tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a name=\"AXqXN\"></a></p>\n<h2 id=\"shell_sort\"><a class=\"markdownIt-Anchor\" href=\"#shell_sort\"></a> Shell_Sort</h2>\n<p><a name=\"NvzxL\"></a></p>\n<h3 id=\"1-为什么说希尔排序涉及了插入排序\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么说希尔排序涉及了插入排序\"></a> 1. 为什么说希尔排序涉及了插入排序？</h3>\n<p>因为希尔排序先将序列分组，然后在组内进行插入排序<br>\n<a name=\"rqY4s\"></a></p>\n<h3 id=\"2-希尔排序是如何分组的\"><a class=\"markdownIt-Anchor\" href=\"#2-希尔排序是如何分组的\"></a> 2. 希尔排序是如何分组的？</h3>\n<p>使用一组增量h1，h2，h3， . . . , ht(就是代表了不同的跨度，h1 =1)。第一阶段，对任意位置i，把array[i]，array[i+ht]，array[i+2ht]…分为一组执行插入排序；第二阶段，对任意位置i，把array[i]，array[i+ht-1]，array[i+2ht-1]…分为一组执行插入排序。显然的，在最后阶段，使用增量h1=1时就是对整个序列执行插入排序。<br>选择合适的增量能使插入排序的时间复杂度低于插入排序，如 Hibbard增量： 1, 3, 7, . . . , 2k − 1。<br><strong>执行一个增量为h<strong><strong>k</strong></strong>的排序(hk-Sort)，等价于对h<strong><strong>k</strong></strong>个子数组(subarray)执行插入排序(见下图)</strong>。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1665481444552-78d1a034-c95c-462b-b080-475d22f10d1c.jpeg\" alt><br>\n<a name=\"yUWsx\"></a></p>\n<h3 id=\"3-希尔排序是如何改进插入排序的-执行名副其实的插入排序前h1分组的作用是什么\"><a class=\"markdownIt-Anchor\" href=\"#3-希尔排序是如何改进插入排序的-执行名副其实的插入排序前h1分组的作用是什么\"></a> 3. 希尔排序是如何改进插入排序的? 执行名副其实的插入排序前(h1)，分组的作用是什么？</h3>\n<p>分组的作用是对数组执行<a href=\"https://zhuanlan.zhihu.com/p/87781731\">预排序</a>，即在执行真正的插入排序前先使数组比较有序，以减少执行插入操作的次数。显然插入排序在1.元素个数少 2. 数组比较有序 的情况下执行效率高。分组营造了前一个条件以高效排序子数组，并为逐步减少分组的增量(跨度)以排序数组中的更多元素提供了第二个条件。所以显然的，希尔排序优于插入排序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shell_Sort</span><span class=\"params\">(std::vector&lt;Comparable&gt; array)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = array.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> gap = N/<span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// insertion Sort</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = gap; p &lt; N; ++p)   <span class=\"comment\">// point: ++p here</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = p - gap;</span><br><span class=\"line\">\t\t\tComparable tmp = std::<span class=\"built_in\">move</span>(array[p]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp;  array[j] &gt; tmp; j-=gap)</span><br><span class=\"line\">\t\t\t\tarray[j + gap] = std::<span class=\"built_in\">move</span>(array[j]);</span><br><span class=\"line\">\t\t\tarray[j + gap] = std::<span class=\"built_in\">move</span>(tmp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a name=\"ZZpJ6\"></a></p>\n<h2 id=\"heap_sort\"><a class=\"markdownIt-Anchor\" href=\"#heap_sort\"></a> Heap_Sort</h2>\n<p><a name=\"mMQHg\"></a></p>\n<h3 id=\"1-如何利用堆实现排序\"><a class=\"markdownIt-Anchor\" href=\"#1-如何利用堆实现排序\"></a> 1. 如何利用堆实现排序</h3>\n<p>要利用堆(heap)将一个乱序的数组变成有序的数组，显然的，要首先构造一个堆(build heap)，即利用heapify的方法将N个元素组成堆的结构(本质还是数组)；接着，对这个堆执行N-1次<code>deleteMax</code>(或<code>deleteMin</code>)操作，在每次执行删除操作时，将删除的元素填入刚刚空出来的最后一个元素的位置上；最后能得到一个递增序列(最大堆)或递减序列(最小堆)。<br>关键是要认识到，在本质上，对堆执行deleteMax操作，是将堆的最后一个元素(<code>array[HeapSize]</code>)填在根(<code>array[0]</code>)的位置(覆盖原有的根值),接着把这个结点通过下滤(percolate down)放在合适位置。较之堆删除，堆排序只改变了一个操作，那就是把这个覆盖的过程，变成一个交换(swap)的过程。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1665664167534-eee32f0c-0cba-487b-a1aa-b684f3f02866.png\" alt=\"image.png\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(vector&lt;Comparable&gt; &amp; objects)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// bulid heap</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = objects.<span class=\"built_in\">size</span>()/<span class=\"number\">2</span><span class=\"number\">-1</span>; j &gt;= <span class=\"number\">0</span>; --j)</span><br><span class=\"line\">\t\t<span class=\"built_in\">percDown</span>(objects, j, objects.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">\t<span class=\"comment\">//make a decreasing array</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = objects.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>; i&gt;<span class=\"number\">0</span>; --i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(objects[<span class=\"number\">0</span>], objects[i]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">percDown</span>(objects, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span>  <span class=\"title\">leftChild</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">percDown</span><span class=\"params\">(vector&lt;Comparable&gt; &amp;objects , <span class=\"type\">int</span> i, <span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tComparable tmp = <span class=\"built_in\">move</span>(objects[i]);</span><br><span class=\"line\">\t<span class=\"type\">int</span> child;<span class=\"comment\">// left child </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;<span class=\"built_in\">leftChild</span>(i) &lt; n; i = child)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tchild = <span class=\"built_in\">leftChild</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (child != n<span class=\"number\">-1</span> &amp;&amp; objects[child] &lt; objects[child + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t++child;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &lt; objects[child])</span><br><span class=\"line\">\t\t\tobjects[i] = <span class=\"built_in\">move</span>(objects[child]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tobjects[i] = <span class=\"built_in\">move</span>(tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"pNLGn\"></a></p>\n<h2 id=\"merge_sort\"><a class=\"markdownIt-Anchor\" href=\"#merge_sort\"></a> Merge_Sort</h2>\n<p><a name=\"cBdMT\"></a></p>\n<h3 id=\"1-归并排序是如何排序的为什么说体现了分而治之-divide-and-conquer的思想\"><a class=\"markdownIt-Anchor\" href=\"#1-归并排序是如何排序的为什么说体现了分而治之-divide-and-conquer的思想\"></a> 1. 归并排序是如何排序的，为什么说体现了分而治之( divide-and-conquer)的思想？</h3>\n<p>归并排序，最重要的基本操作就是<strong>将两个已排序的数组整合为一个</strong>，也就是Merge(合并)操作。要获取两个已排序的数组，首先将待排序的数组一分为二，然后对这两个子数组递归的调用归并排序（递归返回条件：子数组只剩一个元素<code> left &gt;= right</code>)。 <br>归并排序本质上是对<strong>逐步完成对子数组的排序进而完成大数组的排序</strong>。<br><strong>divide：将数组一分为二    conquer：Merge</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; objects, vector&lt;Comparable&gt;&amp; tmpA, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left &gt;= right) <span class=\"comment\">// recursive call&#x27;s end condition : only one element </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;  </span><br><span class=\"line\">\t<span class=\"type\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(objects, tmpA, left, center); <span class=\"comment\">// merge first half </span></span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(objects, tmpA, center + <span class=\"number\">1</span>, right);  <span class=\"comment\">// merge second half</span></span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(objects, tmpA, left, center + <span class=\"number\">1</span>, right); <span class=\"comment\">// patch</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; objects)</span>  <span class=\"comment\">// driver</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;Comparable&gt; <span class=\"title\">tmpA</span><span class=\"params\">(objects.size())</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(objects, tmpA, <span class=\"number\">0</span>, objects.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt; <span class=\"comment\">// merge two sorted array into one</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; objects, vector&lt;Comparable&gt;&amp; tmpA, <span class=\"type\">int</span> leftBegin, <span class=\"type\">int</span> rightBegin, <span class=\"type\">int</span> rightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> leftEnd = rightBegin - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmpAIndex = leftBegin;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = rightEnd - leftBegin + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftBegin &lt;= leftEnd &amp;&amp; rightBegin &lt;= rightEnd) <span class=\"comment\">// comparison between two halves</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (objects[leftBegin] &lt;= objects[rightBegin])</span><br><span class=\"line\">\t\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[leftBegin++]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[rightBegin++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftBegin &lt;= leftEnd) <span class=\"comment\">// copy the remainder</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[leftBegin++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (rightBegin &lt;= rightEnd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmpA[tmpAIndex++] = <span class=\"built_in\">move</span>(objects[rightBegin++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// how to write back to objects</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; ++i,--rightEnd )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tobjects[rightEnd] = <span class=\"built_in\">move</span>(tmpA[rightEnd]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/jpeg/29536731/1672988373854-be3e4874-5705-410b-8800-ad92faa15a40.jpeg\" alt><br>\n<a name=\"dIPOD\"></a></p>\n<h2 id=\"quick_sort\"><a class=\"markdownIt-Anchor\" href=\"#quick_sort\"></a> Quick_Sort</h2>\n<p><a name=\"SkElc\"></a></p>\n<h3 id=\"1-快速排序是如何排序的\"><a class=\"markdownIt-Anchor\" href=\"#1-快速排序是如何排序的\"></a> 1. 快速排序是如何排序的</h3>\n<p>与归并排序类似，快速排序也有分割数组的操作，但不同于归并排序一分为二的做法**，快速排序会先在数组中选取一个枢纽元(pivot)，然后把剩下的元素根据大于/小于pivot分为两组(group)，**产生两个子数组，放在pivot前后，接着递归的对子数组调用快速排序。<br>\n<a name=\"Tfhnl\"></a></p>\n<h3 id=\"2-为什么选择三数中值median-of-three-作为pivot的效率最高\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么选择三数中值median-of-three-作为pivot的效率最高\"></a> 2. 为什么选择三数中值(Median-of-Three )作为pivot的效率最高</h3>\n<p>这里的三数中值，指的是数组最左边<code>array[0]</code>，最右边<code>array[size-1]</code>，和中间<code>array[(left+right)/2]</code>这三个值中大小排中间的那个。<br><strong>选取pivot的原则是取尽可能靠近数组的中值(第 ⌈N/2⌉大的值)，这样做的目的是让分组(partition)后产生了两个子数组如归并排序般尽可能均匀，进而减少递归的层次。<strong>不随机选取三个数取中值的原因在于random函数的代价较高，会影响性能(不随机去一个pivot的原因也是如此)。直接选取第一个元素作为pivot是一个欠妥的做法，这样会导致算法在数组有预排序的情况下做无用功。<br><strong>为什么将三者的最小值放在</strong><code>**array[left]**</code></strong>？</strong> 因为最小值必然小于pivot，避免了一次多余的交换，同时这个left还能作为partition过程中<code>j</code>的哨兵(sentinel)，避免j越界。<br><strong>为什么将三者的最大值放在</strong><code>**array[right]**</code>**？**同理，避免了交换，但此处没有起到做哨兵的作用，因为我们会在选取pivot时就将pivot放在<code>array[right-1]</code>的位置,而i与j遇到equal to pivot的值都会停止，所以pivot也作为了<code>i</code>的哨兵。<br>\n<a name=\"XXNbN\"></a></p>\n<h3 id=\"3-如何分组\"><a class=\"markdownIt-Anchor\" href=\"#3-如何分组\"></a> 3. 如何分组？</h3>\n<p>我们的目标是把小于pivot的值放在数组左边，大于pivot的值放在数组右边。<strong>采取的策略时</strong><code>**i**</code><strong>从数组左边开始遍历，遇到大于pivot的值就停止(该值不属于左边)；</strong><code>**j**</code><strong>从数组右边开始遍历，遇到小于pivot的值就停止。接着交换</strong><code>**i**</code><strong>和</strong><code>**j**</code><strong>所在位置的元素。当i和j交叉时，把</strong><code>**pivot**</code><strong>与</strong><code>**i**</code><strong>所在位置的值交换</strong>(为什么是<code>i</code>而不是<code>j</code>？因为pivot预先被放在数组右边right-1的位置，如果被放在右边那pivot就是和<code>j</code>交换位置)<br>**如何处理等于pivot的元素？**先说结论，<code>**i**</code><strong>和</strong><code>**j**</code><strong>遇到这样的元素都要停下</strong>。<br>接着在极端情况(所有元素都一样)情况下讨论其它做法的低效性<br>**为什么不一个停下而另一个继续前进？**如果<code>i</code>停下而<code>j</code>不停下，则<code>i``j</code>交叉的位置会偏向左侧，而pivot要与i最后在的位置交换值，这样显然会导致子数组的大小不平衡。<br>**为什么不两个都不停下？**首先<code>i</code>，<code>j</code>显然可能会出界，即使存在<code>i``j</code>出界的代码，这样做会导致i最后所处的位置在靠近最右边的位置(取决于具体实现)，而pivot要与<code>i</code>交换位置，进而导致产生的子数组很不平衡，降低了算法效率<br>\n<a name=\"mt8ir\"></a></p>\n<h3 id=\"4-递归结束条件是什么什么是cutoff为什么要结合插入排序\"><a class=\"markdownIt-Anchor\" href=\"#4-递归结束条件是什么什么是cutoff为什么要结合插入排序\"></a> 4. 递归结束条件是什么？什么是cutoff？为什么要结合插入排序？</h3>\n<p>快速排序或许应该像归并排序那样，当子数组仅剩一个元素时递归返回。但是实际上并不这样设置递归返回条件，因为存在这样一个事实：<strong>当数组元素个数很少(5~20)时，快速排序的效率还不如插入排序。因此在partition之后如果子数组的大小小于某一界限(cutoff)，就停止递归调用，转而对子数组调用插入排序,进而提升算法的整体效率</strong><br>这里提到了<a href=\"https://stackoverflow.com/questions/70402/why-is-quicksort-better-than-mergesort\">快速排序与归并排序的区别</a>，还有的区别点是快速排序不占用额外的内存，快速排序使用的是<a href=\"https://stackoverflow.com/questions/33923/what-is-tail-recursion\">尾递归</a>等</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> Comparable <span class=\"title\">Median</span><span class=\"params\">(vector&lt;Comparable&gt; &amp; array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (array[left] &gt; array[right])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[left], array[right]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (array[center] &gt; array[right])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[center], array[right]); <span class=\"comment\">// keep left is min among three values</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (array[left] &gt; array[center])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[left], array[center]); <span class=\"comment\">// keep right is max among three values</span></span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(array[center], array[right - <span class=\"number\">1</span>]); <span class=\"comment\">// put pivot into position right-1 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> array[right - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; array, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> range = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (range &gt; <span class=\"number\">10</span>) <span class=\"comment\">// cutoff = 10</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tComparable pivot = <span class=\"built_in\">Median</span>(array, left, right);</span><br><span class=\"line\">\t\t<span class=\"comment\">// partition</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i = left; <span class=\"type\">int</span> j = right - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (array[++i] &lt; pivot); <span class=\"comment\">// increase before check , details see stackoverflow </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (array[--j] &gt; pivot);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(array[i], array[j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(array[i], array[right - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"comment\">// recursion</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(array, left, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(array, i + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">insertionSort</span>(array, left, right);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Driver</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Comparable&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;Comparable&gt;&amp; array)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">quickSort</span>(array, <span class=\"number\">0</span>, array.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"wPOyJ\"></a></p>\n<h1 id=\"chapter-6-disjoint-sets\"><a class=\"markdownIt-Anchor\" href=\"#chapter-6-disjoint-sets\"></a> Chapter 6 Disjoint Sets</h1>\n<p><a name=\"AHMCd\"></a></p>\n<h2 id=\"1-什么是不相交集什么是unionfind操作\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是不相交集什么是unionfind操作\"></a> 1. 什么是不相交集？什么是union/find操作？</h2>\n<p>对于一个集合S，由一个关系R可将S划分为多个<a href=\"https://www.zhihu.com/question/276100093/answer/388155191\">等价类</a>(equivalence class)，在一个等价类中的所有元素之间均存在关系R(即任意a，b ∈ S, a~b)。显然的，要判断任意给定的S中的元素a，b是否有关系，只需判断a,b是否属于同一个等价类，这也说明了<strong>等价类概念的提出是为了给出一个快速判断a,b是否存在关系的方法(我的理解)</strong>。显然的，等价类是S的一个子集(set)，一个元素也只属于一个等价类，<strong>不同的等价类们就是本章要讨论的不相交集(disjoint sets）</strong><br>什么是union/find操作？先查找元素a和b所在的等价类(find操作)，然后判断是不是同一个等价类(find(a) == find(b) ？ ),that is，<strong>判断a,b是否有关系。如果没有，就将a,b联系起来，也就是变得有关系</strong>，即将a,b的等价类合并为一个新的等价类(注意关系的传递性(Transitive)，a,b如果有关系，那么两者原来所在集合的所有元素间也存在了关系)，合并的过程就是union操作。如果本身就有关系，就不用操作了。<br>\n<a name=\"x95GB\"></a></p>\n<h2 id=\"2-如何表示不相交集\"><a class=\"markdownIt-Anchor\" href=\"#2-如何表示不相交集\"></a> 2. 如何表示不相交集？</h2>\n<p>初始状态，对于N个元素的集合S，假设N个元素间均不存在关系，因此有N个不相交集(每个集合仅有一个元素)。因为不存在comparison操作，所以我们并不在意元素的值是多少，因此我们<strong>把N个元素以0~N-1编号</strong>。<br>我们<strong>用树来表示一个集合，并把树的根作为集合的名字</strong>(某个元素编号)。初始状态时，每个集合名统一表示为-1。<br><strong>树形态的不相交集不具备完全二叉树(堆)那样的规整性，为什么可以用数组来实现？<strong>因为对于每个元素我们只关心它所在的集合是哪个，即它所在的树的根是哪个，因此</strong>对于每个元素，我们仅需知道它所在的树的根值</strong>即可。不仅如此，数组的从0开始下标也与我们的编号符合，因此可以<strong>用大小为N的数组存储0~N-1个元素的父节点（即对第i个数组项，array[i]存储了编号i的父结点），提供了一个由任意结点开始向上遍历即可获取根结点（that is ，任意结点所在集合名）的途径。</strong><br>\n<a name=\"XuWqo\"></a></p>\n<h2 id=\"3-unionfind-如何执行\"><a class=\"markdownIt-Anchor\" href=\"#3-unionfind-如何执行\"></a> 3. Union/find 如何执行 ？</h2>\n<p>find操作要找到元素A所在树的根，即对A结点沿根节点方向向上遍历，直到数组值为 -1(<code>sets[i] &lt; 0</code>)，说明此数组编号为根节点(<code>return x</code>)。这其实就是一个不断获取父节点的过程，可使用递归。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> <span class=\"type\">const</span>  </span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sets[x] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(sets[x]); <span class=\"comment\">// recursive</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Union操作<strong>要合并两个集合，只需要将一个集合的根结点，链接到另一个集合的根节点上</strong>，因为在我们的方法中，根节点才是集合的唯一标识。具体来说，假设root1(同样的，是一个编号)是某个集合的根结点(即，集合名)，root2是另一个集合的根节点，执行Union，就是执行array[root1] = root2 (执行前：array[root1] == array[root2] == -1 ; 执行后：array[root1] == root2 , array[root2] == -1)<br>如果实参不是根，而是元素编号，则需额外执行两次find</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unions</span><span class=\"params\">(<span class=\"type\">int</span> root1, <span class=\"type\">int</span> root2)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tsets[root2] = root1;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>显然的，因为数组是一个支持随机存取的数据结构，则获取set[x]的值是常数时间(that is O(1) )，find操作真正耗时的是向上探索的过程，也就是说<strong>影响find操作的主要是结点所在的深度</strong>。<br>\n<a name=\"xnSpG\"></a></p>\n<h2 id=\"4-如何改进union\"><a class=\"markdownIt-Anchor\" href=\"#4-如何改进union\"></a> 4. 如何改进Union</h2>\n<p>上述合并是有问题的，把两颗相同高度的树合并，或通过把一颗高树(larger height)根节点链接到一颗矮树的根节点以实现两颗不同高度树的合并，均<strong>会使新树的高度比原来最大的那颗还要多一，即增加了各结点的深度，这样会极大影响find的效率(根节点最大高度为N-1)</strong>。因此我们需要改进合并的方法。<br>很自然的想法就是<strong>把矮树的根节点链接到高树的根节点</strong>(注意本章所用的树不是二叉树，而是一颗多路树)，这样新树的高度还会保持与原来高树的一致；如果两棵树高度相同，那么谁链接到谁都可以，结果都会使新树高度增1(所以根节点最大高度为log2N)<br>如何确定高树和矮树？显然的，<strong>我们需要跟踪每棵树的高度，可以用现有的数组存储，原先根节点的数组值为-1，现在将其改写为其所代表集合的高度的负数</strong>(为什么是负数？或许是为了方便find函数的判断语句更好编写:<code>if (sets[x] &lt; 0 return x;</code>注意之前提到设置各集合初始值为-1，也与这里符合)<br>也可以根据数的大小(size)决定谁链接到谁，但显然由高度做决定更好</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unionSets</span><span class=\"params\">(<span class=\"type\">int</span> root1, <span class=\"type\">int</span> root2)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sets[root2] &lt; sets[root1]) <span class=\"comment\">// set[root] keep track of height(negative)</span></span><br><span class=\"line\">\t\t\tsets[root1] = root2; <span class=\"comment\">// root2 is deeper</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sets[root2] == sets[root1])</span><br><span class=\"line\">\t\t\t\t--sets[root1];</span><br><span class=\"line\">\t\t\tsets[root2] = root1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"unJoe\"></a></p>\n<h2 id=\"5-如何改进find\"><a class=\"markdownIt-Anchor\" href=\"#5-如何改进find\"></a> 5. 如何改进find</h2>\n<p>在寻找编号为x的元素的根的过程中，我们使用<strong>路径压缩(Path Compression)<strong>的方法(自调整)，即</strong>把从x到root之间所有结点的父节点均改为根节点。</strong><br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29536731/1666421236514-c4f89687-71a5-42a4-b5fe-19f8f379487a.png\" alt=\"image.png\"><br>具体做法是<strong>递归的将根节点的编号赋值给路径上的结点</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sets[x] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sets[x] = <span class=\"built_in\">find</span>(sets[x]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"fO0SW\"></a></p>\n<h1 id=\"chapter-7-graph-algorithms\"><a class=\"markdownIt-Anchor\" href=\"#chapter-7-graph-algorithms\"></a> Chapter 7 Graph Algorithms</h1>\n<p><a name=\"TOgKc\"></a></p>\n<h2 id=\"graph-implement\"><a class=\"markdownIt-Anchor\" href=\"#graph-implement\"></a> <a href=\"https://stackoverflow.com/questions/5493474/graph-implementation-c\">Graph implement</a></h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1666956918039-3ebc54cf-6c4e-4feb-8f90-6473899dc634.jpeg\" alt></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">vertex</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, vertex* &gt; ve;</span><br><span class=\"line\">\t<span class=\"type\">int</span> name; </span><br><span class=\"line\">\t<span class=\"type\">int</span> seq;<span class=\"comment\">// serial number</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ind; <span class=\"comment\">// indegree</span></span><br><span class=\"line\">    <span class=\"type\">int</span> addition <span class=\"comment\">// additional Message </span></span><br><span class=\"line\">\tvector&lt;ve&gt; adj; <span class=\"comment\">// adjacent list:cost of edge, destination vertex</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vertex</span>(<span class=\"type\">int</span> n) :<span class=\"built_in\">name</span>(n),<span class=\"built_in\">seq</span>(<span class=\"number\">0</span>),<span class=\"built_in\">ind</span>(<span class=\"number\">0</span>)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Graph</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> map&lt;<span class=\"type\">int</span>, vertex*&gt; vmap;</span><br><span class=\"line\">\tvmap graph;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> from, <span class=\"type\">const</span> <span class=\"type\">int</span> to,<span class=\"type\">const</span> <span class=\"type\">int</span> weight)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addVertex</span><span class=\"params\">(<span class=\"type\">int</span> newSeq)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::addEdge</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> from, <span class=\"type\">const</span> <span class=\"type\">int</span> to, <span class=\"type\">const</span> <span class=\"type\">int</span> weight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tvertex* f = graph.<span class=\"built_in\">find</span>(from)-&gt;second;</span><br><span class=\"line\">\tvertex* t = graph.<span class=\"built_in\">find</span>(to)-&gt;second; </span><br><span class=\"line\">\tpair&lt;<span class=\"type\">int</span>, vertex*&gt; edge = <span class=\"built_in\">make_pair</span>(weight, t);</span><br><span class=\"line\">\tf-&gt;adj.<span class=\"built_in\">push_back</span>(edge);</span><br><span class=\"line\">    ++(t-&gt;ind);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::addVertex</span><span class=\"params\">(<span class=\"type\">int</span> newSeq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> iter = graph.<span class=\"built_in\">find</span>(newSeq);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (iter != graph.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvertex * v;</span><br><span class=\"line\">\t\tv = <span class=\"keyword\">new</span> <span class=\"built_in\">vertex</span>(newSeq);</span><br><span class=\"line\">\t\tgraph[newSeq] = v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Graph::size</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> graph.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitialGraph</span><span class=\"params\">(Graph&amp; myGraph)</span>  <span class=\"comment\">// a instance</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">2</span>); </span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addVertex</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);<span class=\"comment\">// as unweighted graph , weight = 1</span></span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>); </span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\tmyGraph.<span class=\"built_in\">addEdge</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"JeoiH\"></a></p>\n<h2 id=\"topological-sort\"><a class=\"markdownIt-Anchor\" href=\"#topological-sort\"></a> Topological Sort</h2>\n<p><a name=\"ueS0P\"></a></p>\n<h3 id=\"1-什么是拓扑排序意义是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是拓扑排序意义是什么\"></a> 1. 什么是拓扑排序？意义是什么？</h3>\n<p>首先先理解拓扑的含义：the way the parts of sth are arranged and related. 形象的来说：比如说一个人要自学计算机科学知识(sth)，而该领域知识由很多板块的内容(parts)构成，这些内容又相互关联(在学懂A课程前必须有B课程的基础，related)，那么他就面临一个问题，怎么安排学习顺序(路径，arranged)？一个显然不合理的安排是在学习操作系统先于数据结构与算法，因为数据结构与算法是学习OS的前置课程。<strong>一个不违反前置条件的学习路径就是一个拓扑排序，其意义就是得到一条合理的学习路径。<strong>说的更广泛一点，拓扑排序就是得到一个合理的处理顺序。<br>如果我们把各板块内容之间铺垫关系画成一张图，各板块为顶点，有向边作为关联(如 Vertex数据结构与算法指向Vertex操作系统)，那么</strong>拓扑排序在这个图中体现为一条沿着有向边方向的路径</strong>(即路径中任意一段单位路径u到v,不存在边(v,u))<br>显然，<strong>存在拓扑排序的图一定是有向无环图</strong>( directed acyclic graph，DAG),<a href=\"https://www.quora.com/Why-must-a-graph-with-a-topological-sort-be-acyclic-and-why-must-an-acyclic-graph-have-a-topological-sort\">如果图是有环的，那么就找不到符合要求的路径，因为总会违反前置条件</a><br>\n<a name=\"yLpq8\"></a></p>\n<h3 id=\"2-如何实现拓扑排序算法怎样使其更高效\"><a class=\"markdownIt-Anchor\" href=\"#2-如何实现拓扑排序算法怎样使其更高效\"></a> 2. 如何实现拓扑排序算法？怎样使其更高效？</h3>\n<p>对于我们要选择的第一个顶点，显然的，它必须没有前置条件，即没有顶点指向它，入度(indegree为0)。我们选择这样一个点，然后<strong>在图中抹去该点和它的边</strong>(显然的，都是由它发出的边，与它相关的顶点入度也随之更新)，在剩下的图中重复这个步骤，直到图为空(如果找不到入度为0的顶点而图不为空，说明图不是DAG，存在环)。顶点被抹去的顺序，就是拓扑排序。<br>如何快速寻找到入度为0的点呢？如果通过遍历顶点集的方式，那么开销是很大的，特别是如果图很稀疏(边很少，sparse)，那么要去除的边也是很少的，因此每一步被影响到入度的顶点的数量也是很少的，即大部分的顶点入度是一直没变的，反复的遍历它们是pointless行为。<br>提升效率方法是<strong>将入度为0的点单独拿出来，我们可以用栈或队列来存储。在每次去掉顶点和边之后，我们将更新后入度变为0的顶点加入到队列中</strong>。显然的，队列的出队顺序就是我们要求的拓扑排序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&quot;Graph.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TopologicalSort</span><span class=\"params\">(Graph&amp; myGraph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\tqueue&lt;vertex*&gt; zero;</span><br><span class=\"line\">\t<span class=\"type\">int</span> counter = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N = myGraph.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter :myGraph.graph) <span class=\"comment\">// initalize vertexSet which indegree is zero</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iter.second-&gt;ind == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tzero.<span class=\"built_in\">push</span>(iter.second);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!zero.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvertex* v = zero.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tzero.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tv-&gt;seq = ++counter;</span><br><span class=\"line\">\t\tcout &lt;&lt; v-&gt;name &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> adjN = v-&gt;adj.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; adjN; ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (--(v-&gt;adj[i].second-&gt;ind) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tzero.<span class=\"built_in\">push</span>(v-&gt;adj[i].second);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (counter != N<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"Ms2lL\"></a></p>\n<h2 id=\"shortest-path-algorithms\"><a class=\"markdownIt-Anchor\" href=\"#shortest-path-algorithms\"></a> Shortest-Path Algorithms</h2>\n<p><a name=\"TdCMl\"></a></p>\n<h3 id=\"1-什么是单源最短路径问题\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是单源最短路径问题\"></a> 1. 什么是单源最短路径问题？</h3>\n<p>单源最短路径问题(Single-Source Shortest-Path Problem): <strong>给定一个有权图(weighted graph,可以有环)中的一个点</strong><code>**v**</code><strong>，求出</strong><code>**v**</code><strong>到其它所有顶点的最短路径</strong>，that is ,在答案所呈现的结果图中，<code>v</code>到结果图中任意一个顶点<code>w</code>的路径，其长度是<code>v</code>与<code>w</code>之间存在的所有路径中，长度最短的那条。<br>也可以从另一个角度理解这个问题，即如果把边长视为开销，那么<strong>该问题就是要以最小的开销，从源顶点开始，覆盖整张图的顶点</strong><br>\n<a name=\"q5MIP\"></a></p>\n<h3 id=\"2为什么breadth-first-search可以解决unweighted-shortest-paths\"><a class=\"markdownIt-Anchor\" href=\"#2为什么breadth-first-search可以解决unweighted-shortest-paths\"></a> 2.为什么Breadth-First Search可以解决Unweighted Shortest-Paths?</h3>\n<p>为了理解SSSP问题，我们先考虑无权图，无权图可视为权重为1的有权图<br>我们先设置问题的初始状态：<code>v</code>到任意<code>w</code>的距离都是无穷大，任意<code>w</code>的状态都是unknown(<code>v</code>到该<code>w</code>的最短路径还未确定)。<br>我们首先能确定的是<code>v</code>能直接到达的点(<code>v</code>的邻接点)，因为v只有唯一途径能到达这些点，所以这个唯一途径就是最短路径。我们把这些点称为第一层，其最短路径均为1。接着，我们能确定的点显然是第一层的邻接点，<strong>因为</strong><code>**v**</code><strong>能通过第一层的点去访问只有这些点</strong>，我们把这些点称为第二层，其最短路径自然为2。按照这样的一个广度优先搜索的逻辑，我们便能确定所有点的最短路径。<br>因为是无权图，所以不存在对路径长度的多次更新（关于该点可见后续讨论中的例子：不存在将s-&gt;w1-&gt;w3更改为s-&gt;w2-&gt;w3的可能），对每个顶点的处理，只需简单的将其distance信息设置为前一个顶点的distance+1即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::unweighted_Shortest_Path_with_queue</span><span class=\"params\">(vertex&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tqueue&lt;vertex*&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)</span><br><span class=\"line\">\t\titer.second-&gt;dist = INFINITY;</span><br><span class=\"line\">\ts.dist = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(&amp;s);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvertex v = *q.<span class=\"built_in\">front</span>(); <span class=\"comment\">// priority &#x27;.&#x27; &gt; &#x27;*&#x27;</span></span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; adjac : v.adj)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tadjac.second-&gt;dist = v.dist + <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\tadjac.second-&gt;path = v.name;</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">push</span>(adjac.second);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::unweighted_Shortest_Path</span><span class=\"params\">(vertex&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> NUM_VERTICES = <span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titer.second-&gt;dist = INFINITY;</span><br><span class=\"line\">\t\titer.second-&gt;known = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.dist = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> currDist = <span class=\"number\">0</span>; currDist &lt; NUM_VERTICES; ++currDist) <span class=\"comment\">// double for loops:inefficiency</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!iter.second-&gt;known &amp;&amp; iter.second-&gt;dist == currDist)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\titer.second-&gt;known = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; adjac : (iter.second-&gt;adj))</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tadjac.second-&gt;dist = currDist + <span class=\"number\">1</span>; <span class=\"comment\">// update distance</span></span><br><span class=\"line\">\t\t\t\t\tadjac.second-&gt;path = iter.second-&gt;name;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"YjF5L\"></a></p>\n<h3 id=\"3为什么dijkstra-algorithm每一步要选择最近的结点为什么该算法可以解决single-source-weighted\"><a class=\"markdownIt-Anchor\" href=\"#3为什么dijkstra-algorithm每一步要选择最近的结点为什么该算法可以解决single-source-weighted\"></a> 3.为什么Dijkstra Algorithm每一步要选择最近的结点，为什么该算法可以解决Single-Source Weighted？</h3>\n<p>与上一问一样，要找到<code>v</code>到所有顶点的最短路径，我们总得先知道<code>v</code>能到达哪些点。所以我们在用Dijkstra解决SSSP的时候，我们似乎也应该按照这样的结点选择顺序：首先找的是<code>v</code>的邻接点，然后再邻接点… 。但是我们需要注意，<strong>我们实际选择结点的顺序(选择结点即把结点变为known，说明找到了到它的最短路径)，是不断的选取未确定结点中离</strong><code>**v**</code><strong>距离最近的那一个，而不是像无权图中那样邻接点接着邻接点的广度搜索。</strong><br><strong>为什么要选择最近的那一个？</strong><br>举个最简单的例子：在这个图中，我们首先探索了源顶点的邻接点w1,w2，更新其dist为ds+dcost，那么w1.dist=1，w2.dist =3。那么下一轮我们选择那个顶点进行探索(其邻接点)呢？显然是w1，因为在当前条件下，我们只知道源顶点离w1更近一些，那么到w3(后续未知结点)的最短路径自然更可能的在w1这边(我们还不知道后续顶点的dist信息)。<strong>因此我们在每次选择一个顶点以探索他的邻接点(更新dist信息)，都要选择当前距离v最近的那个，因为经过这样一个点的路径才最有可能是(到后续顶点)最短路径/开销可能最少。</strong><br>为什么在无权图中不用这样做？<br>无权图的边长权重都为1，开销的是一样的。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1667390674960-21e67dd1-f11c-4336-a168-c237056626fe.jpeg\" alt><br>我们要有一个认知：<strong>源顶点</strong><code>**v**</code><strong>到某一目标顶点</strong><code>**w****t**</code><strong>之间的最短路径①上存在着几个中间顶点，那么v到任意一个中间结点</strong><code>**w****i**</code>**的最短路径②一定与①重合。**或者说v到目标顶点的最短路径，是目标顶点在该路径的上一个顶点的最短路径延长了一个边长所得到的。<br><strong>因此我们逐步找到各顶点的最短路径，并从之前找到的最短路径(以开销最少的方式)延展到其它顶点上，便可以找到到所有顶点的最短路径。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Graph::Dijkstra_Algorithm</span><span class=\"params\">(vertex&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titer.second-&gt;dist = INFINITY;</span><br><span class=\"line\">\t\titer.second-&gt;known = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.dist = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">existUnknown</span>()) <span class=\"comment\">//there is an unknown vertex</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"> \t\tvertex* v = <span class=\"built_in\">smallestUnknown</span>();   <span class=\"comment\">// smallest unknown distance vertex</span></span><br><span class=\"line\">\t\tv-&gt;known = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : v-&gt;adj)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v-&gt;dist + iter.first &lt; iter.second-&gt;dist) </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\titer.second-&gt;dist = v-&gt;dist + iter.first; <span class=\"comment\">// update</span></span><br><span class=\"line\">\t\t\t\titer.second-&gt;path = v-&gt;name;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Graph:: <span class=\"built_in\">existUnknown</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)  <span class=\"comment\">// iteration </span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!iter.second-&gt;known)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vertex* <span class=\"title\">Graph::smallestUnknown</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tvertex* min = graph.<span class=\"built_in\">begin</span>()-&gt;second;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; iter : graph)  <span class=\"comment\">// iteration </span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!iter.second-&gt;known &amp;&amp; iter.second-&gt;dist &lt; min-&gt;dist)</span><br><span class=\"line\">\t\t\tmin = iter.second;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"b4gnk\"></a></p>\n<h3 id=\"4为什么dijkstra-algorithm不适用于有负权值边的图\"><a class=\"markdownIt-Anchor\" href=\"#4为什么dijkstra-algorithm不适用于有负权值边的图\"></a> 4.为什么Dijkstra Algorithm不适用于有负权值边的图</h3>\n<p>在Dijkstra算法中，我们<strong>一旦将一个顶点</strong><code>**v**</code><strong>由unknown标记为known，就说明由</strong><code>**s**</code><strong>到</strong><code>**v**</code><strong>的最短路径已经找到，且不会再改变，即算法不会在后续过程中回头(look back)修改到</strong><code>**v**</code><strong>的最短路程这一信息</strong>。如果我们用Dijkstra算法在图中确定了<code>v</code>的最短路径，然后发现<code>v</code>到某个邻接点<code>u</code>(状态为unknown)的边权值为负，那么此时<code>s</code>到<code>v</code>的实际最短路径就发生了变化：s-&gt;v-&gt;w-&gt;v，然而因为Dijkstra算法不会look back，所以算法继续保持之前的最短路径，因此会产生与事实不符的结果。<br>\n<a name=\"wzqMO\"></a></p>\n<h2 id=\"critical-path-problems\"><a class=\"markdownIt-Anchor\" href=\"#critical-path-problems\"></a> Critical Path Problems</h2>\n<p><a name=\"MCV9V\"></a></p>\n<h3 id=\"1-如何理解关键路径关键路径是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-如何理解关键路径关键路径是什么\"></a> 1. 如何理解关键路径？关键路径是什么？</h3>\n<p>一个项目由多个可独立完成工作(jobs)组成，各工作之间存在优先级限制关系(precedence constraint)，即某一项工作必须在完成另一项(或多项)工作后才能启动。①如何确定项目的最快(早)完成时间？②如何确定某些工作的可延迟时间 (that is,slack time 松弛时间) 以不至于增加整个项目的完成时间？<br><strong>关键路径这样一组工作序列：该工作序列可以用来确定项目的最快完成时间。对第二点，关键路径上的所有工作的可延迟时间均为0，关键路径上的任何一个工作被延迟，都会增加整个项目的完成时间，这也是为什么称之为&quot;关键&quot;。</strong><br>这样的项目可以体现在有向无环图中。为什么一定是无环？与拓扑排序一样的道理，如果有几个工作成环状相互制约，那就无法开启任何一项工作，因为总是违反其优先级限制关系。<strong>关键路径在这样的图中体现为从开始到结束的最长路径(longest path)</strong><br>注意路径的长度由边的权值(工作完成所需时间)决定而不是边的数量<br>\n<a name=\"oj5FV\"></a></p>\n<h3 id=\"2-为什么图的最长路径就是关键路径\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么图的最长路径就是关键路径\"></a> 2. 为什么图的最长路径就是关键路径？</h3>\n<blockquote>\n<p>关键路径是通过识别最长的相关活动并测量从开始到结束完成它们所需的时间来确定的 -wikipedia</p>\n</blockquote>\n<p>我们首先要理解一条路径上的各个工作节点之间存在着严格的先后关系，即优先级限制关系。这就说明<strong>各工作只能串行的执行</strong>，哪怕你有很多处理器(processors)也必须等待高优先级的工作执行完毕后再开启新的工作。互不关联(不在同一路径)的工作可以并行的执行，所以<strong>在最长路径上的最后一个工作执行完毕时，其它路径也一定执行完毕，即整个项目执行完毕。因此最长路径决定了项目的完成时间，不延迟的执行最长路径(上的工作)所花的时间，就是项目的最快完成时间。</strong><br>\n<a name=\"Aa03a\"></a></p>\n<h2 id=\"network-flow-problems\"><a class=\"markdownIt-Anchor\" href=\"#network-flow-problems\"></a> Network Flow Problems</h2>\n<p><a name=\"RBuq3\"></a></p>\n<h3 id=\"1-如何理解网络流问题\"><a class=\"markdownIt-Anchor\" href=\"#1-如何理解网络流问题\"></a> 1. 如何理解网络流问题？</h3>\n<p>网络流问题就是从一个端<code>s</code>往另一个端<code>t</code>发送流(Flow,如通水，运货，发送数据包等)，要经过数个中间节点，各节点间的边的传输容量是有限的(如水管的阈值，超过了这个值水管会破裂)，问从s发送到t的最大流(the maximum amount of ﬂow)是多少。显然的要找出这个最大流，<strong>我们要解决的根本问题是如何正确安排运输方案(即路径选择)以最大化流</strong>。<br><strong>如何计算图中流的数量(the amount of ﬂow)？</strong> <strong>只需看从端</strong><code>**s**</code><strong>发出了多少流即可</strong>(端<code>t</code>肯定接受同样数量的流，除非“漏水”了)<br>**怎么验证我们得到的流的数量是最大的？**把图分割(cut)为两个部分，一部分包含s，另一部分包含t(其余结点随意，因此存在多种切割方式)，<strong>经过切割线上的边的容量总和决定了最大流的界限，容量总和的最小值即为图所能承受的最大流的值(the minimum cut capacity is exactly equal to the maximum ﬂow)</strong><br>由此我们可以看出，<strong>解决最大流问题的目的不是为了得到最大流的值，而是知道能达到最大流的运输方案</strong><br><a href=\"https://www.youtube.com/watch?v=6DFWUgV5Osc&amp;list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&amp;index=8\"><strong>网络流问题基础 Network Flow Problems</strong></a><br>\n<a name=\"LytbY\"></a></p>\n<h3 id=\"2-如何得到最大流\"><a class=\"markdownIt-Anchor\" href=\"#2-如何得到最大流\"></a> 2. 如何得到最大流？</h3>\n<p>首先考虑简单的算法(naive algorithm )，我们随机的选择路径( free to choose any path from s to t)，直到Gr中不存在s到t的路径，看能否得到最大流，事实证明，这样是不可靠的，得到的方案可能会使我们会得到一个小于最大流的值。<strong>该方法存在的缺陷是，一旦在某一步选中了错误的路径(不属于最大流方案的路径)，算法无法纠正错误，因此找不到最大流。</strong><br>我们改进一下这个算法，<strong>在每次进行一次路径选择(即在G<strong><strong>r</strong></strong>图中相应边执行了减法)之后，接着在相应边上加上一条方向相反的边，其权值就等于刚刚该边减去的值。称为Ford–Fulkerson algorithm</strong><br><strong>这样做的目的，是让算法有了撤销(undo)的能力，可以把不好的路径撤销掉，因此该算法总能找到正确的路径，进而找到最大流。</strong><br><a href=\"https://www.youtube.com/watch?v=8sLON0DqLZo&amp;list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&amp;index=9\">**Ford-Fulkerson Algorithm 寻找网络最大流  -Dr Wang **</a></p>"},{"title":"ubuntu界面Mac化","date":"2023-03-27T04:00:00.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n最终效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904915178-2b8d446d-4d5f-42d7-9850-d5a4c0dc0bcf.png#averageHue=%232dc92b&clientId=u8ce3d915-14ae-4&from=paste&height=565&id=ueeea8242&name=image.png&originHeight=848&originWidth=1914&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=159245&status=done&style=none&taskId=u5fb92b60-b558-40fb-9a44-b1f4da5e687&title=&width=1276)\n<a name=\"s7Ott\"></a>\n<!--more-->\n# 1. 安装GNOME Tweaks\n这个软件可以让你配置Ubuntu的交互界面，你可以在Ubuntu自带的由GNOME Software 下载<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679900946204-c742a5d9-a91a-4b67-8a85-b82a66b80d98.png#averageHue=%235e5e5e&clientId=ud601214a-d7ed-4&from=paste&height=390&id=u117233a8&name=image.png&originHeight=743&originWidth=1084&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=75219&status=done&style=none&taskId=uaaab7274-262a-40dc-b6b7-e1858e9749d&title=&width=568.760009765625)\n\n<a name=\"i6Rr5\"></a>\n# 2.下载安装模拟Mac风格的交互界面主题[WhiteSur-gtk-theme](https://github.com/vinceliuice/WhiteSur-gtk-theme)\n```bash\ngit clone https://github.com/vinceliuice/WhiteSur-gtk-theme.git\ncd WhiteSur-gtk-theme\n./install.sh\n```\n<a name=\"dH9pb\"></a>\n# 3. 下载Mac图标集\n```bash\ngit clone https://github.com/vinceliuice/WhiteSur-icon-theme\ncd  WhiteSur-icon-theme\n./install.sh\n```\n<a name=\"cwXmK\"></a>\n# 4. 解除Gnome Tweak Tool 中的扩展禁用状态\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901490751-dac0bd23-34aa-40db-a176-024e2f42459f.png#averageHue=%234d4c4c&clientId=ud601214a-d7ed-4&from=paste&height=400&id=u37ab7a7f&name=image.png&originHeight=625&originWidth=1044&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=100597&status=done&style=none&taskId=u1f3960dc-937b-4e46-b496-68fe90b71d4&title=&width=668.16)<br />安装`chrome-gnome-shell`\n```bash\nsudo apt install chrome-gnome-shell\n```\n接着跳转到[User Themes](https://extensions.gnome.org/extension/19/user-themes/)<br />安装该插件并开启<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901620872-e69d3a78-b565-4b13-9736-46750d55fe6b.png#averageHue=%23fcfcfb&clientId=ud601214a-d7ed-4&from=paste&height=272&id=uaa079ca5&name=image.png&originHeight=425&originWidth=1447&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=60616&status=done&style=none&taskId=uf904ddd5-8741-44fd-b6ad-7a7442b5c3c&title=&width=926.08)<br />解决<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901649198-a2f7d303-960f-4b35-b96e-0bc7c8ae464b.png#averageHue=%23353534&clientId=ud601214a-d7ed-4&from=paste&height=390&id=u3191091d&name=image.png&originHeight=609&originWidth=1044&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=76490&status=done&style=none&taskId=u79e6d1ca-ed2a-420f-9c0b-caec1b63807&title=&width=668.16)\n\n<a name=\"p4iNI\"></a>\n# 5. 安装Mac风格的Dock\n安装并开启[Dash to Dock](https://extensions.gnome.org/extension/307/dash-to-dock/)，并可自行设置Dock样式<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679903078052-658ae42a-c311-4990-93f7-dc8700c3ddb5.png#averageHue=%23696969&clientId=u33b15efd-72b8-4&from=paste&height=437&id=ub859c8a3&name=image.png&originHeight=683&originWidth=1385&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=168939&status=done&style=none&taskId=u7cf1d85f-9a5e-4770-8407-ce5971d3b0b&title=&width=886.4)\n\n<a name=\"EAoF9\"></a>\n# 6. 将交通灯移动到窗口右侧\n在GNOME Tweaks -> Window Titlebars -> Left<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904374525-112bf886-c3ed-4b08-8636-460188802e21.png#averageHue=%23393938&clientId=u053a5944-acf3-4&from=paste&height=429&id=u3ec2f613&name=image.png&originHeight=643&originWidth=1066&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79002&status=done&style=none&taskId=u3d4a3f13-0d2f-4d62-9dff-3a863f75003&title=&width=710.6666666666666)\n\n","source":"_posts/ubuntu_mac.md","raw":"---\ntitle: ubuntu界面Mac化 \ndate: 2023/3/27\ncategories:\n- gadget \ntags: \n- tutorial\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n最终效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904915178-2b8d446d-4d5f-42d7-9850-d5a4c0dc0bcf.png#averageHue=%232dc92b&clientId=u8ce3d915-14ae-4&from=paste&height=565&id=ueeea8242&name=image.png&originHeight=848&originWidth=1914&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=159245&status=done&style=none&taskId=u5fb92b60-b558-40fb-9a44-b1f4da5e687&title=&width=1276)\n<a name=\"s7Ott\"></a>\n<!--more-->\n# 1. 安装GNOME Tweaks\n这个软件可以让你配置Ubuntu的交互界面，你可以在Ubuntu自带的由GNOME Software 下载<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679900946204-c742a5d9-a91a-4b67-8a85-b82a66b80d98.png#averageHue=%235e5e5e&clientId=ud601214a-d7ed-4&from=paste&height=390&id=u117233a8&name=image.png&originHeight=743&originWidth=1084&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=75219&status=done&style=none&taskId=uaaab7274-262a-40dc-b6b7-e1858e9749d&title=&width=568.760009765625)\n\n<a name=\"i6Rr5\"></a>\n# 2.下载安装模拟Mac风格的交互界面主题[WhiteSur-gtk-theme](https://github.com/vinceliuice/WhiteSur-gtk-theme)\n```bash\ngit clone https://github.com/vinceliuice/WhiteSur-gtk-theme.git\ncd WhiteSur-gtk-theme\n./install.sh\n```\n<a name=\"dH9pb\"></a>\n# 3. 下载Mac图标集\n```bash\ngit clone https://github.com/vinceliuice/WhiteSur-icon-theme\ncd  WhiteSur-icon-theme\n./install.sh\n```\n<a name=\"cwXmK\"></a>\n# 4. 解除Gnome Tweak Tool 中的扩展禁用状态\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901490751-dac0bd23-34aa-40db-a176-024e2f42459f.png#averageHue=%234d4c4c&clientId=ud601214a-d7ed-4&from=paste&height=400&id=u37ab7a7f&name=image.png&originHeight=625&originWidth=1044&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=100597&status=done&style=none&taskId=u1f3960dc-937b-4e46-b496-68fe90b71d4&title=&width=668.16)<br />安装`chrome-gnome-shell`\n```bash\nsudo apt install chrome-gnome-shell\n```\n接着跳转到[User Themes](https://extensions.gnome.org/extension/19/user-themes/)<br />安装该插件并开启<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901620872-e69d3a78-b565-4b13-9736-46750d55fe6b.png#averageHue=%23fcfcfb&clientId=ud601214a-d7ed-4&from=paste&height=272&id=uaa079ca5&name=image.png&originHeight=425&originWidth=1447&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=60616&status=done&style=none&taskId=uf904ddd5-8741-44fd-b6ad-7a7442b5c3c&title=&width=926.08)<br />解决<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901649198-a2f7d303-960f-4b35-b96e-0bc7c8ae464b.png#averageHue=%23353534&clientId=ud601214a-d7ed-4&from=paste&height=390&id=u3191091d&name=image.png&originHeight=609&originWidth=1044&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=76490&status=done&style=none&taskId=u79e6d1ca-ed2a-420f-9c0b-caec1b63807&title=&width=668.16)\n\n<a name=\"p4iNI\"></a>\n# 5. 安装Mac风格的Dock\n安装并开启[Dash to Dock](https://extensions.gnome.org/extension/307/dash-to-dock/)，并可自行设置Dock样式<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679903078052-658ae42a-c311-4990-93f7-dc8700c3ddb5.png#averageHue=%23696969&clientId=u33b15efd-72b8-4&from=paste&height=437&id=ub859c8a3&name=image.png&originHeight=683&originWidth=1385&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=168939&status=done&style=none&taskId=u7cf1d85f-9a5e-4770-8407-ce5971d3b0b&title=&width=886.4)\n\n<a name=\"EAoF9\"></a>\n# 6. 将交通灯移动到窗口右侧\n在GNOME Tweaks -> Window Titlebars -> Left<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904374525-112bf886-c3ed-4b08-8636-460188802e21.png#averageHue=%23393938&clientId=u053a5944-acf3-4&from=paste&height=429&id=u3ec2f613&name=image.png&originHeight=643&originWidth=1066&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79002&status=done&style=none&taskId=u3d4a3f13-0d2f-4d62-9dff-3a863f75003&title=&width=710.6666666666666)\n\n","slug":"ubuntu_mac","published":1,"updated":"2023-03-28T09:36:03.706Z","_id":"clfs2874g00005umo71gu1e5s","comments":1,"layout":"post","photos":[],"link":"","content":"<p><meta name=\"referrer\" content=\"no-referrer\"><br>最终效果：<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904915178-2b8d446d-4d5f-42d7-9850-d5a4c0dc0bcf.png#averageHue=%232dc92b&amp;clientId=u8ce3d915-14ae-4&amp;from=paste&amp;height=565&amp;id=ueeea8242&amp;name=image.png&amp;originHeight=848&amp;originWidth=1914&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=159245&amp;status=done&amp;style=none&amp;taskId=u5fb92b60-b558-40fb-9a44-b1f4da5e687&amp;title=&amp;width=1276\" alt=\"image.png\"><br><a name=\"s7Ott\"></a><br><span id=\"more\"></span></p>\n<h1 id=\"1-安装GNOME-Tweaks\"><a href=\"#1-安装GNOME-Tweaks\" class=\"headerlink\" title=\"1. 安装GNOME Tweaks\"></a>1. 安装GNOME Tweaks</h1><p>这个软件可以让你配置Ubuntu的交互界面，你可以在Ubuntu自带的由GNOME Software 下载<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679900946204-c742a5d9-a91a-4b67-8a85-b82a66b80d98.png#averageHue=%235e5e5e&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u117233a8&amp;name=image.png&amp;originHeight=743&amp;originWidth=1084&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=75219&amp;status=done&amp;style=none&amp;taskId=uaaab7274-262a-40dc-b6b7-e1858e9749d&amp;title=&amp;width=568.760009765625\" alt=\"image.png\"></p>\n<p><a name=\"i6Rr5\"></a></p>\n<h1 id=\"2-下载安装模拟Mac风格的交互界面主题WhiteSur-gtk-theme\"><a href=\"#2-下载安装模拟Mac风格的交互界面主题WhiteSur-gtk-theme\" class=\"headerlink\" title=\"2.下载安装模拟Mac风格的交互界面主题WhiteSur-gtk-theme\"></a>2.下载安装模拟Mac风格的交互界面主题<a href=\"https://github.com/vinceliuice/WhiteSur-gtk-theme\">WhiteSur-gtk-theme</a></h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/vinceliuice/WhiteSur-gtk-theme.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> WhiteSur-gtk-theme</span><br><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure>\n<p><a name=\"dH9pb\"></a></p>\n<h1 id=\"3-下载Mac图标集\"><a href=\"#3-下载Mac图标集\" class=\"headerlink\" title=\"3. 下载Mac图标集\"></a>3. 下载Mac图标集</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/vinceliuice/WhiteSur-icon-theme</span><br><span class=\"line\"><span class=\"built_in\">cd</span>  WhiteSur-icon-theme</span><br><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure>\n<p><a name=\"cwXmK\"></a></p>\n<h1 id=\"4-解除Gnome-Tweak-Tool-中的扩展禁用状态\"><a href=\"#4-解除Gnome-Tweak-Tool-中的扩展禁用状态\" class=\"headerlink\" title=\"4. 解除Gnome Tweak Tool 中的扩展禁用状态\"></a>4. 解除Gnome Tweak Tool 中的扩展禁用状态</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901490751-dac0bd23-34aa-40db-a176-024e2f42459f.png#averageHue=%234d4c4c&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=400&amp;id=u37ab7a7f&amp;name=image.png&amp;originHeight=625&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=100597&amp;status=done&amp;style=none&amp;taskId=u1f3960dc-937b-4e46-b496-68fe90b71d4&amp;title=&amp;width=668.16\" alt=\"image.png\"><br>安装<code>chrome-gnome-shell</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure><br>接着跳转到<a href=\"https://extensions.gnome.org/extension/19/user-themes/\">User Themes</a><br>安装该插件并开启<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901620872-e69d3a78-b565-4b13-9736-46750d55fe6b.png#averageHue=%23fcfcfb&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=272&amp;id=uaa079ca5&amp;name=image.png&amp;originHeight=425&amp;originWidth=1447&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=60616&amp;status=done&amp;style=none&amp;taskId=uf904ddd5-8741-44fd-b6ad-7a7442b5c3c&amp;title=&amp;width=926.08\" alt=\"image.png\"><br>解决<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901649198-a2f7d303-960f-4b35-b96e-0bc7c8ae464b.png#averageHue=%23353534&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u3191091d&amp;name=image.png&amp;originHeight=609&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=76490&amp;status=done&amp;style=none&amp;taskId=u79e6d1ca-ed2a-420f-9c0b-caec1b63807&amp;title=&amp;width=668.16\" alt=\"image.png\"></p>\n<p><a name=\"p4iNI\"></a></p>\n<h1 id=\"5-安装Mac风格的Dock\"><a href=\"#5-安装Mac风格的Dock\" class=\"headerlink\" title=\"5. 安装Mac风格的Dock\"></a>5. 安装Mac风格的Dock</h1><p>安装并开启<a href=\"https://extensions.gnome.org/extension/307/dash-to-dock/\">Dash to Dock</a>，并可自行设置Dock样式<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679903078052-658ae42a-c311-4990-93f7-dc8700c3ddb5.png#averageHue=%23696969&amp;clientId=u33b15efd-72b8-4&amp;from=paste&amp;height=437&amp;id=ub859c8a3&amp;name=image.png&amp;originHeight=683&amp;originWidth=1385&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=168939&amp;status=done&amp;style=none&amp;taskId=u7cf1d85f-9a5e-4770-8407-ce5971d3b0b&amp;title=&amp;width=886.4\" alt=\"image.png\"></p>\n<p><a name=\"EAoF9\"></a></p>\n<h1 id=\"6-将交通灯移动到窗口右侧\"><a href=\"#6-将交通灯移动到窗口右侧\" class=\"headerlink\" title=\"6. 将交通灯移动到窗口右侧\"></a>6. 将交通灯移动到窗口右侧</h1><p>在GNOME Tweaks -&gt; Window Titlebars -&gt; Left<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904374525-112bf886-c3ed-4b08-8636-460188802e21.png#averageHue=%23393938&amp;clientId=u053a5944-acf3-4&amp;from=paste&amp;height=429&amp;id=u3ec2f613&amp;name=image.png&amp;originHeight=643&amp;originWidth=1066&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=79002&amp;status=done&amp;style=none&amp;taskId=u3d4a3f13-0d2f-4d62-9dff-3a863f75003&amp;title=&amp;width=710.6666666666666\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"<p><meta name=\"referrer\" content=\"no-referrer\"><br>最终效果：<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904915178-2b8d446d-4d5f-42d7-9850-d5a4c0dc0bcf.png#averageHue=%232dc92b&amp;clientId=u8ce3d915-14ae-4&amp;from=paste&amp;height=565&amp;id=ueeea8242&amp;name=image.png&amp;originHeight=848&amp;originWidth=1914&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=159245&amp;status=done&amp;style=none&amp;taskId=u5fb92b60-b558-40fb-9a44-b1f4da5e687&amp;title=&amp;width=1276\" alt=\"image.png\"><br><a name=\"s7Ott\"></a><br></p>","more":"<p></p>\n<h1 id=\"1-安装GNOME-Tweaks\"><a href=\"#1-安装GNOME-Tweaks\" class=\"headerlink\" title=\"1. 安装GNOME Tweaks\"></a>1. 安装GNOME Tweaks</h1><p>这个软件可以让你配置Ubuntu的交互界面，你可以在Ubuntu自带的由GNOME Software 下载<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679900946204-c742a5d9-a91a-4b67-8a85-b82a66b80d98.png#averageHue=%235e5e5e&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u117233a8&amp;name=image.png&amp;originHeight=743&amp;originWidth=1084&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=75219&amp;status=done&amp;style=none&amp;taskId=uaaab7274-262a-40dc-b6b7-e1858e9749d&amp;title=&amp;width=568.760009765625\" alt=\"image.png\"></p>\n<p><a name=\"i6Rr5\"></a></p>\n<h1 id=\"2-下载安装模拟Mac风格的交互界面主题WhiteSur-gtk-theme\"><a href=\"#2-下载安装模拟Mac风格的交互界面主题WhiteSur-gtk-theme\" class=\"headerlink\" title=\"2.下载安装模拟Mac风格的交互界面主题WhiteSur-gtk-theme\"></a>2.下载安装模拟Mac风格的交互界面主题<a href=\"https://github.com/vinceliuice/WhiteSur-gtk-theme\">WhiteSur-gtk-theme</a></h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/vinceliuice/WhiteSur-gtk-theme.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> WhiteSur-gtk-theme</span><br><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure>\n<p><a name=\"dH9pb\"></a></p>\n<h1 id=\"3-下载Mac图标集\"><a href=\"#3-下载Mac图标集\" class=\"headerlink\" title=\"3. 下载Mac图标集\"></a>3. 下载Mac图标集</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/vinceliuice/WhiteSur-icon-theme</span><br><span class=\"line\"><span class=\"built_in\">cd</span>  WhiteSur-icon-theme</span><br><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure>\n<p><a name=\"cwXmK\"></a></p>\n<h1 id=\"4-解除Gnome-Tweak-Tool-中的扩展禁用状态\"><a href=\"#4-解除Gnome-Tweak-Tool-中的扩展禁用状态\" class=\"headerlink\" title=\"4. 解除Gnome Tweak Tool 中的扩展禁用状态\"></a>4. 解除Gnome Tweak Tool 中的扩展禁用状态</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901490751-dac0bd23-34aa-40db-a176-024e2f42459f.png#averageHue=%234d4c4c&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=400&amp;id=u37ab7a7f&amp;name=image.png&amp;originHeight=625&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=100597&amp;status=done&amp;style=none&amp;taskId=u1f3960dc-937b-4e46-b496-68fe90b71d4&amp;title=&amp;width=668.16\" alt=\"image.png\"><br>安装<code>chrome-gnome-shell</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure><br>接着跳转到<a href=\"https://extensions.gnome.org/extension/19/user-themes/\">User Themes</a><br>安装该插件并开启<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901620872-e69d3a78-b565-4b13-9736-46750d55fe6b.png#averageHue=%23fcfcfb&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=272&amp;id=uaa079ca5&amp;name=image.png&amp;originHeight=425&amp;originWidth=1447&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=60616&amp;status=done&amp;style=none&amp;taskId=uf904ddd5-8741-44fd-b6ad-7a7442b5c3c&amp;title=&amp;width=926.08\" alt=\"image.png\"><br>解决<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901649198-a2f7d303-960f-4b35-b96e-0bc7c8ae464b.png#averageHue=%23353534&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u3191091d&amp;name=image.png&amp;originHeight=609&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=76490&amp;status=done&amp;style=none&amp;taskId=u79e6d1ca-ed2a-420f-9c0b-caec1b63807&amp;title=&amp;width=668.16\" alt=\"image.png\"></p>\n<p><a name=\"p4iNI\"></a></p>\n<h1 id=\"5-安装Mac风格的Dock\"><a href=\"#5-安装Mac风格的Dock\" class=\"headerlink\" title=\"5. 安装Mac风格的Dock\"></a>5. 安装Mac风格的Dock</h1><p>安装并开启<a href=\"https://extensions.gnome.org/extension/307/dash-to-dock/\">Dash to Dock</a>，并可自行设置Dock样式<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679903078052-658ae42a-c311-4990-93f7-dc8700c3ddb5.png#averageHue=%23696969&amp;clientId=u33b15efd-72b8-4&amp;from=paste&amp;height=437&amp;id=ub859c8a3&amp;name=image.png&amp;originHeight=683&amp;originWidth=1385&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=168939&amp;status=done&amp;style=none&amp;taskId=u7cf1d85f-9a5e-4770-8407-ce5971d3b0b&amp;title=&amp;width=886.4\" alt=\"image.png\"></p>\n<p><a name=\"EAoF9\"></a></p>\n<h1 id=\"6-将交通灯移动到窗口右侧\"><a href=\"#6-将交通灯移动到窗口右侧\" class=\"headerlink\" title=\"6. 将交通灯移动到窗口右侧\"></a>6. 将交通灯移动到窗口右侧</h1><p>在GNOME Tweaks -&gt; Window Titlebars -&gt; Left<br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904374525-112bf886-c3ed-4b08-8636-460188802e21.png#averageHue=%23393938&amp;clientId=u053a5944-acf3-4&amp;from=paste&amp;height=429&amp;id=u3ec2f613&amp;name=image.png&amp;originHeight=643&amp;originWidth=1066&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=79002&amp;status=done&amp;style=none&amp;taskId=u3d4a3f13-0d2f-4d62-9dff-3a863f75003&amp;title=&amp;width=710.6666666666666\" alt=\"image.png\"></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"clfmf6v9n00031gva2cr781jt","category_id":"clfmf6v9s00051gva4w9b9z3q","_id":"clfmf6v9w000a1gvaglu57t3y"},{"post_id":"clfmf6v9r00041gvaf24ub5l2","category_id":"clfmf6v9s00051gva4w9b9z3q","_id":"clfmf6v9w000c1gva2jgn3z72"},{"post_id":"clfqu81go0000vymo267cfg4d","category_id":"clfmf6v9s00051gva4w9b9z3q","_id":"clfqu81gz0002vymo05qx9ckc"},{"post_id":"clfqu81jy0003vymo73rohact","category_id":"clfqu81k00004vymofy5la1xc","_id":"clfqu81k30006vymo2e98e1b6"},{"post_id":"clfs2874g00005umo71gu1e5s","category_id":"clfs2azfg0000ermob7x8gznp","_id":"clfs2azfl0003ermo76pn9u8c"}],"PostTag":[{"post_id":"clfmf6v9n00031gva2cr781jt","tag_id":"clfmf6v9t00061gva5zy27gic","_id":"clfmf6v9v00091gva4jyhgdyf"},{"post_id":"clfmf6v9r00041gvaf24ub5l2","tag_id":"clfmf6v9t00061gva5zy27gic","_id":"clfmf6v9w000b1gva9qzn30t1"},{"post_id":"clfqu81go0000vymo267cfg4d","tag_id":"clfmf6v9t00061gva5zy27gic","_id":"clfqu81gy0001vymogifcgx71"},{"post_id":"clfqu81jy0003vymo73rohact","tag_id":"clfmf6v9t00061gva5zy27gic","_id":"clfqu81k30005vymoaadf3k4t"},{"post_id":"clfs2874g00005umo71gu1e5s","tag_id":"clfs2azfj0001ermo8i933y6h","_id":"clfs2azfl0002ermofpbw6s3j"}],"Tag":[{"name":"Foundation","_id":"clfmf6v9t00061gva5zy27gic"},{"name":"tutorial","_id":"clfs2azfj0001ermo8i933y6h"}]}}